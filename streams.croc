module streams

import exceptions:
	BoundsException,
	IOException,
	NotImplementedException,
	RangeException,
	TypeException,
	ValueException

import math:
	min

local function clamp(x, lo, hi) =
	x < lo ? lo : x > hi ? hi : x

class EOFClass {}

/**
A value that represents an end-of-file condition.

The value of this variable doesn't really matter, only so long as it's unique. This value will be returned by API functions
when end-of-file is reached. You can then test for an end-of-file condition by using \tt{returnValue is stream.EOF}.

Note that the "core" stream API does not use this value to signify end-of-file. This value is used by the higher level APIs.
*/
global EOF = EOFClass()

/**
A helper function for checking the params to stream \tt{read} and \tt{write} functions.

This ensures that the \tt{offset} and \tt{size} parameters are valid, and throws exceptions if not.

\throws[exceptions.BoundsException] if either \tt{offset} or \tt{size} is invalid.
*/
function checkRWParams(m, offset, size)
{
	if(offset < 0 || offset > #m)
		throw BoundsException(format("Invalid offset {} in memblock of size {}", offset, #m))

	if(size < 0 || size > #m - offset)
		throw BoundsException(format("Invalid size {} in memblock of size {} starting from offset {}", size, #m, offset))
}

local checkRWParams = checkRWParams

/**
The base class for stream-based IO.

This class defines the interface that all streams must implement, as well as some helper functions which are implemented in
terms of the user-defined methods. This interface is fairly low-level and is meant to be wrapped by higher-level stream
wrapers and filters.

There are a relatively small number of functions which must be implemented to satisfy the stream interface. Detailed descriptions
of these methods and their behavior is given inside this class, but a quick overview is as follows:

\blist
	\li \b{\tt{readable, writable, seekable}} - These simply return bools which indicate whether this stream can be read from,
		written to, and seeked.
	\li \b{\tt{read, write, seek}} - The real workhorse functions which actually perform the reading, writing, and seeking of the
		stream. Each of these only needs to be implemented if the corresponding \tt{-able} method returns \tt{true}.
	\li \b{\tt{hasError, getOSError, getError}} - For error handling of streams which wrap system-level interfaces.
	\li \b{\tt{flush, close, isOpen}} - Miscellaneous optional methods.
\endlist

For any given stream, likely only the first six (or some subset thereof) will have to be implemented.

There is a deliberate avoidance of throwing exceptions from the lowest level of the stream API. Many IO events and error
conditions are not exceptional and/or do not represent an error on behalf of the programmer. Only in cases where it is obvious
that programmer error has occurred are exceptions thrown. In all other cases, return values are used to indicate success
or failure.
*/
class Stream
{
	_scratch

	/**
	Constructor. Be sure to call this as \tt{super()} in classes derived from \link{Stream}. While it only checks
	that one of \link{readable} and \link{writable} returns true right now, this may change in the future.
	*/
	this()
	{
		if(!:readable() && !:writable())
			throw IOException("Stream is neither readable nor writable!")
	}

	/**
	Reads data from the stream into the given memblock.

	\param[this] must be readable.
	\param[m] is the memblock into which data will be read.
	\param[offset] is the offset into \tt{m} where the first byte of data will be placed. Defaults to 0.
	\param[size] is the number of bytes to read. Defaults to the size of \tt{m} minus the \tt{offset}.

	\returns Either an integer or \tt{null}.

	\blist
		\li If \tt{size} is 0, this function is a no-op, and the return value is 0.
		\li If \tt{size} is nonzero,
		\blist
			\li If the read is successful, the return value is an integer in the range \tt{[1, size]} and indicates
				the number of bytes actually read. Fewer than \tt{size} bytes can be read in a number of non-error
				situations. If you need to fill up a buffer, make repeated calls to \tt{read} until the desired number
				of bytes has been read. The \link{readExact} method does this for you.
			\li If the stream has reached the end of the file, the return value is 0.
			\li If any error has occurred, the return value is \tt{null}. In this case, the cause of the error can be
				determined by the \link{getOSError} and \link{getError} methods.
		\endlist
	\endlist

	\throws[exceptions.BoundsException] if the \tt{offset} is outside the range \tt{[0, #m]}, or if \tt{size}
	is outside the range \tt{[0, #m - offset]}.
	*/
	function read(this: @InStream, m: memblock, offset: int = 0, size: int = #m - offset)
		throw NotImplementedException()

	/**
	Writes data into the stream from the given memblock.

	\param[this] must be writable.
	\param[m] is the memblock from which data will be written.
	\param[offset] is the offset into \tt{m} where the first byte of data will be retrieved. Defaults to 0.
	\param[size] is the number of bytes to write. Defaults to the size of \tt{m} minus the \tt{offset}.

	\returns Either an integer or \tt{null}.

	\blist
		\li If \tt{size} is 0, this function is a no-op, and the return value is 0.
		\li If \tt{size} is nonzero,
		\blist
			\li If the write is successful, the return value is an integer in the range \tt{[1, size]} and indicates
				the number of bytes actually written. Fewer than \tt{size} bytes can be written in a number of non-error
				situations. If you need to write a whole buffer, make repeated calls to \tt{write} until the desired number
				of bytes has been written. The \link{writeExact} method does this for you.
			\li If the stream has reached the end of the file, the return value is 0.
			\li If any error has occurred, the return value is \tt{null}. In this case, the cause of the error can be
				determined by the \link{getOSError} and \link{getError} methods.
		\endlist
	\endlist

	\throws[exceptions.BoundsException] if the \tt{offset} is outside the range \tt{[0, #m]}, or if \tt{size}
	is outside the range \tt{[0, #m - offset]}.
	*/
	function write(this: @OutStream, m: memblock, offset: int = 0, size: int = #m - offset)
		throw NotImplementedException()

	/**
	Changes the position of the stream's read/write position, and reports the new position once changed.

	Seeking past the end of a stream may or may not be an error, depending on the kind of stream.

	\param[this] must be seekable.
	\param[offset] is the position offset, whose meaning depends upon the \tt{where} parameter.
	\param[where] is a character indicating the position in the stream from which the new stream position will be calculated.
	It can be one of the three following values:

	\dlist
		\li{\b{\tt{'b'}}} The \tt{offset} is treated as an absolute offset from the beginning of the stream.
		\li{\b{\tt{'c'}}} The \tt{offset} is treated as a relative offset from the current read/write position. This means that
			negative \tt{offset} values move the read/write position backwards.
		\li{\b{\tt{'e'}}} The \tt{offset} is treated as a relative offset from the end of the stream.
	\endlist

	\returns Either an integer or \tt{null}.

	If the seek was successful, returns the new stream position as an absolute position from the beginning of the stream.

	If there was an error, returns \tt{null}.

	\throws[exceptions.IOException] if the resulting stream position would be negative.
	*/
	function seek(this: @SeekStream, offset: int, where: char)
		throw NotImplementedException()

	/**
	Tells whether or not \link{read} can be called on this stream.
	\returns a bool indicating such. The default implementation returns \tt{false}.
	*/
	function readable() = false

	/**
	Tells whether or not \link{write} can be called on this stream.
	\returns a bool indicating such. The default implementation returns \tt{false}.
	*/
	function writable() = false

	/**
	Tells whether or not \link{seek} can be called on this stream.
	\returns a bool indicating such. The default implementation returns \tt{false}.
	*/
	function seekable() = false

	/**
	Tells whether or not an error has occurred on this stream.
	\returns a bool indicating such. The default implementation returns \tt{false}.
	*/
	function hasError() = false

	/**
	Returns an OS-specific error code of the most recent error that occurred on this stream, and resets the stored error.

	The value that this function returns is meant to be used for more precise error handling than would be possible with just a
	message or an exception. However, its interpretation is platform-dependent and is therefore really only useful for very
	low-level programming.

	When this function is called, the error stored in the stream is reset to a "non-error" code.

	\returns an integer error code. The default implementation just returns 0.
	*/
	function getOSError() = 0

	/**
	Returns a human-readable representation of the most recent error that occurred on this stream, and resets the stored error.

	This message is likely to be used in error messages or exception objects. Of course, this message can't really be used to
	diagnose the error programmatically.

	Because this has to call \link{getOSError}, the stored error will be reset.

	\returns a string representation of the most recent error. The default implementation just returns the empty string.
	*/
	function getError() = ""

	/**
	An optional method used to flush cached data to the stream.

	Often buffering schemes are used to improve IO performance, but such schemes mean that the stream and its backing store are
	often incoherent. This method is called to force coherency by flushing any buffered data and writing it into the backing store.

	The default implementation is simply to do nothing and return \tt{true}.

	\returns either a bool or \tt{null}. If the flush was successful, returns \tt{true}. If end-of-file was reached, returns
	\tt{false}. If an error occurred, returns \tt{null}.
	*/
	function flush() = true

	/**
	An optional method used to close a stream by releasing any system resources associated with it and preventing any further use.

	The default implementation is simply to do nothing and return \tt{true}.

	\returns either a bool or \tt{null}. If closing was successful, returns \tt{true}. If end-of-file was reached (this can happen
	when flushing out buffers associated with the stream before closing), returns \tt{false}. If an error occurred, returns \tt{null}.
	*/
	function close() = true

	/**
	An optional method used to check whether or not this stream has been closed.

	This goes along with the \link{close} method; once \link{close} has been called, this method should return \tt{false}.

	\returns a bool indicating whether or not this stream is still open. The default implementation simply returns \tt{true}.
	*/
	function isOpen() = true

	/**
	A helper method which attempts to read a block of data fully, making multiple calls to \link{read} as needed.

	Since \link{read} may not read all the data for a block in one call, this method exists to automatically make as many calls
	to \link{read} as needed to fill the requested block of data. The parameters are identical to those of \link{read}.

	\returns either a bool or \tt{null}.
	\blist
		\li If the read completed successfully, returns \tt{true}.
		\li If end-of-file was reached, returns \tt{false}.
		\li If some error occurred, returns \tt{null}.
	\endlist
	*/
	function readExact(m: memblock, offset: int = 0, size: int = #m - offset)
	{
		checkRWParams(m, offset, size)
		local remaining = size

		while(remaining > 0)
		{
			local bytesRead = :read(m, offset, remaining)

			if(bytesRead is null)
				return null
			else if(bytesRead == 0)
				return false

			offset += bytesRead
			remaining -= bytesRead
		}

		return true
	}

	/**
	A helper method which attempts to write a block of data fully, making multiple calls to \link{write} as needed.

	Since \link{write} may not write all the data for a block in one call, this method exists to automatically make as many calls
	to \link{write} as needed to write the requested block of data. The parameters are identical to those of \link{write}.

	\returns either a bool or \tt{null}.
	\blist
		\li If the write completed successfully, returns \tt{true}.
		\li If end-of-file was reached, returns \tt{false}.
		\li If some error occurred, returns \tt{null}.
	\endlist
	*/
	function writeExact(m: memblock, offset: int = 0, size: int = #m - offset)
	{
		checkRWParams(m, offset, size)
		local remaining = size

		while(remaining > 0)
		{
			local bytesWritten = :write(m, offset, remaining)

			if(bytesWritten is null)
				return null
			else if(bytesWritten == 0)
				return false

			offset += bytesWritten
			remaining -= bytesWritten
		}

		return true
	}

	/**
	Skips forward a given number of bytes.

	The stream need not be seekable in order to skip forward. If it is not seekable, data will simply be read into a scratch buffer
	and discarded until the desired number of bytes have been skipped. If it is seekable, this will simply call \link{seek} to seek
	forward \tt{dist} bytes.

	\param[this] must be readable, and may optionally be seekable.
	\param[dist] is the number of bytes to skip. Can be 0.

	\returns either a bool or \tt{null}.
	\blist
		\li If the number of bytes requested was skipped, returns \tt{true}.
		\li If end-of-file was reached before the skip could be finished, returns \tt{false}.
		\li If some error occurred, returns \tt{null}.
	\endlist

	\throws[exceptions.RangeException] if \tt{dist} is negative.
	*/
	function skip(this: @InStream, dist: int)
	{
		if(dist < 0)
			throw RangeException(format("Invalid skip distance ({})", dist))
		else if(dist == 0)
			return true

		if(:seekable())
		{
			local pos = :seek(dist, 'c')

			if(pos is null)
				return null
			else
				return true
		}

		local f = :flush()
		
		if(f is null)
			return null
		else if(!f)
			return false

		:_scratch ?= memblock.new(4096)
		local buf = :_scratch

		while(dist > 0)
		{
			local numBytes = min(dist, #buf)

			local bytesRead = :readExact(buf, 0, numBytes)

			if(bytesRead is null)
				return null
			else if(bytesRead == 0)
				return false

			dist -= numBytes
		}

		return true
	}

	/**
	Reads all remaining data from the stream up to end-of-file into a memblock.

	This will call \link{read} as many times as needed until it indicates that the end of file has been reached.

	\param[this] must be readable.
	\param[m] is an optional memblock to use as the buffer to hold the read data. If one is given, it will be resized to hold the
		read data. If it is not given, a new memblock will be used instead.

	\returns the memblock holding the read data if successful, or \tt{null} if an error occurred.
	*/
	function readAll(this: @InStream, m: memblock = null)
	{
		if(m is null)
			m = memblock.new(4096)
		else if(#m < 4096)
			#m = 4096

		local offs = 0

		while(true)
		{
			local numBytes = :read(m, offs)

			if(numBytes is null)
				return null
			else if(numBytes == 0)
				break

			offs += numBytes

			if(#m < offs + 4096)
				#m = offs + 4096
		}

		#m = offs
		return m
	}

	/**
	Copies data from another stream into this one.

	The data is copied in blocks of 4096 bytes at a time.

	\param[this] must be writable.
	\param[s] is the source stream from which the data will be read, and must be readable.
	\param[size] is the number of bytes to copy, or -1 to mean all data until \tt{s} reaches end-of-file.

	\returns either a bool or \tt{null}, followed by \tt{null} or a \link{Stream}.
	\blist
		\li If the copy completed successfully, returns \tt{true, null}.
		\li If \tt{size != -1} and end-of-file was reached on \tt{s} before copying completed, returns \tt{false, s}.
		\li If end-of-file was reached on \tt{this} before copying completed, returns \tt{false, this}.
		\li If an error occurred when reading from \tt{s}, returns \tt{null, s}.
		\li if an error occurred when writing to \tt{this}, returns \tt{null, this}.
	\endlist

	That is, if EOF was reached or an error occurred on either stream, the stream on which that happened is returned as
	the second value.

	\throws[exceptions.RangeException] if \tt{size < -1}.
	*/
	function copy(this: @OutStream, s: @InStream, size: int = -1)
	{
		:_scratch ?= memblock.new(4096)
		local buf = :_scratch

		if(size < -1)
			throw RangeException(format("Invalid size: {}", size))

		if(size == -1)
		{
			while(true)
			{
				local numRead = s.read(buf)

				if(numRead is null)
					return null, s
				else if(numRead == 0)
					break

				local written = :writeExact(buf, 0, numRead)

				if(written is null)
					return null, this
				else if(!written)
					return false, this
			}
		}
		else
		{
			local remaining = size

			while(remaining > 0)
			{
				local numBytes = min(remaining, #buf)
				local numRead = s.read(buf, 0, numBytes)

				if(numRead is null)
					return null, s
				else if(numRead == 0)
					return false, s

				local written = :writeExact(buf, 0, numRead)

				if(written is null)
					return null, this
				else if(!written)
					return false, this

				remaining -= numRead
			}
		}

		return true, null
	}

	/**
	Sets or gets the absolute position in the stream, as a convenience.

	\param[this] must be seekable.
	\param[pos] is either the new read/write position, measured in bytes from the beginning of the stream, or \tt{null}.

	\returns the new position if \tt{pos} was non-null, or the current position if \tt{pos} was \tt{null}. If an error occurred,
	returns \tt{null} instead.
	*/
	function position(this: @SeekStream, pos: int|null)
	{
		if(pos is null)
			return :seek(0, 'c')
		else
			return :seek(pos, 'b')
	}

	/**
	Returns the size of the stream in bytes.

	It does this by seeking to the end of the stream and getting the position, then seeking back to where it was before
	calling this method. As a result this method can cause buffered data to be flushed.

	\param[this] must be seekable.

	\returns an integer indicating how many bytes long this stream is, or \tt{null} if any error occurred.
	*/
	function size(this: @SeekStream)
	{
		local pos = :position()

		if(pos is null)
			return null

		local ret = :seek(0, 'e')

		if(ret is null)
			return null

		if(:position(pos) is null)
			return null

		return ret
	}
}

/**
These are meant to be used as custom parameter type constraints, to ensure that a stream parameter supports certain operations.

All of these ensure that \tt{s} is derived from \link{Stream}. The \tt{in} functions ensure that \tt{s.readable()} returns true;
the \tt{out} functions ensure that \tt{s.writable()} returns true; and the \tt{seek} functions ensure that \tt{s.seekable()}
returns true. An example of use:

\code
// Expects the dest stream to be writable and the src stream to be readable
function copyBlock(dest: @OutStream, src: @InStream) { ... }

// Finds the directory section in a ZIP file and reads it; expects the stream to be readable and seekable.
function readZIPDirectory(s: @InSeekStream) { ... }
\endcode

It's a good idea to use only what you need and not over-request features; for instance, if you're never going to write to the
stream, don't use an \tt{out} function.

\param[s] the stream object to test.
\returns a bool telling whether or not it satisfies the constraints.
*/
function InStream(s) =        s as Stream && s.readable()
function OutStream(s) =       s as Stream &&                 s.writable()                 /// ditto
function InoutStream(s) =     s as Stream && s.readable() && s.writable()                 /// ditto
function SeekStream(s) =      s as Stream &&                                 s.seekable() /// ditto
function InSeekStream(s) =    s as Stream && s.readable() &&                 s.seekable() /// ditto
function OutSeekStream(s) =   s as Stream &&                 s.writable() && s.seekable() /// ditto
function InoutSeekStream(s) = s as Stream && s.readable() && s.writable() && s.seekable() /// ditto

/**
Implements a readable, writable, seekable stream that uses a memblock as its data backing store.

This is a very useful kind of stream. With it you can redirect stream operations that would normally go to a file to memory
instead. It can often be much faster to read in a large chunk of a file, or a file in its entirety, and then do processing
in memory. This is also useful for building up data to be sent over networks or such.

The backing memblock can be one you provide, or it can use its own. The memblock will be grown automatically when data is
written past its end.
*/
class MemblockStream : Stream
{
	_mb
	_pos = 0

	/**
	Constructor.
	
	\param[mb] is the memblock to use as the backing store. If none is given, a new zero-size memblock will be used instead.
	*/
	this(mb: memblock = memblock.new(0))
	{
		:_mb = mb
		super()
	}

	/**
	Implmentation of \link{Stream.read}.

	This will never return \tt{null}.
	*/
	function read(m: memblock, offset: int = 0, size: int = #m - offset)
	{
		if(:_pos >= #:_mb)
			return 0

		checkRWParams(m, offset, size)

		if(size == 0)
			return 0

		local numBytes = min(size, #:_mb - :pos)
		m.rawCopy(offset, :_mb, :_pos, numBytes)
		:_pos += numBytes
		return numBytes
	}

	/**
	Implmentation of \link{Stream.write}.
	
	If there is not enough space in the memblock to hold the new data, the memblock's size will be expanded to accommodate.

	This will never return \tt{null}.
	*/
	function write(m: memblock, offset: int = 0, size: int = #m - offset)
	{
		checkRWParams(m, offset, size)

		if(size == 0)
			return 0

		local bytesLeft = #:_mb - :_pos

		if(size > bytesLeft)
			#:_mb += size - bytesLeft

		:_mb.rawCopy(:_pos, m, offset, size)
		:_pos += size
		return size
	}

	/**
	Implmentation of \link{Stream.seek}.
	
	If you seek past the end of the memblock, the memblock will be resized to the new offset. This is to match the behavior
	of seeking on files.

	This will never return \tt{null}.
	
	\throws[exceptions.ValueException] if \tt{where} is invalid.
	\throws[exceptions.IOException] if the resulting offset is negative.
	*/
	function seek(offset: int, where: char)
	{
		switch(where)
		{
			case 'b': break
			case 'c': offset += :_pos; break
			case 'e': offset += #:_mb; break
			default: throw ValueException(format("Invalid seek type '{}'", where))
		}

		if(offset < 0)
			throw IOException("Invalid seek offset")

		if(offset > #:_mb)
			#:_mb = offset

		:_pos = offset
		return offset
	}

	/**
	Implementations of \link{Stream.readable}, \link{Stream.writable}, and \link{Stream.seekable}. All return true.
	*/
	function readable() = true
	function writable() = true /// ditto
	function seekable() = true /// ditto

	/**
	Gets the backing memblock.
	
	It's probably best not to change the size of the memblock while it's still being used by the stream.
	
	\returns the backing memblock.
	*/
	function getBacking() = :_mb
}

local function cropPartial(s: memblock, pos: int)
{
	local i = pos - 1

	while(i > 0)
	{
		local b = s[i]

		if(!(b & 0x80))
			break

		if((b & 0xC0) == 0xC0)
		{
			local d = pos - i

			if(b & 0x20)
				d--

			if(b & 0x10)
				d--

			if(d == 2)
				i = pos

			return i
		}
		else
			i--
	}

	return pos
}

class UTF8Stream
{
	stream
	readBuf
	writeBuf
	chunks

	bufPos = 0
	bound = 0

	shouldFlush = false
	dirty = false

	this(s: Stream)
	{
		:stream = s
		:readBuf = memblock.new(4096)
		:writeBuf = memblock.new(0)
		:chunks = []
	}

	function readln()
	{
		if(:bound == 0)
		{
			:_readMore(:bufPos)

			if(:bound == 0)
				return null
		}

		#:chunks = 0
		local readBuf = :readBuf

		while main(:bound > 0)
		{
			local start = :bufPos

			for(; :bufPos < :bound; :bufPos++)
			{
				if(readBuf[:bufPos] == 10)
				{
					:chunks ~= string.fromRawUnicode(readBuf, start, :bufPos)
					:bufPos++
					break main
				}
			}

			local realEnd = cropPartial(readBuf, :bufPos)

			:chunks ~= string.fromRawUnicode(readBuf, start, realEnd)

			if(realEnd < :bufPos)
			{
				for(local i, j = 0, realEnd; j < :bufPos; i++, j++)
					readBuf[i] = readBuf[j]
			}

			:_readMore(:bufPos - realEnd)
		}

		local ret = "".join(:chunks)
		#:chunks = 0

		if(#ret && ret[-1] == '\r')
			#ret--

		return ret
	}

	function iterator(idx: int)
	{
		if(local ret = :readln())
			return idx + 1, ret
	}

	function opApply(_)
		return :iterator, this, 0

	function write(vararg)
	{
		for(i: 0 .. #vararg)
			:stream.write(toString(vararg[i]).toRawUnicode(8, :writeBuf))
	}

	function writeln(vararg)
	{
		:write(vararg)
		:write("\n")

		if(:shouldFlush)
			:stream.flush()
	}

	function writef(fmt: string, vararg)
	{
		:stream.write(format(fmt, vararg).toRawUnicode(8, :writeBuf))
	}

	function writefln(fmt: string, vararg)
	{
		:writef(fmt, vararg)
		:write("\n")

		if(:shouldFlush)
			:stream.flush()
	}

	function flushOnNL(f: bool)
		:shouldFlush = f

	function _readMore(start: int)
	{
		:bufPos = 0
		:bound = :stream.read(:readBuf, start)
	}
}

/**
A base class for types of streams which expand the capabilities of another stream without obscuring the underlying stream
interface.

It takes a stream object and implements all of the \link{Stream} interface methods as simply passthroughs to the underlying
stream object. Subclasses can then add methods and possibly override just those which they need to.
*/
class StreamWrapper : Stream
{
	_stream

	/**
	Constructor.
	
	\param[s] is the stream object to be wrapped.
	*/
	this(s: Stream)
	{
		:_stream = s
		super()
	}

	/**
	These all simply pass through functionality to the wrapped stream object.
	*/
	function read(m, off, size) = :_stream.read(m, off, size)
	function write(m, off, size) = :_stream.write(m, off, size) /// ditto
	function seek(off, where) = :_stream.seek(off, where)       /// ditto
	function flush() = :_stream.flush()                         /// ditto
	function close() = :_stream.close()                         /// ditto
	function isOpen() = :_stream.isOpen()                       /// ditto
	function readable() = :_stream.readable()                   /// ditto
	function writable() = :_stream.writable()                   /// ditto
	function seekable() = :_stream.seekable()                   /// ditto
	function hasError() = :_stream.hasError()                   /// ditto
	function getOSError() = :_stream.getOSError()               /// ditto
	function getError() = :_stream.getError()                   /// ditto

	/**
	Gets the stream that this instance wraps.
	
	\returns the same stream object that was passed to the constructor.
	*/
	function getWrappedStream() = :_stream
}

/**
A kind of stream wrapper class that adds a simple interface for reading and writing binary data. 

Because it's a stream wrapper, the basic stream interface can still be used on it and the functionality will be passed through
to the wrapped stream.
*/
class BinaryStream : StreamWrapper
{
	_rwBuf
	_strBuf

	/**
	Constructor.

	\param[s] is the stream to be wrapped.
	*/
	this(s: Stream)
	{
		super(s)
		:_rwBuf = memblock.new(8)
		:_strBuf = memblock.new(0)
	}

	function _commonRead(size, readMethod)
	{
		local r = :stream.readExact(:_rwBuf, 0, size)
		
		if(r)
			return :_rwBuf.(readMethod)(0)
		else if(r is null)
			return null
		else
			return EOF
	}

	/**
	These all read a single integer or floating-point value of the given type and size.

	Note that because Croc's \tt{int} type is a signed 64-bit integer, \tt{readUInt64} will return negative numbers for those
	that exceed 2\sup{63} - 1. It exists for completeness.

	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or an \tt{int} or \tt{float} representing
	the value read, if successful.
	*/
	function readInt8() =    :_commonRead(1, "readInt8")
	function readInt16() =   :_commonRead(2, "readInt16")   /// ditto
	function readInt32() =   :_commonRead(4, "readInt32")   /// ditto
	function readInt64() =   :_commonRead(8, "readInt64")   /// ditto
	function readUInt8() =   :_commonRead(1, "readUInt8")   /// ditto
	function readUInt16() =  :_commonRead(2, "readUInt16")  /// ditto
	function readUInt32() =  :_commonRead(4, "readUInt32")  /// ditto
	function readUInt64() =  :_commonRead(8, "readUInt64")  /// ditto
	function readFloat32() = :_commonRead(4, "readFloat32") /// ditto
	function readFloat64() = :_commonRead(8, "readFloat64") /// ditto

	/**
	Reads a binary representation of a \tt{string} object. Should only be used as the inverse to \link{writeString}.

	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or a \tt{string} representing the value read,
	if successful.
	*/
	function readString()
	{
		local len = :readUInt64()
		#:_strBuf = len

		local r = :stream.readExact(:_strBuf)

		if(r)
			return text.fromRawUnicode(:_strBuf)
		else if(r is null)
			return null
		else
			return EOF
	}

	/**
	Reads a given number of \b{ASCII} characters and returns them as a string.

	This is particularly useful for chunk identifiers in RIFF-type files and "magic numbers", though it can have other uses as well.

	\param[n] is the number of bytes to read.

	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or a \tt{string} representing the characters
	read, if successful.

	\throws[exceptions.RangeException] if \tt{n < 1}.
	*/
	function readChars(n: int)
	{
		if(n < 1)
			throw RangeException(format("Invalid number of characters ({})", n))

		#:_strBuf = n

		local r = :stream.readExact(:_strBuf)

		if(r)
			return text.fromRawAscii(:_strBuf)
		else if(r is null)
			return null
		else
			return EOF
	}

	/**
	Reads a chunk of data from the stream as a memblock. Acts as a higher-level interface than the raw \tt{read} and \tt{readExact}
	methods.

	\param[m] is either a memblock to act as the destination or an \tt{int} saying how many bytes to read. If \tt{m} is a memblock,
	\tt{#m} bytes will be read and \tt{m}'s contents will be replaced by them. If \tt{m} is an \tt{int}, a new memblock of size \tt{m}
	will be created and returned.

	\returns a memblock holding the read data (either \tt{m} if \tt{m} was a memblock, or a new memblock if not) if successful. Returns
	\tt{null} if an error occurred, or \tt{EOF} if end-of-file was reached.
	*/
	function readMemblock(m: memblock|int)
	{
		if(isInt(m))
		{
			if(m < 0)
				throw RangeException(format("Invalid size: {}", m))

			m = memblock.new(m)
		}

		local r = :stream.readExact(m)

		if(r)
			return m
		else if(r is null)
			return null
		else
			return EOF
	}

	function _commonWrite(val, size, writeMethod)
	{
		:_rwbuf.(writeMethod)(0, val)

		local r = :stream.writeExact(:_rwBuf, 0, size)

		if(r)
			return this
		else if(r is null)
			return null
		else
			return EOF
	}

	/**
	These all write a single integer or floating-point value of the given type and size.

	\param[x] is the value to write.
	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or \tt{this} if the write was successful.
	*/
	function writeInt8(x: int) =      :_commonWrite(x, 1, "writeInt8")
	function writeInt16(x: int) =     :_commonWrite(x, 2, "writeInt16")   /// ditto
	function writeInt32(x: int) =     :_commonWrite(x, 4, "writeInt32")   /// ditto
	function writeInt64(x: int) =     :_commonWrite(x, 8, "writeInt64")   /// ditto
	function writeUInt8(x: int) =     :_commonWrite(x, 1, "writeUInt8")   /// ditto
	function writeUInt16(x: int) =    :_commonWrite(x, 2, "writeUInt16")  /// ditto
	function writeUInt32(x: int) =    :_commonWrite(x, 4, "writeUInt32")  /// ditto
	function writeUInt64(x: int) =    :_commonWrite(x, 8, "writeUInt64")  /// ditto
	function writeFloat32(x: float) = :_commonWrite(x, 4, "writeFloat32") /// ditto
	function writeFloat64(x: float) = :_commonWrite(x, 8, "writeFloat64") /// ditto

	/**
	Writes a binary representation of the given string. To read this binary representation back again, use \link{readString}.

	\param[x] is the string to write.
	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or \tt{this} if the write was successful.
	*/
	function writeString(x: string)
	{
		text.toRawUnicode(x, 8, :_strBuf)
		:writeUInt64(#:_strBuf)

		local r = :stream.writeExact(:_strBuf)

		if(r)
			return this
		else if(r is null)
			return null
		else
			return EOF
	}

	/**
	Writes the given string, which must be ASCII only, as a raw sequence of byte-sized characters.
	
	This is particularly useful for chunk identifiers in RIFF-type files and "magic numbers", though it can have other uses
	as well.
	
	\param[x] is the string containing the characters to be written. It must be ASCII.
	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or \tt{this} if the write was successful.
	\throws[exceptions.ValueException] if \tt{x} is not ASCII.
	*/
	function writeChars(x: string)
	{
		if(!ascii.isAscii(x))
			throw ValueException("Can only write ASCII strings as raw characters")

		text.toRawUnicode(x, 8, :_strBuf)

		local r = :stream.writeExact(:_strBuf)

		if(r)
			return this
		else if(r is null)
			return null
		else
			return EOF
	}

	/**
	Writes a slice of a memblock as a chunk of data. Acts as a higher-level interface than the \tt{write} and \tt{writeExact}
	methods.
	
	\param[m] is the memblock from which the data will be written.
	\param[lo] is the low slice index into the memblock. Defaults to 0.
	\param[hi] is the high slice index into the memblock. Defaults to the length of the memblock.
	\returns \tt{null} if an error occurred; \link{EOF} if end-of-file was reached; or \tt{this} if the write was successful.
	Zero-length writes will always succeed.
	\throws[exceptions.BoundsException] if the given slice indices are invalid.
	*/
	function writeMemblock(m: memblock, lo: int = 0, hi: int = #m)
	{
		if(lo < 0)
			lo += #m

		if(hi < 0)
			hi += #m

		if(lo < 0 || lo > hi || hi > #m)
			throw BoundsException(format("Invalid memblock slice indices {} .. {} (memblock length: {})", lo, hi, #m))

		if(local size = hi - lo)
		{
			local r = :stream.writeExact(m, lo, size)

			if(r is null)
				return null
			else if(!r)
				return EOF
		}

		return this
	}
}

/**
A stream wrapper that adds input buffering. Note that this class only allows reading and seeking; writing is unsupported.

This stream adds a transparent buffering scheme when reading data. Seeking is also allowed and will work correctly even
if data is buffered.
*/
class BufferedInStream : StreamWrapper
{
	_buf
	_bufPos = 0
	_bound = 0

	/**
	Constructor.

	\param[s] is the stream to be wrapped.
	\param[bufSize] is the size of the memory buffer. Defaults to 4KB. Its size is clamped to a minimum of 128 bytes, and
	there is no upper limit.
	*/
	this(s: @InStream, bufSize: int = 4096)
	{
		super(s)
		:_buf = memblock.new(clamp(bufSize, 128, intMax))
	}

	/**
	Regardless of whether or not the underlying stream is writable, this class is not. Erratic behavior can result if you try
	to write to a stream that is wrapped by this class.

	\returns false.
	*/
	function writable() =
		false

	/**
	Implementation of the \tt{read} method. It works exactly like the normal \tt{read} method, performing buffering transparently.

	The call signature and return values are the same as \link{Stream.read}.
	*/
	function read(m: memblock, offset: int = 0, size: int = #m - offset)
	{
		checkRWParams(m, offset, size)
		local remaining = size

		while(remaining > 0)
		{
			local buffered = :_bound - :_bufPos

			if(buffered == 0)
			{
				buffered = :_readMore()

				if(buffered is null)
					return null
				else if(buffered == 0)
					break
			}

			local num = min(buffered, remaining)
			m.rawCopy(offset, :_buf, :_bufPos, num)
			:_bufPos += num
			offset += num
			remaining -= num
		}

		return size - remaining
	}

	/**
	Implementation of the \tt{seek} method. It works exactly like the normal \tt{seek} method, and will seek properly even if
	data has been buffered.

	Seeking will clear the data buffer. The call signature and return values are the same as \link{Stream.seek}.
	*/
	function seek(this: @SeekStream, offset: int, where: char)
	{
		if(where == 'c')
			offset -= :_bound - :_bufPos

		:_bufPos, :_bound = 0, 0
		return :_stream.seek(offset, where)
	}

	function _readMore()
	{
		assert((:_bound - :_bufPos) == 0)
		:_bufPos = 0
		:_bound = :_stream.read(:_buf)

		if(:_bound is null)
		{
			:_bound = 0
			return null
		}

		return :_bound
	}
}

/**
A stream wrapper that adds output buffering. Note that this class only allows writing and seeking; reading is unsupported.

This stream adds a transparent buffering scheme when writing data. Seeking is also allowed and will work correctly even
if data is buffered.
*/
class BufferedOutStream : StreamWrapper
{
	_buf
	_bufPos = 0

	/**
	Constructor.

	\param[s] is the stream to be wrapped.
	\param[bufSize] is the size of the memory buffer. Defaults to 4KB. Its size is clamped to a minimum of 128 bytes, and
	there is no upper limit.
	*/
	this(s: @OutStream, bufSize: int = 4096)
	{
		super(s)
		:_buf = memblock.new(clamp(bufSize, 128, intMax))
	}

	/**
	Regardless of whether or not the underlying stream is readable, this class is not. Erratic behavior can result if you try
	to read from a stream that is wrapped by this class.

	\returns false.
	*/
	function readable() =
		false

	/**
	Implementation of the \tt{write} method. It works exactly like the normal \tt{write} method, performing buffering transparently.

	The call signature and return values are the same as \link{Stream.write}.
	*/
	function write(m: memblock, offset: int = 0, size: int = #m - offset)
	{
		checkRWParams(m, offset, size)
		local remaining = size

		while(remaining > 0)
		{
			local spaceLeft = #:_buf - :_bufPos

			if(spaceLeft == 0)
			{
				local f = :flush()

				if(f is null)
					return null
				else if(!f)
					return EOF

				spaceLeft = #:_buf
			}

			local num = min(spaceLeft, remaining)
			:_buf.rawCopy(:_bufPos, m, offset, num)
			:_bufPos += num
			offset += num
			remaining -= num
		}

		return size - remaining
	}

	/**
	Implementation of the \tt{seek} method. It works exactly like the normal \tt{seek} method, and will seek properly even if
	data has been buffered.

	Seeking will flush the data buffer. The call signature and return values are the same as \link{Stream.seek}.
	*/
	function seek(offset: int, where: char)
	{
		if(where == 'c')
			offset -= :_bufPos

		if(:_bufPos > 0)
		{
			local f = :flush()
			
			if(f is null)
				return null
			else if(!f)
				return EOF
		}

		return :_stream.seek(offset, where)
	}

	/**
	Implementation of the \tt{flush} method. This writes any buffered data to the stream. If no data is buffered, does nothing.
	*/
	function flush()
	{
		if(:_bufPos > 0)
		{
			local w = :_stream.write(:_buf, 0, :_bufPos)
			
			if(w is null)
				return null
			else if(w == 0)
				return false

			:_bufPos = 0
			w = :_stream.flush()
			
			if(w is null)
				return null
			else if(!w)
				return false
		}

		return true
	}

	function close()
	{
		local f = :_flush()
		
		if(f is null)
			return null
		else if(!f)
			return false

		return :_stream.close()
	}
}