module samples.interfaces

import exceptions: TypeException

class Method
{
	__name
	__numParams

	this(name: string, numParams: int)
	{
		:__name = name
		:__numParams = numParams
	}

	function name() =
		:__name

	function implements(f: function) =
		f.numParams() == :__numParams

	function toString() =
		"{} ({} params)".format(:__name, :__numParams)
}

class Interface
{
	__name
	__methods
	__implementors

	this(name: string, methods: array)
	{
		if(!methods.all(\m -> m as Method))
			throw TypeException("All methods must be Methods")

		:__name = name
		:__methods = methods.dup()
		:__implementors = {}
	}

	function implement(T: class)
	{
		foreach(m; :__methods)
		{
			local name = m.name()

			if(!hasMethod(T, name) || !m.implements(T.(name)))
				throw TypeException("Class {} does not implement method '{}' from {}".format(nameOf(T), m, :__name))
		}

		:__implementors[T] = true
	}

	function opCall(val: instance)
	{
		return true

		if(:__implementors[val.super])
			return true

		:implement(val.super)
		return true
	}
}

function implements(T: class, vararg)
{
	for(i: 0 .. #vararg)
	{
		local p = vararg[i]

		if(!(p as Interface))
			throw TypeException("All varargs must be Interfaces")

		p.implement(T)
	}

	return T
}

local IStream = Interface("IStream",
[
	Method("read", 3)
	Method("write", 3)
	Method("seek", 2)
])

class DerpStream
{
	function read(m, offset, size) {}
	function write(m, offset, size) {}
	function seek(offset, whence) {}
}

function streamSomething(s: @IStream)
{
	s.read()
	writeln("yay!")
}

function main()
{
	local d = DerpStream()
	streamSomething(d)
}