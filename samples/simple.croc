module samples.simple

namespace N
{
	function Okay(x) = isInt(x)
}

function foo(x: @N.Okay) {}

foo(3.5)

/*
class Stream
{
	this()
	{
		if(!:readable() && !:writable())
			throw IOException(format("Instances of class {} are neither readable nor writable; not a very useful stream, is it?", nameOf(:super)))

		:scratch = memblock.new("u8", 4096)
	}

	function read(m: memblock, num: int)  throw NotImplementedException()
	function write(m: memblock, num: int) throw NotImplementedException()
	function seek(pos: int, where: char)  throw NotImplementedException()
	function close()                      throw NotImplementedException()
	function isOpen()                     throw NotImplementedException()

	function flush() {}
	function readable() = false
	function writable() = false
	function seekable() = false

	function skip(this: @InStream, dist: int)
	{
		if(dist < 0)
			throw RangeException(format("Invalid skip distance ({})", dist))

		:flush()
		local buf = :scratch

		while(dist > 0)
		{
			local numRead = :read(buf, dist < #buf ? dist : #buf)

			if(numRead == 0)
				throw IOException("EOF while reading")

			dist -= numRead
		}
	}

	function copy(this: @OutStream, s: @InStream)
	{
		local buf = :scratch

		while(true)
		{
			local numRead = s.read(buf, #buf)

			if(numRead == 0)
				break
			
			do
			{
				local numWritten = :write(buf, numRead)
	
				if(numWritten == 0)
					throw IOException("EOF while writing")

				numRead -= numWritten
			} while(numRead > 0)
		}

		return this
	}

	function position(this: @SeekStream, pos: int|null)
	{
		if(pos is null)
			return :seek(0, 'c')
		else
			return :seek(pos, 'b')
	}

	function size(this: @SeekStream)
	{
		:flush()
		local pos = :position()
		local ret = :seek(0, 'e')
		:position(pos)
		return ret
	}
}

function InStream(s) =        s as Stream && s.readable()
function OutStream(s) =       s as Stream &&                 s.writable()
function InoutStream(s) =     s as Stream && s.readable() && s.writable()
function SeekStream(s) =      s as Stream &&                                 s.seekable()
function InSeekStream(s) =    s as Stream && s.readable() &&                 s.seekable()
function OutSeekStream(s) =   s as Stream &&                 s.writable() && s.seekable()
function InoutSeekStream(s) = s as Stream && s.readable() && s.writable() && s.seekable()

class NativeInStream : Stream {} // Tango InputStream
class NativeOutStream : Stream {} // Tango OutputStream
class NativeInoutStream : Stream {} // Tango Conduit

class TextReader
{
	this(s: @InStream)
		:stream = s

	function readln()
	{
		// get next line and return as a string, or null if EOF
	}

	function opApply(_)
	{
		return (\_-> :readln()), this, null
	}
}

class BinaryReader
{
	this(s: @InStream)
		:stream = s

	function readByte() = ...
	function readUByte() = ...
	function readShort() = ...
	function readUShort() = ...
	function readInt() = ...
	function readUInt() = ...
	function readLong() = ...
	function readULong() = ...
	function readFloat() = ...
	function readDouble() = ...
	function readChar() = ...
	function readWChar() = ...
	function readDChar() = ...
	function readString() = ...
	function readChars(num: int) = ...
	function readMemblock(t: memblock|string, size: int|null) = ...
}

class TextWriter
{
	this(s: @OutStream)
		:stream = s

	function write(vararg) { ... }
	function writeln(vararg) { ... }
	function writef(fmt: string, vararg) { ... }
	function writefln(fmt: string, vararg) { ... }
	function flushOnNL(f: bool) { ... }
}

class BinaryWriter
{
	this(s: @OutStream)
	{
		:stream = s
		:writeBuf = memblock.new("i8", 8)
		:strBuf = memblock.new("i8", 0)
	}

	function writeExact(buf: memblock, size: int)
	{
		if(:s.write(buf, size) < size)
			throw IOException("EOF while writing")
	}

	function writeByte(x: int)     { :writeBuf.writeByte(0, x);          :writeExact(:writeBuf, 1) }
	function writeUByte(x: int)    { :writeBuf.writeUByte(0, x);         :writeExact(:writeBuf, 1) }
	function writeShort(x: int)    { :writeBuf.writeShort(0, x);         :writeExact(:writeBuf, 2) }
	function writeUShort(x: int)   { :writeBuf.writeUShort(0, x);        :writeExact(:writeBuf, 2) }
	function writeInt(x: int)      { :writeBuf.writeInt(0, x);           :writeExact(:writeBuf, 4) }
	function writeUInt(x: int)     { :writeBuf.writeUInt(0, x);          :writeExact(:writeBuf, 4) }
	function writeLong(x: int)     { :writeBuf.writeLong(0, x);          :writeExact(:writeBuf, 8) }
	function writeULong(x: int)    { :writeBuf.writeULong(0, x);         :writeExact(:writeBuf, 8) }
	function writeFloat(x: float)  { :writeBuf.writeFloat(0, x);         :writeExact(:writeBuf, 4) }
	function writeDouble(x: float) { :writeBuf.writeDouble(0, x);        :writeExact(:writeBuf, 8) }
	function writeChar(x: char)    { :writeBuf.writeUByte(0, toInt(x));  :writeExact(:writeBuf, 1) }
	function writeWChar(x: char)   { :writeBuf.writeUShort(0, toInt(x)); :writeExact(:writeBuf, 2) }
	function writeDChar(x: char)   { :writeBuf.writeUInt(0, toInt(x));   :writeExact(:writeBuf, 4) }

	function writeString(x: string)
	{
		
	}

	function writeChars(x: string)
	{

	}
}
*/
/*
function help(x, child: string = null)
{
	local d

	if(isString(x))
	{
		local mt

		try
			mt = debug.getMetatable(x)
		catch(e)
			throw format("Invalid type '{}'", x)

		if(child in mt)
			d = docsOf(mt.(child))
	}
	else
	{
		d = docsOf(x)

		if(#d && child !is null)
		{
			if(d.children is null)
				throw "No children"

			local found = false

			foreach outerLoop(c; d.children)
			{
				if(c.name == child)
				{
					found = true
					d = c
					break
				}

				if(c.dittos)
				{
					foreach(dit; c.dittos)
					{
						if(dit.name == child)
						{
							found = true
							d = c
							break outerLoop
						}
					}
				}
			}

			if(!found)
				throw "Not found"
		}
	}

	if(#d == 0)
	{
		writeln("<no help available>")
		return
	}

	function writeHeader(d)
	{
		if(d.protection)
			write(d.protection, " ")

		write(d.kind, " ", d.name)

		if(d.params)
		{
			write("(")

			foreach(i, p; d.params)
			{
				if(i > 0)
					write(", ")

				write(p.name)

				if(p.type != "any" && p.type != "vararg")
					write(": ", p.type)

				if(p.value)
					write(" = ", p.value)
			}

			write(")")
		}

		if(d.base)
			write(" : ", d.base)

		if(d.value)
			write(" = ", d.value)

		write(" (", d.file)
		if(d.line != 0)
			write(":  ", d.line)
		writeln(")")
	}

	writeHeader(d)

	if(d.dittos)
		foreach(dit; d.dittos)
			writeHeader(dit)

	foreach(line; d.docs.splitLines())
		writeln("  ", line.strip())

	if(d.children && #d.children)
	{
		writeln()
		writeln("Members:")

		foreach(c; d.children)
			writeln("   ", c.name)
	}

	writeln()
}

function dumpDocs(docs: string, indent: bool)
{
	local strip = true

	foreach(line; docs.splitLines())
	{
		local s = line.strip()

		if(s == "")
		{
			writeln()
			continue
		}
		else if(s == "{{{")
			strip = false

		if(strip)
		{
			if(indent)
				write(" ")
			writeln(s)
		}
		else
			writeln(line)

		if(s == "}}}")
			strip = true
	}
}

function dumpHeader(d)
{
	switch(d.kind)
	{
		case "class":
			write(" '''`class ")
			write(d.name)
			if(d.base)
				write(" : ", d.base)
			writeln("`'''::")
			break

		case "function":
			writef(" '''`{}(", d.name == "constructor" ? "this" : d.name)

			foreach(i, p; d.params)
			{
				if(i > 0)
					write(", ")

				write(p.name)

				if(p.type != "any" && p.type != "vararg")
					write(": ", p.type)

				if(p.value)
					write(" = ", p.value)
			}

			writeln(")`'''::")
			break

		default:
			writeln("<unhandled kind ", d.kind, ">")
	}
}

function dumpItem(d)
{
	dumpHeader(d)

	if(d.dittos)
		foreach(dit; d.dittos)
			dumpHeader(dit)

	switch(d.kind)
	{
		case "class":
			writeln()
			dumpDocs(d.docs, true)
			writeln()

			foreach(child; d.children)
				dumpItem(child)

			break

		case "function":
			dumpDocs(d.docs, true)
			writeln()
			break

		default:
			writeln("<unhandled kind ", d.kind, ">")
	}
}

function dumpStdlib(x)
{
	local d = docsOf(x)

	if(#d == 0)
		throw "WAHHHH"

	writefln("= {} =", d.name)
	writeln()
	dumpDocs(d.docs, false)
	writeln()
	writeln("[[PageOutline(2-9, Table of Contents, inline)]]")
	writeln()

	local curSection = ""

	foreach(child; d.children)
	{
		if(child.section != curSection)
		{
			curSection = child.section
			writefln("== {} ==", curSection)
			writeln()
		}

		dumpItem(child)
	}
}
*/
// dumpStdlib(_G)

/*
I guess it's baselib (but could be moved?)
	stringification
		toString(value, style: char = 'd')
		rawToString(value)
		format(fmt: string, vararg)
	console IO
		write(vararg)
		writeln(vararg)
		writef(vararg)
		writefln(vararg)
		readln()
		dumpVal(value, printNewline: bool = true)
	conversions
		toBool(value)
		toInt(value: bool|int|float|char|string)
		toFloat(value: bool|int|float|char|string)
		toChar(value: int)
	attributes
		attrs(o: function|class|namespace, t: table)
		hasAttributes(value)
		attributesOf(value)
*/

/*
global loaded = {}
global path = "."
global customLoaders = {}
global loaders // filled in at end

function load(name: string)
{
	// Have we already loaded this module?
	local ns = loaded[name]
	if(isNamespace(ns))
		return ns

	return commonLoad(name)
}

function reload(name: string)
{
	// Have we already loaded this module?
	local ns = loaded[name]
	if(ns is null)
		throw "trying to reload a module that hasn't been loaded"

	return commonLoad(name)
}

function commonLoad(name: string)
{
	// Are we circularly importing this module?
	if(loading[name] !is null)
		throw "circular import"
	loading[name] = true
	scope(exit) loading[name] = null

	// Go through all the loaders and try them until one returns something
	foreach(l; loaders)
	{
		local mod = l(name)

		if(isFuncDef(mod) || isFunction(mod))
			return initModule(mod, name) // Run the module initializer
		else if(isNamespace(mod))
		{
			// Stick the namespace into the loaded table
			loaded[name] = mod
			return mod
		}
	}

	// Got through all the loaders without finding anything
	throw "couldn't find anything to load"
}

function initModule(mod: function|funcdef, name: string)
{
	// Hmmm.....
	if(isFunction(mod) && !mod.isNative())
		throw "must be native func"

	// Create the namespace for the module
	local ns = _G

	foreach(piece; name.split("."))
	{
		if(piece in ns)
		{
			if(!isNamespace(ns.(piece)))
				throw "conflicts with existing global"
		}
		else
			ns.(piece) = namespace(name) : ns {} // fake syntax.. parametric name

		ns = ns.(piece)
	}

	// If we're reloading, the namespace has to be cleared
	if(#ns > 0)
		hash.clear(ns)

	// Set up the loader function
	if(isFunction(mod))
		debug.setFuncEnv(mod, ns)
	else
		mod = newFunction(mod, ns) // fake function that really should exist somewhere; creates a function from a funcdef and (optional) namespace

	// Call it and put it in the loaded table
	mod(with ns)
	loaded[name] = ns
	return ns
}

function runMain(mod: namespace, vararg)
{
	if(hasField(mod, "main"))
	{
		local main = mod.main

		if(isFunction(main))
			main(with mod, vararg)
	}
}

function customLoad(name: string)
{
	local l = customLoaders[name]

	if(isFunction(l) || isFuncDef(l) || isNamespace(l))
		return l

	return null
}

function checkTaken(name: string)
{
	local ns = _G

	foreach(piece; name.split("."))
	{
		if(piece !in ns)
			return

		if(!isNamespace(ns.(piece)))
			throw "conflicts with existing global"

		ns = ns.(piece)
	}
}

function loadFiles(name: string)
{
	local pos = name.rfind(".")
	local packages, modName

	if(pos == #name)
	{
		packages = ""
		modName = name
	}
	else
	{
		packages = name[..pos].split(".")
		modName = name[pos + 1..]
	}

	foreach outerLoop(path; paths.split(";"))
	{
		if(!io.exists(path))
			continue

		foreach(piece; packages)
		{
			path = io.join(path, piece)

			if(!io.exists(path))
				continue outerLoop
		}

		local src = io.join(path, modName ~ ".croc")
		local bin = io.join(path, modName ~ ".croco")

		if(io.exists(src))
		{
			if(io.exists(bin))
			{
				if(time.compare(io.modified(src), io.modified(bin)) > 0)
					return compiler.compileModule(io.readFile(src), src)
				else
					return serialization.deserializeModule(bin) // fake function, should exist
			}
			else
				return compiler.compileModule(io.readFile(src), src)
		}
		else if(io.exists(bin))
			return serialization.deserializeModule(bin) // fake function, should exist
	}

	return null
}

loaders = [customLoad, checkTaken, loadFiles]*/