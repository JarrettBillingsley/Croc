module samples.simple

import streams

function main()
{
// 	registerCodec("ascii", AsciiCodec())

// 	local s = "hello there!"
// 	local asc = getCodec("ascii")
// 	local m = asc.encode(s, "replace")
// 	writeln$ m
// 	m[0] = 188
// 	local t = asc.decode(m, "replace")
// 	writeln$ t

	local r = CrocWikiLinkResolver()

	r.enterModule("string")
	r.enterItem("StringBuffer")

	writeln$ r.resolveLink("Vector.toString")

	// writeln("Globals:")
	// writeln$ json.toJSON$ r._globals, true

	// writeln()
	// writeln("Modules:")
	// writeln$ json.toJSON$ r._modules, true
}

import exceptions:
	BoundsException,
	LookupException,
	NotImplementedException,
	ParamException,
	TypeException,
	UnicodeException,
	ValueException

import string: StringBuffer

local textCodecs = {}

/**
Register a text codec of the given name. The codec can then be retrieved with \link{getCodec}.

\throws[exceptions.LookupException] if there is already a codec registered named \tt{name}.
*/
function registerCodec(name: string, codec: TextCodec)
{
	if(name in textCodecs)
		throw LookupException("Already a codec for '{}' registered".format(name))

	textCodecs[name] = codec
}

/**
Re-registers an already-registered codec with one or more alternate names.

For instance, if you wanted the codec "foobar" to be accessible also as "foo-bar" or "FOOBAR", you could use:

\code
aliasCodec("foobar", "foo-bar", "FOOBAR")
\endcode

Then \tt{getCodec("foo-bar")} and \tt{getCodec("FOOBAR")} would give the same codec as \tt{getCodec("foobar")}.

\param[name] is the name of the codec to alias. It must have been previously registered with \link{registerCodec}.
\param[vararg] is one or more strings that will be registered as aliases to the given codec.

\throws[exceptions.ParamException] if you don't pass at least one variadic argument.
\throws[exceptions.TypeException] if any of the variadic arguments are not strings.
*/
function aliasCodec(name: string, vararg)
{
	local c = getCodec(name)

	if(#vararg == 0)
		throw ParamException("Must have at least one variadic argument")

	for(i: 0 .. #vararg)
	{
		local rename = vararg[i]

		if(!isString(rename))
			throw TypeException("All variadic arguments must be strings")

		registerCodec(rename, c)
	}
}

/**
Gets the codec object that was registered with the given name.

\throws[exceptions.LookupException] if there was no codec registered with the given name.
*/
function getCodec(name: string)
{
	if(local ret = textCodecs[name])
		return ret

	throw LookupException("No codec registered for '{}'".format(name))
}

/**
Returns whether or not a codec of the given name has been registered.
*/
function hasCodec(name: string) =
	name in textCodecs

class TextCodec
{
	/**
	The name of the text encoding that this codec implements.
	*/
	name = ""

	/**
	Takes a string to encode, a memblock into which the encoded data is placed, and an index into the memblock where
	encoding should begin. The length of the memblock will be set to exactly long enough to contain the encoded data.
	The same memblock is returned.
	*/
	function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict")
		throw NotImplementedException()

	/**
	Same as calling \link{encodeInto} with a new, empty memblock and a starting index of 0.
	*/
	function encode(str: string, errors: string = "strict") =
		:encodeInto(str, memblock.new(0), 0, errors)

	/**
	Takes a memblock and a range of characters to decode. Decodes the given range into a string, which is returned.
	If the given range is not consumed in its entirety, it is an error. If you need that behavior -- and about the
	only time that you would is in a "stream decoding" situation -- that's what \link{incrementalDecoder} is for.
	*/
	function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
		throw NotImplementedException()

	/**
	Same as calling \link{decodeRange} with a slice of the entire memblock.
	*/
	function decode(src: memblock, errors: string = "strict") =
		:decodeRange(src, 0, #src, errors)

	/**
	Returns a new instance of a class derived from \link{IncrementalEncoder} that allows you to encode a stream of
	text incrementally -- that is, when the end of a string is reached, the encoder preserves any state that it needs
	so that another string can be encoded after it and treated as a continuation.
	*/
	function incrementalEncoder(errors: string = "strict")
		throw NotImplementedException()

	/**
	Returns a new instance of a class derived from \link{IncrementalDecoder} that allows you to decode a stream of text
	incrementally -- that is, when the end of the memblock range is reached, the decoder preserves any state that it
	needs so that another piece of memblock can be decoded after it and treated as a continuation.
	*/
	function incrementalDecoder(errors: string = "strict")
		throw NotImplementedException()
}

class IncrementalEncoder
{
	/**
	The error behavior of an incremental encoder is specified only once, when it's first constructed.
	*/
	this(errors: string = "strict")
		throw NotImplementedException()

	/**
	Like \link{TextCodec.encodeInto}, but works a bit differently. The \tt{final} parameter tells the function whether
	or not this is the last piece of string to be encoded. This way the encoder can throw an error if there's
	insufficient input or whatever.

	Returns three things: \tt{dest}, the number of characters consumed from \tt{str}, and the index in \tt{dest} after
	the last encoded character (that is, you could then pass that index as the \tt{start} of another call to this
	function).
	*/
	function encodeInto(str: string, dest: memblock, start: int, final: bool = false)
		throw NotImplementedException()

	/**
	Same as caling \link{encodeInto} with a new, empty memblock and a starting index of 0.
	*/
	function encode(str: string, final: bool = false) =
		:encodeInto(str, memblock.new(0), 0, final)

	/**
	Resets any internal state to its initial state so that this encoder object can be used to encode a new string.
	*/
	function reset()
		throw NotImplementedException()
}

class IncrementalDecoder
{
	/**
	The error behacior of an incremental decoder is specified only once, when it's first constructed.
	*/
	this(errors: string = "strict")
		throw NotImplementedException()

	/**
	Like \link{TextCodec.decodeRange}, but works a bit differently. The \tt{final} parameter tells the function whether
	or not this is the last piece of data to be decoded. This way the decoder can throw an error if there's insufficient
	input or whatever.

	Returns two things: a string representing the portion of \tt{src} that was decoded, and the index in \tt{src} after
	the last decoded byte (that is, you could then pass that index as the \tt{lo} of another call to this function).
	*/
	function decodeRange(src: memblock, lo: int, hi: int, final: bool = false)
		throw NotImplementedException()

	/**
	Same as calling \link{decodeRange} with a slice of the entire memblock.
	*/
	function decode(src: memblock, final: bool = false) =
		:decodeRange(src, 0, #src, final)

	/**
	Resets any internal state to its initial state so that this decoder object can be used to decode a new string.
	*/
	function reset()
		throw NotImplementedException()
}

class AsciiCodec : TextCodec
{
	name = "ascii"

	function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict")
	{
		if(start < 0) start += #dest
		if(start < 0 || start > #dest)
			throw BoundsException("Invalid start index {} for memblock of length {}".format(start, #dest))

		local i = start
		#dest = math.max(#dest, #str + start)

		foreach(j, ch; str)
		{
			local c = toInt(ch)

			if(c > 0x7f)
			{
				if(errors is "strict")
					throw UnicodeException("Character {} cannot be encoded as ASCII as its codepoint (U+{:X6}) is above U+00007F".format(j, c))
				else if(errors is "ignore")
					continue
				else if(errors is "replace")
					c = 63 // '?'
				else
					throw ValueException("Invalid error handling type '{}'".format(errors))
			}

			dest[i] = c
			i++;
		}

		#dest = start + i
		return dest
	}

	function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		if(lo < 0) lo += #src
		if(hi < 0) hi += #src
		if(lo < 0 || lo > hi || hi > #src)
			throw BoundsException("Invalid slice indices ({} .. {}) for memblock of length {}".format(lo, hi, #src))

		local s = StringBuffer(#src)

		for(i: lo .. hi)
		{
			local c = src[i]

			if(c > 0x7f)
			{
				if(errors is "strict")
					throw UnicodeException("Character at byte offset {} is invalid ASCII as its value (0x{:X2}) is above 0x7F".format(i, c))
				else if(errors is "ignore")
					continue
				else if(errors is "replace")
					c = 0xFFFD
				else
					throw ValueException("Invalid error handling type '{}'".format(errors))
			}

			s.append(toChar(c))
		}

		return s.toString()
	}
}

// =====================================================================================================================

import docs: docsOf

/**
This class defines a default behavior for mapping documentation links (made with the \tt{\\link} command) to the things
they refer to.

For URIs (such as with \tt{\\link{http://www.example.com}}), no attempt is made to ensure the correctness or well-
formedness of the link. All that happens is that they are passed to the \link{translateURI} method unchanged.

All other links are considered links to other documentable items. The way it does this is by taking a snapshot of the
global namespace and all currenly-loaded modules. This means that any modules imported after instantiating this class
are unknown to that instance, and links into them will not resolve. Most of the time this won't be a problem since
you'll likely have imported them beforehand so that you can output their docs!

Documentation links are also checked for correctness. If the link resolves to a valid item, it will be passed to the
\link{translateLink} method.

Subclasses need only implement \link{translateURI} and \link{translateLink} to translate the links into the appropriate
output format.
*/
class BaseLinkResolver
{
	// struct ItemDesc { string name, fqn; DocTable docTable; ItemDesc[string] children; }
	_modules // ItemDesc[string]
	_globals // ItemDesc[string]
	_curModule = null // ItemDesc
	_item = null // ItemDesc

	/**
	The constructor takes a snapshot of the global namespace and all loaded modules, so if there are any modules that
	you want links to resolve to, you must have imported them before instantiating this class.

	When you create a link resolver, any links will be evaluated within the global scope. You can change the scope in
	which links are resolved by using the \tt{enter/leaveItem/Module} methods.
	*/
	this()
	{
		// Setup modules
		:_modules = {}

		foreach(name, m; modules.loaded)
		{
			if(local dt = docsOf(m))
				:_modules[name] = :_makeMapRec(dt)
		}

		// Setup globals
		if(local dt = docsOf(_G))
			:_globals = :_makeMapRec(dt).children
		else
			:_globals = {}

		// Might be some globals added by user code that aren't in docsOf(_G).children
		foreach(name, val; _G)
		{
			if(name !is "_G" && name !in :_globals && name !in modules.loaded)
			{
				if(local dt = docsOf(val))
					:_globals[name] = :_makeMapRec(dt)
			}
		}
	}

	/**
	Returns a string saying what scope this resolver is currently operating in.

	\returns one of \tt{"global"} (the default), \tt{"module"} (when you have entered a module), or \tt{"item"} (when
	you have entered an item within a module).
	*/
	function currentScope()
	{
		if(:_item is null)
		{
			if(:_module is null)
				return "global"
			else
				return "module"
		}
		else
			return "item"
	}

	/**
	Switches from global scope to module scope, so that links will be resolved in the context of the given module.

	This method is called automatically by the various doc outputters which take link resolvers.

	\throws[exceptions.ValueException] if the current scope is not global scope.
	\throws[exceptions.ValueException] if there is no module of the given name.
	*/
	function enterModule(name: string)
	{
		if(:_item !is null || :_curModule !is null)
			throw ValueException("Attempting to enter a module from {} scope".format(:currentScope()))

		if(local m = :_modules[name])
			:_curModule = m
		else
			throw ValueException("No module named '{}' (did you import it after creating this resolver?)".format(name))
	}

	/**
	Switches from module scope back to global scope.

	This method is called automatically by the various doc outputters which take link resolvers.

	\throws[exceptions.ValueException] if the current scope is not module scope.
	*/
	function leaveModule()
	{
		if(:_item !is null || :_curModule is null)
			throw ValueException("Attempting to leave a module from {} scope".format(:currentScope()))

		:_curModule = null
	}

	/**
	Switches from module scope to item scope, so that links will be resolved in the context of the given item (class or
	namespace declaration).

	This method is called automatically by the various doc outputters which take link resolvers.

	\throws[exceptions.ValueException] if the current scope is not module scope.
	\throws[exceptions.ValueException] if there is no item of the given name in the current module.
	*/
	function enterItem(name: string)
	{
		if(:_item !is null || :_curModule is null)
			throw ValueException("Attempting to enter an item from {} scope".format(:currentScope()))

		if(local i = :_curModule.children[name])
			:_item = i
		else
			throw ValueException("No item named '{}' in {}".format(name, _curModule.name))
	}

	/**
	Switches from item scope back to module scope.

	This method is called automatically by the various doc outputters which take link resolvers.

	\throws[exceptions.ValueException] if the current scope is not item scope.
	*/
	function leaveItem()
	{
		if(:_item is null || :_curModule is null)
			throw ValueException("Attempting to leave an item from {} scope".format(:currentScope()))

		:_item = null
	}

	/**
	Given a raw, unprocessed link, turns it into a link string suitable for output.

	It does this by analyzing the link, determining whether it's a URI or a code link, ensuring it's a valid link if
	it's a code link, and then calling \link{translateLink} or \link{translateURI} as appropriate to turn the raw link
	into something suitable for output. It does not process the outputs of those two methods; whatever they return is
	what this method returns.
	*/
	function resolveLink(link: string)
	{
		if("/" in link)
		{
			// URI; no further processing necessary. If someone writes something like "www.example.com" it's ambiguous
			// and it's their fault when it doesn't resolve :P
			return :translateURI(link)
		}
		else
		{
			// Okay, so: names aren't really all that specific. Name lookup works more or less like in Croc itself, with
			// one exception: names can refer to other members within classes and namespaces.
			// In any case, a dotted name can resolve to one of two locations (qualified name within current module, or
			// fully-qualified name), and a name without dots can resolve to one of FOUR locations (those two, plus
			// global, or another name within the current class/NS).
			// Also, names shadow one another. If you write a link to \tt{toString} within a class that defines it, the
			// link will resolve to this class's method, rather than the function declared at global scope.

			local isDotted = "." in link

			if(!isDotted && :_inItem(link)) // not dotted, could be item name
				return :translateLink(:_curModule.name, :_item.name ~ "." ~ link)
			else if(:_inCurModule(link)) // maybe it's something in the current module
				return :translateLink(:_curModule.name, link)
			else
			{
				// tryyyy all the modules!
				local isFQN, modName, itemName = :_inModules(link)

				if(isFQN)
					return :translateLink(modName, itemName)

				// um. um. global?!
				// it might be a member of a global class or something, or just a plain old global
				if(:_inGlobalItem(link) || :_inGlobals(link))
					return :translateLink("", link)
			}
		}

		// noooooo nothing matched :(
		return :invalidLink(link)
	}

	/**
	Given a module name and a sub-item name (which may or may not be dotted, since it might be something like a class
	field), translates them into a suitable link string.

	This, and \link{translateURI} are the only methods you have to override in a subclass.

	\param[mod] is the name of the module that contains the linked item, or the empty string if the linked item is in
		the global namespace.
	\param[item] is the name of the item that is being linked, or the empty string if the link points at the given
		module instead.
	\returns the link translated into a form that makes sense to whatever output format you're using.
	*/
	function translateLink(mod: string, item: string)
		throw NotImplementedException()

	/**
	Given a URI, translates it into a suitable link string.

	This, and \link{translateLink} are the only methods you have to override in a subclass.

	\param[uri] is the URI to translate.
	\returns the link translated into a form that makes sense to whatever output format you're using.
	*/
	function translateURI(uri: string)
		throw NotImplementedException()

	/**
	This method is called when the given link fails to resolve.

	\link{resolveLink} will call this method if it fails to find a valid target for the given link. This method can
	return a string which will then be returned by \link{resolveLink}. By default, this method throws a
	\link{exceptions.ValueException} saying which link failed, but you can override it so that it does something else
	(such as returning a dummy link and logging the error to stderr).

	\param[link] is the link that failed to resolve.

	\returns a replacement string, optionally.
	*/
	function invalidLink(link: string)
		throw ValueException("No target found for link '{}'".format(link))

	// =================================================================================================================
	// Private

	function _inGlobalItem(link: string)
	{
		local dot = link.find(".")

		if(dot is #link)
			return false

		local n = link[0 .. dot]
		local f = link[dot + 1 ..]
		local i = :_globals[n]

		return i !is null && i.children && f in i.children
	}

	function _inItem(link: string) =
		:_item !is null && link in :_item.children

	function _inCurModule(link: string) =
		:_curModule !is null && :_inModule(:_curModule, link)

	function _inGlobals(link: string) =
		link in :_globals

	function _inModules(link: string)
	{
		if(link in :_modules)
			return true, link, ""

		// What we're doing here is trying every possible prefix as a module name. So for the name "a.b.c.d" we try
		// "a.b.c", "a.b", and "a" as module names, and see if the rest of the string is an item inside it.
		local lastDot

		for(local dot = link.rfind("."); dot != #link; dot = link.rfind(".", lastDot - 1))
		{
			lastDot = dot
			local modName = link[0 .. dot]

			if(local m = :_modules[modName])
			{
				// There can only be ONE match to the module name. Once you find it, there can't be any other modules
				// with names that are a prefix, since that's enforced by the module system. So if the item doesn't
				// exist in this module, it doesn't exist at all

				local itemName = link[dot + 1 ..]

				if(:_inModule(m, itemName))
					return true, modName, itemName
				else
					return false
			}
		}

		return false
	}

	function _inModule(mod: table, item: string)
	{
		local t = mod

		foreach(piece; item.split("."))
		{
			if(t.children is null)
				return false

			t = t.children[piece]

			if(t is null)
				return false
		}

		return true
	}

	function _makeMapRec(dt: table)
	{
		local ret = { name = dt.name }

		if(dt.children)
		{
			ret.children = {}

			foreach(child; dt.children)
			{
				local c = :_makeMapRec(child)
				ret.children[child.name] = c

				if(local dit = child.dittos)
				{
					foreach(d; dit)
						ret.children[d.name] = c
				}
			}
		}

		return ret
	}
}

/**
A link resolver that does absolutely nothing.

It never throws any errors or does anything, really  It's useful for when you don't want any link resolution behavior at
all. Its \link{resolveLink} and \tt{translateLink/URI} methods return the empty string.
*/
class NullLinkResolver : BaseLinkResolver
{
	this() {}
	function enterModule(name: string) {}
	function leaveModule() {}
	function enterItem(name: string) {}
	function leaveItem() {}
	function resolveLink(link: string) = ""
	function translateLink(mod: string, item: string) = ""
	function translateURI(uri: string) = ""
	function invalidLink(link: string) {}
}

local StdlibLookup =
{
	array         = "StdLib/ArrayLib"
	ascii         = "StdLib/AsciiLib"
	compiler      = "StdLib/CompilerLib"
	console       = "StdLib/ConsoleLib"
	debug         = "StdLib/DebugLib"
	docs          = "StdLib/DocsLib"
	env           = "StdLib/EnvLib"
	exceptions    = "StdLib/ExceptionsLib"
	file          = "StdLib/FileLib"
	gc            = "StdLib/GCLib"
	hash          = "StdLib/HashLib"
	json          = "StdLib/JsonLib"
	math          = "StdLib/MathLib"
	memblock      = "StdLib/MemblockLib"
	modules       = "StdLib/ModulesLib"
	os            = "StdLib/OSLib"
	path          = "StdLib/PathLib"
	regexp        = "StdLib/RegexpLib"
	serialization = "StdLib/SerializationLib"
	stream        = "StdLib/StreamLib"
	string        = "StdLib/StringLib"
	text          = "StdLib/TextLib"
	thread        = "StdLib/ThreadLib"
	time          = "StdLib/TimeLib"

	devil         = "Addons/DevilLib"
	gl            = "Addons/GlLib"
	net           = "Addons/NetLib"
	pcre          = "Addons/PCRE"
	sdl           = "Addons/SdlLib"
}

class CrocWikiLinkResolver : BaseLinkResolver
{
	function translateLink(mod: string, item: string)
	{
		if(mod is "")
		{
			if(item is "")
				return "StdLib/BaseLib"
			else switch(item)
			{
				case "Object":    return "StdLib/Object"
				case "Throwable": return "StdLib/Throwable"
				default:          return "StdLib/BaseLib#" ~ item
			}
		}
		else
		{
			local ret = StdlibLookup[mod]

			if(ret is null)
				throw ValueException("Unknown stdlib module '{}'".format(mod))

			if(item is "")
				return ret
			else
				return ret ~ "#" ~ item
		}
	}

	function translateURI(uri: string) =
		uri
}