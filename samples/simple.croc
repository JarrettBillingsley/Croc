module samples.simple

function main()
{
// 	BaselibDumper().dump()

// 	StdlibDumper.dump(string)

// 	writeln$ json.toJSON(docsOf(Object), true)
// 	foreach(member; docsOf(array).children)
// 		writeln$ json.toJSON(member, true)

	local b = BaseDocOutput()
	b.insertSectionBefore("docs", "deprecated")
	writeln$ b.getSectionOrder()
	b.insertSectionAfter("docs", "license")
	writeln$ b.getSectionOrder()
}

import exceptions:
	TypeException,
	ValueException,
	NotImplementedException

local stdSections =
[
	"deprecated"

	"docs"
	"examples"
	"param"
	"returns"
	"throws"

	"bugs"
	"notes"
	"todo"
	"warnings"

	"see"

	"authors"
	"date"
	"history"
	"since"
	"version"

	"copyright"
	"license"
]

local function validSectionName(name: string) =
	!(#name == 0 || (#name == 1 && name[0] == '_') || (name[0] != '_' && name !in stdSections))

class BaseDocOutput
{
	_sectionOrder = stdSections.dup()
	_sectionHandlers = 
	{
    	docs = "handleDocsSection",
    	param = "handleParamSection",
    	throws = "handleThrowsSection"
	}

	this()
	{
		:_sectionOrder = :_sectionOrder.dup()
		:_sectionHandlers = hash.dup(:_sectionHandlers)
	}

	// Section/text span handlers
	// Link indexing/lookup
	// High-level output funcs

	// =================================================================================================
	// Section ordering

	function insertSectionBefore(sec: string, before: string)
		:_insertSectionImpl(sec, before, false)

	function insertSectionAfter(sec: string, after: string)
		:_insertSectionImpl(sec, after, true)

	function _insertSectionImpl(sec: string, target: string, after: bool)
	{
		if(!validSectionName(sec))
			throw ValueException(format("Invalid section name '{}'", sec))
		else if(!validSectionName(target))
			throw ValueException(format("Invalid section name '{}'", target))
		else if(sec == target)
			throw ValueException("Section names must be different")

		local ord = :_sectionOrder

		// Check if this section is already in the order. It's possible for it not to be,
		// if it's a custom section.
		local idx = ord.find(sec)

		if(idx < #ord)
			ord.pop(idx)

		// Find where to insert and put it there.
		local targetIdx = ord.find(target)

		if(targetIdx == #ord)
			throw ValueException(format("Section '{}' does not exist in the section order", target))

		ord.insert(after ? targetIdx + 1 : targetIdx, sec)
	}

	function getSectionOrder() =
		:_sectionOrder.dup()

	function setSectionOrder(order: array)
	{
		// Make sure it's an array of valid section names
		foreach(name; order)
		{
			if(!isString(name))
				throw ValueException("Order must be an array of nothing but strings")
			else if(!validSectionName(name))
				throw ValueException(format("Invalid section name '{}' in given order", name))
		}

		// Make sure all standard sections are accounted for
		foreach(sec; stdSections)
			if(sec !in order)
				throw ValueException(format("Standard section '{}' does not exist in the given order", sec))

		:_sectionOrder = order.dup()
	}
	
	// =================================================================================================
	// Section handlers
	
	function getSectionHandler(name: string)
	{
		if(local handler = :_sectionHandlers[name])
			return handler
		else
			return "defaultSectionHandler"
	}
	
	function setSectionHandler(name: string, handlerName: string)
	{
		if(name !in :_sectionOrder)
			throw ValueException(format("Section '{}' does not appear in the section order", name))
		
		if(!hasMethod(this, handlerName))
			throw ValueException(format("No method named '{}' exists in this class", handlerName))

		:_sectionHandlers[name] = handlerName
	}

	function defaultSectionHandler(name: string, contents: array)
	{
		:beginParagraph()
		:beginBold()
		:outputText(name, ": ")
		:endBold()
		:outputParagraphContents(contents[0])
		:endParagraph()

		:outputParagraphs(contents[1 ..])
	}

	function handleDocsSection(name: string, contents: array)
	{
		if(#contents == 1 && #contents[0] == 1 && contents[0][0] is "")
			return

		:outputParagraphs(contents)
	}

	function handleParamSection(name: string, contents: array)
	{
		if(#contents == 0)
			return
			
		:beginParagraph()
		:beginBold()
		:outputText("Params:")
		:endBold()
		:endParagraph()
		
		:beginDefList()
		
		foreach(param; contents)
		{
			:beginDefTerm()
			:beginBold()
			
			:outputText(param.name)
			
			if(param.type != "any" && param.type != "vararg")
				:outputText(": ", param.type)

			if(param.value)
				:outputText(" = ", param.value)

			:endBold()
			:endDefTerm()
			
			:beginDefDef()
			:outputParagraphs(param.docs)
			:endDefDef()
		}

		:endDefList()
	}
	
	function handleThrowsSection(name: string, contents: array)
	{
		assert(#contents > 0)
		
		:beginParagraph()
		:beginBold()
		:outputText("Throws:")
		:endBold()
		:endParagraph()
		
		:beginDefList()
		
		foreach(ex; contents)
		{
			:beginDefTerm()
			:beginBold()
			:outputText(ex[0])
			:endBold()
			:endDefTerm()

			:beginDefDef()
			:outputParagraphs(ex[1..])
			:endDefDef()
		}

		:endDefList()
	}
}

class TracWikiDocOutput : BaseDocOutput
{

}

// import streams: Stream, MemblockStream, BinaryStream, UTF8Stream

// function main()
// {
//
// }
// 
/* import exceptions: TypeException, ValueException

function help(x, child: string = null)
{
	local d

	if(isString(x))
	{
		local mt

		try
			mt = debug.getMetatable(x)
		catch(e: Exception)
			throw TypeException(format("Invalid type '{}'", x))

		if(child in mt)
			d = docsOf(mt.(child))
	}
	else
	{
		d = docsOf(x)

		if(#d && child !is null)
		{
			if(d.children is null)
				throw ValueException("No children")

			local found = false

			foreach outerLoop(c; d.children)
			{
				if(c.name == child)
				{
					found = true
					d = c
					break
				}

				if(c.dittos)
				{
					foreach(dit; c.dittos)
					{
						if(dit.name == child)
						{
							found = true
							d = c
							break outerLoop
						}
					}
				}
			}

			if(!found)
				throw ValueException("Not found")
		}
	}

	if(#d == 0)
	{
		writeln("<no help available>")
		return
	}

	function writeHeader(d)
	{
		if(d.protection)
			write(d.protection, " ")

		write(d.kind, " ", d.name)

		if(d.params)
		{
			write("(")

			foreach(i, p; d.params)
			{
				if(i > 0)
					write(", ")

				write(p.name)

				if(p.type != "any" && p.type != "vararg")
					write(": ", p.type)

				if(p.value)
					write(" = ", p.value)
			}

			write(")")
		}

		if(d.base)
			write(" : ", d.base)

		if(d.value)
			write(" = ", d.value)

		write(" (", d.file)
		if(d.line != 0)
			write(":  ", d.line)
		writeln(")")
	}

	writeHeader(d)

	if(d.dittos)
		foreach(dit; d.dittos)
			writeHeader(dit)

	foreach(line; d.docs.splitLines())
		writeln("  ", line.strip())

	if(d.children && #d.children)
	{
		writeln()
		writeln("Members:")

		foreach(c; d.children)
			writeln("   ", c.name)
	}

	writeln()
} */

local listRE = regexp.Regexp(@"^(\*|\d\.) .*$")

class DocDumper
{
	indentChildren = false

	function dumpDocs(docs: string, indent: bool)
	{
		local codeSec, list = false, false

		foreach(line; docs.splitLines())
		{
			local s = line.strip()

			if(s == "")
			{
				list = false
				writeln()
				continue
			}
			else if(s == "{{{")
				codeSec = true
			else if(listRE.test(s))
				list = true

			if(codeSec || list)
				writeln(line)
			else
			{
				if(indent)
					write(" ")
				writeln(s)
			}

			if(s == "}}}")
				codeSec = false
		}
	}

	function dumpHeader(d, isChild: bool = :indentChildren)
	{
		switch(d.kind)
		{
			case "function":
				writef("{}(", d.name == "constructor" ? "this" : d.name)

				foreach(i, p; d.params)
				{
					if(i > 0)
						write(", ")

					write(p.name)

					if(p.type != "any" && p.type != "vararg")
						write(": ", p.type)

					if(p.value)
						write(" = ", p.value)
				}

				write(")")
				break

			case "class", "namespace":
				write(d.kind, " ", d.name)
				if(d.base)
					write(" : ", d.base)
				break

			case "field":
				write(d.name)

				if(d.value)
					write(" = ", d.value)
				break

			case "variable":
				write(d.protection, " ", d.name)

				if(d.value)
					write(" = ", d.value)
				break

			default:
				writeln("<unhandled kind ", d.kind, " ", d.name, ">")
		}
	}

	function dumpItem(d, isChild: bool = :indentChildren)
	{
		:dumpHeader(d, isChild)

		if(d.dittos)
			foreach(dit; d.dittos)
				:dumpHeader(dit, true)

		switch(d.kind)
		{
			case "function", "field", "variable":
				:dumpDocs(d.docs, isChild)
				writeln()
				break

			case "class", "namespace":
				writeln()
				:dumpDocs(d.docs, isChild)
				writeln()

				foreach(child; d.children)
					:dumpItem(child, true)
				break

			default:
				writeln("<unhandled kind ", d.kind, " ", d.name, ">")
		}
	}
}

class BaselibDumper : DocDumper
{
	this()
		:indentChildren = true

	function dumpHeader(d, isChild: bool)
	{
		write(" '''`")
		super.dumpHeader(d)
		writeln("`'''::")
	}

	function dump()
	{
		local d = docsOf(_G)

		writefln("= {} =", d.name)
		writeln()
		:dumpDocs(d.docs, false)
		writeln()
		writeln("[[PageOutline(2-9, Table of Contents, inline)]]")
		writeln()

		local curSection = ""

		foreach(child; d.children)
		{
			if(child.section != curSection)
			{
				curSection = child.section
				writefln("== {} ==", curSection)
				writeln()
			}

			:dumpItem(child)
		}
	}
}

class StdlibDumper : DocDumper
{
	function dumpHeader(d, isChild: bool)
	{
		if(isChild)
			write(" '''`")
		else
			write("== '''`")

		super.dumpHeader(d)

		if(isChild)
			writeln("`'''::")
		else
			writeln("`''' ==")
	}

	function dump(mod)
	{
		local d = docsOf(mod)

		writefln("= {} =", d.name)
		writeln()
		:dumpDocs(d.docs, false)
		writeln()
		writeln("[[PageOutline(2-9, Members, inline)]]")
		writeln()

		foreach(child; d.children)
			:dumpItem(child)
	}
}

/*
I guess it's baselib (but could be moved?)
	stringification
		toString(value, style: char = 'd')
		rawToString(value)
		format(fmt: string, vararg)
	console IO
		write(vararg)
		writeln(vararg)
		writef(vararg)
		writefln(vararg)
		readln()
		dumpVal(value, printNewline: bool = true)
	conversions
		toBool(value)
		toInt(value: bool|int|float|char|string)
		toFloat(value: bool|int|float|char|string)
		toChar(value: int)
*/