module samples.simple

import streams

function main()
{
	local t = docs.TracWikiDocOutput()
	t.outputItem(docs.docsOf(docs.parseCommentText), "")

	// registerCodec("ascii", AsciiCodec())

	// local s = "hello there!"
	// local asc = getCodec("ascii")
	// local m = asc.encode(s, "replace")
	// writeln$ m
	// m[0] = 188
	// local t = asc.decode(m, "replace")
	// writeln$ t
}

import docs: docsOf

class BaseLinkResolver
{
	// ItemDesc[string]
	// struct ItemDesc { string name; ItemDesc[string] children; }
	_modules
	_enclosing

	this()
	{
		:_modules = {}

		if(local dt = docsOf(_G))
			:_modules[""] = :_makeChildMap(dt)

		:_enclosing = []
	}

	function addModule(name: string)
	{
		if(name in :_modules)
			throw ValueException("Module '{}' has already been added".format(name))

		local mod = :_lookupModule(name)
		local dt = docsOf(m)

		if(dt is null)
			throw ValueException("Module '{}' has no documentation".format(name))
		else if(dt.kind !is "module")
			throw ValueException("'{}' does not name a module, it names a '{}'".format(name, dt.kind))

		:_modules[name] = :_makeChildMap(dt)
	}

	function addModules(vararg)
	{
		for(i: 0 .. #vararg)
		{
			local m = vararg[i]

			if(!isString(m))
				throw TypeException("All parameters must be strings; parameter {} is a '{}'".format(i + 1, typeof(m)))

			:addModule(m)
		}
	}

	function addStdModules()
	{
		:addModules(
			"docs",
			"exceptions",
			"gc",
			"modules",
			"array",
			"ascii",
			"compiler",
			"console",
			"env",
			"hash",
			"json",
			"math",
			"memblock",
			"path",
			"regexp",
			"serialization",
			"stream",
			"string",
			"text",
			"thread",
			"time")

		foreach(mod; ["debug", "file", "os", "devil", "gl", "net", "pcre", "sdl"])
		{
			if(mod in _G)
				:addModule(mod)
		}
	}

	function enterItem(dt: table)
	{
		:_enclosing.append(:_makeChildMap(dt))
	}

	function leaveItem()
	{
		assert(#:_enclosing > 0, "item stack underflow")
		:_enclosing.pop()
	}

	function resolveLink(link: string)
	{
		if("/" in link)
		{
			// URI; no further processing necessary. If someone writes something like "www.example.com" it's ambiguous and it's their
			// fault when it doesn't resolve :P
			return link
		}
		else if('.' in link)
		{
			// probably a FQN, but might be a QN in this namespace (Classname.field or similar)

			// let's treat it like it's a local QN first

			// that didn't work; treat it as an FQN
		}
		else
		{
			// relative name
		}
	}

	function translateLink(mod: string, item: string)
		throw NotImplementedException()

	function _lookupModule(name: string)
	{
		local m = _G

		foreach(namePart; name.split("."))
		{
			if(namePart in m)
				m = m.(namePart)
			else
				throw ValueException("Module '{}' does not exist".format(name))

			if(!isNamespace(m))
				throw ValueException("'{}' does not name a module".format(name))
		}

		return m
	}

	function _makeChildMap(dt: table)
	{
		local ret = {}

		foreach(child; dt.children)
		{
			local t = { name = child.name }

			if(child.children)
				t.children = :_makeChildMap(child)

			ret[child.name] = t

			if(local dit = child.dittos)
				foreach(d; dit)
					ret[d.name] = t
		}

		return ret
	}
}

import exceptions: BoundsException, UnicodeException
import string: StringBuffer

local textCodecs = {}

function registerCodec(name: string, codec: TextCodec)
{
	if(name in textCodecs)
		throw LookupException("Already a codec for '{}' registered".format(name))

	textCodecs[name] = codec
}

function getCodec(name: string)
{
	if(local ret = textCodecs[name])
		return ret

	throw LookupException("No codec registered for '{}'".format(name))
}

function hasCodec(name: string) =
	name in textCodecs

class TextCodec
{
	name = ""

	function encodeInto(str: string, dest: memblock, errors: string = "strict")
		throw NotImplementedException()

	function encode(str: string, errors: string = "strict") =
		:encodeInto(str, memblock.new(0), errors)

	function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
		throw NotImplementedException()
		
	function decode(src: memblock, errors: string = "strict") =
		:decodeRange(src, 0, #src, errors)

	function incrementalEncoder(errors: string = "strict")
		throw NotImplementedException()

	function incrementalDecoder(errors: string = "strict")
		throw NotImplementedException()
}

class IncrementalEncoder
{
	this(errors: string = "strict")
		throw NotImplementedException()

	function encodeInto(str: string, dest: memblock, final: bool = false)
		throw NotImplementedException()

	function encode(str: string, final: bool = false) =
		:encodeInto(str, memblock.new(0), final)

	function reset()
		throw NotImplementedException()
}

class IncrementalDecoder
{
	this(errors: string = "strict")
		throw NotImplementedException()

	function decodeRange(src: memblock, lo: int, hi: int, final: bool = false)
		throw NotImplementedException()

	function decode(src: memblock, final: bool = false) =
		:decodeRange(src, 0, #src, final)

	function reset()
		throw NotImplementedException()
}

class AsciiCodec : TextCodec
{
	name = "ascii"

	function encodeInto(str: string, dest: memblock, errors: string = "strict")
	{
		#dest = #str
		local i = 0

		foreach(j, ch; str)
		{
			local c = toInt(ch)

			if(c > 0x7f)
			{
				if(errors is "strict")
					throw UnicodeException("Character {} cannot be encoded as ASCII as its codepoint (U+{:X5}) is above U+0007F".format(j, c))
				else if(errors is "ignore")
					continue
				else if(errors is "replace")
					c = 63 // '?'
				else
					throw ValueException("Invalid error handling type '{}'".format(errors))
			}

			dest[i] = c
			i++;
		}

		#dest = i
		return dest
	}

	function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		if(lo < 0) lo += #src
		if(hi < 0) hi += #src
		
		if(lo < 0 || lo > hi || hi > #src)
			throw BoundsException("Invalid slice indices ({} .. {}) for memblock of length {}".format(lo, hi, #src))
			
		local s = StringBuffer(#src)
		
		for(i: lo .. hi)
		{
			local c = src[i]
			
			if(c > 0x7f)
			{
				if(errors is "strict")
					throw UnicodeException("Character at byte offset {} is invalid ASCII as its value (0x{:X2}) is above 0x7F".format(i, c))
				else if(errors is "ignore")
					continue
				else if(errors is "replace")
					c = 0xFFFD
				else
					throw ValueException("Invalid error handling type '{}'".format(errors))
			}
			
			s.append(toChar(c))
		}
		
		return s.toString()
	}
}