module samples.simple

// import streams: Stream, MemblockStream, BinaryStream, UTF8Stream

import exceptions: CompileException
import compiler: loadString

namespace Test {}

function xpass(code: string, result = null)
{
	local func, ret
	hash.clear(Test)

	try
		func = loadString(code, Test)
	catch(e: CompileException)
		throw Exception(format("Test '{}' failed to compile", code), e)

	try
		ret = func()
	catch(e: Exception)
		throw Exception(format("Test '{}' expected to pass but failed", code), e)

	if(typeof(ret) != typeof(result) || ret != result)
		throw Exception(format("Test '{}' expected to give results '{}' but gave '{}' instead", code, result, ret))
}

function xfail(code: string, args: array, result: class)
{
	local func
	hash.clear(Test)

	try
		func = loadString(code, Test)
	catch(e: CompileException)
		throw Exception(format("Test '{}' failed to compile", code), e)

	try
		func(args.expand())
	catch(e: Exception)
	{
		if(e as result)
			return

		throw Exception(format("Test '{}' expected to fail and did, but threw exception type '{}' instead of '{}'", code, e.super, result), e)
	}

	throw Exception(format("Test '{}' expected to fail but passed"))
}

function xcomppass(code: string)
{
	try
		loadString(code)
	catch(e: CompileException)
		throw Exception(format("Test '{}' expected to pass compilation but failed", code), e)
	catch(e: Exception)
		throw Exception(format("Test '{}' expected to pass compilation but caused an error", e))
}

function xcompfail(code: string)
{
	try
		loadString(code)
	catch(e: CompileException)
		return
	catch(e: Exception)
		throw Exception(format("Test '{}' expected to fail compilation but caused another error", e))

	throw Exception(format("Test '{}' expected to fail compilation but passed"))
}

function main()
{
	// TODO: make xcompfail take some sort of "somethingLike" parameter which it will search for in the compiler error
	xpass("function foo(x: @isString) {} foo(@`hi`)")
	xpass("local t = {f = isString}; function foo(x: @t.f) {} foo(@`hi`)")
	xpass("@attrs({}) @attrs({}) function foo() {} foo(); attributesOf(foo)")
	xpass("local function foo() {} foo()")
	xpass("local class C {} C()")
	xcompfail("@foo.bar(with 5) function blah(){}")
	xpass("local t = {function f(x) = x}; @t.f function foo(){} foo()")
	xpass("local C = class C{}; C()")
	xpass("local N = namespace N{x = 5}; N.x = 10")
	xpass("local namespace N {x = 5} local namespace M : N {x = 4} M.x = 10")
	xpass("@attrs({}) class C{} C(); attributesOf(C)")
	xpass("@attrs({}) namespace N{x = 5} N.x = 10; attributesOf(N)")
	xcompfail("local x, x")
	xpass("global x; x = 5")
	xpass("local x = 5; if(local y = x) return y; return 0", 5)
	xpass("local x = 5; while(x > 0) { x-- }")
	xpass("local x = 5; while(local y = x) { x-- }")
	xpass("while(true) break")
	xpass("while(local x = true) return x", true)
	xpass("local x = 5; do { x-- } while(x > 0)")
	xpass("do { break; } while(false)")
	xpass("do { break; } while(true)")
	xpass("for(local x = 0; x < 10; x++) {}")
	xpass("for(isString(0); ;) { break }")
	xpass("foreach(v; [1 2 3]) {}")
	xpass("switch(5) { case 0 .. 10: return true; case 10000: default: return false }", true)
	xpass("for(x: 0 .. 10) continue")
	xpass("try { return } finally {}")
	xpass("local x = 1; x += 1; x -= 1; x *= 1; x /= 1; x %= 2; x &= 1; x |= 1; x ^= 0; x <<= 1; x >>= 1; x >>>= 1")
	xpass("local x, y = @`yep`, @`nope`; return x || y", "yep")
	xpass("local x, y = @`yep`, @`nope`; return x && y", "nope")
	xpass("local x, y = 1, 2; return x + y", 3)
	xpass("local x, y = 1, 2; return x - y", -1)
	xpass("local x, y = 1, 2; return x * y", 2)
	xpass("local x, y = 1, 2; return x / y", 0)
	xpass("local x, y = 1, 2; return x % y", 1)
	xpass("local x, y = 1, 2; return x & y", 0)
	xpass("local x, y = 1, 2; return x | y", 3)
	xpass("local x, y = 1, 2; return x ^ y", 3)
	xpass("local x, y = 1, 2; return x << y", 4)
	xpass("local x, y = 1, 2; return x >> y", 0)
	xpass("local x, y = 1, 2; return x >>> y", 0)
	xpass("local x, y = 1, 2; return x <=> y", -1)
	xpass("local x, y = 1, 2; return x == y", false)
	xpass("local x, y = 1, 2; return x != y", true)
	xpass("local x, y = 1, 2; return x is y", false)
	xpass("local x, y = 1, 2; return x !is y", true)
	xpass("local x, y = 1, 2; return x < y", true)
	xpass("local x, y = 1, 2; return x <= y", true)
	xpass("local x, y = 1, 2; return x > y", false)
	xpass("local x, y = 1, 2; return x >= y", false)
	xpass("local x, y = 1, [2]; return x in y", false)
	xpass("local x, y = 1, [2]; return x !in y", true)
	xpass("local x = 1; return -x", -1);
	xpass("local x = 1; return !x", false);
	xpass("local x = 1; return ~x", 0xFFFFFFFF_FFFFFFFE);
	xpass("function foo() { return 5; } local coro = coroutine foo; return coro()", 5)
	xpass("return #vararg", 0)
	xcompfail("function foo() = #vararg")
	xpass("class B { function f() = 5 } class C : B { function f() = super.f() } return C().f()", 5)
	xpass("function foo() = this return foo(with 5)", 5)
	xpass("function foo(vararg) = vararg[0] return foo(3)", 3)
	xcompfail("function foo() = vararg[0]")
	xpass("local a = @`abc`; return a[0 .. 2]", "ab")
	xpass("function foo(vararg) return vararg[0 .. 2]; local x, y = foo(1, 2, 3); return x + y", 3)
	xcompfail("function foo() return vararg[0 .. 2]")
	xpass("return 2.3", 2.3)
	xpass("function foo(vararg) return (vararg); return foo(3)", 3)
	xcompfail("function foo() return (vararg)")
	xpass("function foo() return 1, 2, 3; return [foo()]", [1 2 3])
	xpass("function foo() yield(1, 2, 3); local c = coroutine foo; return [c()]", [1 2 3])
	xpass("local t = {[i] = v foreach i, v; @`abc`}; return hash.keys(t).sort() ~ hash.values(t).sort()", [0 1 2 'a' 'b' 'c'])
	xpass("local a = [c foreach c; @`abc`]; return a", ['a' 'b' 'c'])
	xpass("local a = [c for c: 0 .. 3]; return a", [0 1 2])
	xpass("local a = [c + d for c: 0 .. 3 for d: 4 .. 6]; return a", [4 5 5 6 6 7])
	xpass("local a = [c foreach i, c; @`axbxcx` if (i & 1) == 0]; return a", ['a' 'b' 'c'])
	xpass("local a = [a * b foreach i, a; [1 0 2 0 3 0] for b: 1 .. 2 if (i & 1) == 0]; return a", [1 2 3])
	xpass("local a = [a * b foreach a; [1 2] if a > 1 foreach b; [5 6]]; return a", [10 12])
	xpass("local a = [a * b for a: 1 .. 3 if a > 1 for b: 5 .. 7]; return a", [10 12])
	xpass("local x = 4; if(x ? false : true) return 1; else return 2", 2)
	xpass("local x, y = 1, 2; if(x && y) return true", true)
	xpass("function foo() = 5 if((foo())) return true", true)
}

/*
function help(x, child: string = null)
{
	local d

	if(isString(x))
	{
		local mt

		try
			mt = debug.getMetatable(x)
		catch(e)
			throw format("Invalid type '{}'", x)

		if(child in mt)
			d = docsOf(mt.(child))
	}
	else
	{
		d = docsOf(x)

		if(#d && child !is null)
		{
			if(d.children is null)
				throw "No children"

			local found = false

			foreach outerLoop(c; d.children)
			{
				if(c.name == child)
				{
					found = true
					d = c
					break
				}

				if(c.dittos)
				{
					foreach(dit; c.dittos)
					{
						if(dit.name == child)
						{
							found = true
							d = c
							break outerLoop
						}
					}
				}
			}

			if(!found)
				throw "Not found"
		}
	}

	if(#d == 0)
	{
		writeln("<no help available>")
		return
	}

	function writeHeader(d)
	{
		if(d.protection)
			write(d.protection, " ")

		write(d.kind, " ", d.name)

		if(d.params)
		{
			write("(")

			foreach(i, p; d.params)
			{
				if(i > 0)
					write(", ")

				write(p.name)

				if(p.type != "any" && p.type != "vararg")
					write(": ", p.type)

				if(p.value)
					write(" = ", p.value)
			}

			write(")")
		}

		if(d.base)
			write(" : ", d.base)

		if(d.value)
			write(" = ", d.value)

		write(" (", d.file)
		if(d.line != 0)
			write(":  ", d.line)
		writeln(")")
	}

	writeHeader(d)

	if(d.dittos)
		foreach(dit; d.dittos)
			writeHeader(dit)

	foreach(line; d.docs.splitLines())
		writeln("  ", line.strip())

	if(d.children && #d.children)
	{
		writeln()
		writeln("Members:")

		foreach(c; d.children)
			writeln("   ", c.name)
	}

	writeln()
}

function dumpDocs(docs: string, indent: bool)
{
	local strip = true

	foreach(line; docs.splitLines())
	{
		local s = line.strip()

		if(s == "")
		{
			writeln()
			continue
		}
		else if(s == "{{{")
			strip = false

		if(strip)
		{
			if(indent)
				write(" ")
			writeln(s)
		}
		else
			writeln(line)

		if(s == "}}}")
			strip = true
	}
}

function dumpHeader(d)
{
	switch(d.kind)
	{
		case "class":
			write(" '''`class ")
			write(d.name)
			if(d.base)
				write(" : ", d.base)
			writeln("`'''::")
			break

		case "function":
			writef(" '''`{}(", d.name == "constructor" ? "this" : d.name)

			foreach(i, p; d.params)
			{
				if(i > 0)
					write(", ")

				write(p.name)

				if(p.type != "any" && p.type != "vararg")
					write(": ", p.type)

				if(p.value)
					write(" = ", p.value)
			}

			writeln(")`'''::")
			break

		default:
			writeln("<unhandled kind ", d.kind, ">")
	}
}

function dumpItem(d)
{
	dumpHeader(d)

	if(d.dittos)
		foreach(dit; d.dittos)
			dumpHeader(dit)

	switch(d.kind)
	{
		case "class":
			writeln()
			dumpDocs(d.docs, true)
			writeln()

			foreach(child; d.children)
				dumpItem(child)

			break

		case "function":
			dumpDocs(d.docs, true)
			writeln()
			break

		default:
			writeln("<unhandled kind ", d.kind, ">")
	}
}

function dumpStdlib(x)
{
	local d = docsOf(x)

	if(#d == 0)
		throw "WAHHHH"

	writefln("= {} =", d.name)
	writeln()
	dumpDocs(d.docs, false)
	writeln()
	writeln("[[PageOutline(2-9, Table of Contents, inline)]]")
	writeln()

	local curSection = ""

	foreach(child; d.children)
	{
		if(child.section != curSection)
		{
			curSection = child.section
			writefln("== {} ==", curSection)
			writeln()
		}

		dumpItem(child)
	}
}
*/
// dumpStdlib(_G)

/*
I guess it's baselib (but could be moved?)
	stringification
		toString(value, style: char = 'd')
		rawToString(value)
		format(fmt: string, vararg)
	console IO
		write(vararg)
		writeln(vararg)
		writef(vararg)
		writefln(vararg)
		readln()
		dumpVal(value, printNewline: bool = true)
	conversions
		toBool(value)
		toInt(value: bool|int|float|char|string)
		toFloat(value: bool|int|float|char|string)
		toChar(value: int)
	attributes
		attrs(o: function|class|namespace, t: table)
		hasAttributes(value)
		attributesOf(value)
*/

/*
global loaded = {}
global path = "."
global customLoaders = {}
global loaders // filled in at end

function load(name: string)
{
	// Have we already loaded this module?
	local ns = loaded[name]
	if(isNamespace(ns))
		return ns

	return commonLoad(name)
}

function reload(name: string)
{
	// Have we already loaded this module?
	local ns = loaded[name]
	if(ns is null)
		throw "trying to reload a module that hasn't been loaded"

	return commonLoad(name)
}

function commonLoad(name: string)
{
	// Are we circularly importing this module?
	if(loading[name] !is null)
		throw "circular import"
	loading[name] = true
	scope(exit) loading[name] = null

	// Go through all the loaders and try them until one returns something
	foreach(l; loaders)
	{
		local mod = l(name)

		if(isFuncDef(mod) || isFunction(mod))
			return initModule(mod, name) // Run the module initializer
		else if(isNamespace(mod))
		{
			// Stick the namespace into the loaded table
			loaded[name] = mod
			return mod
		}
	}

	// Got through all the loaders without finding anything
	throw "couldn't find anything to load"
}

function initModule(mod: function|funcdef, name: string)
{
	// Hmmm.....
	if(isFunction(mod) && !mod.isNative())
		throw "must be native func"

	// Create the namespace for the module
	local ns = _G

	foreach(piece; name.split("."))
	{
		if(piece in ns)
		{
			if(!isNamespace(ns.(piece)))
				throw "conflicts with existing global"
		}
		else
			ns.(piece) = namespace(name) : ns {} // fake syntax.. parametric name

		ns = ns.(piece)
	}

	// If we're reloading, the namespace has to be cleared
	if(#ns > 0)
		hash.clear(ns)

	// Set up the loader function
	if(isFunction(mod))
		debug.setFuncEnv(mod, ns)
	else
		mod = newFunction(mod, ns) // fake function that really should exist somewhere; creates a function from a funcdef and (optional) namespace

	// Call it and put it in the loaded table
	mod(with ns)
	loaded[name] = ns
	return ns
}

function runMain(mod: namespace, vararg)
{
	if(hasField(mod, "main"))
	{
		local main = mod.main

		if(isFunction(main))
			main(with mod, vararg)
	}
}

function customLoad(name: string)
{
	local l = customLoaders[name]

	if(isFunction(l) || isFuncDef(l) || isNamespace(l))
		return l

	return null
}

function checkTaken(name: string)
{
	local ns = _G

	foreach(piece; name.split("."))
	{
		if(piece !in ns)
			return

		if(!isNamespace(ns.(piece)))
			throw "conflicts with existing global"

		ns = ns.(piece)
	}
}

function loadFiles(name: string)
{
	local pos = name.rfind(".")
	local packages, modName

	if(pos == #name)
	{
		packages = ""
		modName = name
	}
	else
	{
		packages = name[..pos].split(".")
		modName = name[pos + 1..]
	}

	foreach outerLoop(path; paths.split(";"))
	{
		if(!io.exists(path))
			continue

		foreach(piece; packages)
		{
			path = io.join(path, piece)

			if(!io.exists(path))
				continue outerLoop
		}

		local src = io.join(path, modName ~ ".croc")
		local bin = io.join(path, modName ~ ".croco")

		if(io.exists(src))
		{
			if(io.exists(bin))
			{
				if(time.compare(io.modified(src), io.modified(bin)) > 0)
					return compiler.compileModule(io.readFile(src), src)
				else
					return serialization.deserializeModule(bin) // fake function, should exist
			}
			else
				return compiler.compileModule(io.readFile(src), src)
		}
		else if(io.exists(bin))
			return serialization.deserializeModule(bin) // fake function, should exist
	}

	return null
}

loaders = [customLoad, checkTaken, loadFiles]*/