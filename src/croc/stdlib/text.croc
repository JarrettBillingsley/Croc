/** This library contains utilities for performing text encoding, decoding, and specialized output formatting.

Whereas the \tt{string} library concerns itself with simple algorithmic operations on string objects, this module deals
with the more "linguistic" aspects of text handling, such as converting between text encodings and displaying objects in
human-readable forms.

This module exposes flexible interfaces, and the hope is that more text encodings and formatting options will be made
available by second- and third-party libraries.

\b{Codec Error Handling}

The text codecs' encoding and decoding functions all take an optional argument to control the behavior of encoding and
decoding when erroneous input is encountered. There are three error behaviors: \tt{"strict"}, \tt{"ignore"}, and
\tt{"replace"}. The default behavior is \tt{"strict"}.

For encoding, the input text is always well-formed, since Croc strings are always valid sequences of Unicode codepoints.
However, many text encodings only support a subset of all available Unicode codepoints, so the error handling mechanism
is used when an unencodable character is encountered. If the error behavior is \tt{"strict"}, a \tt{UnicodeError} is
thrown. If the error behavior is \tt{"ignore"}, the unencodable character is simply skipped. If the error behavior is
\tt{"replace"}, the unencodable character is skipped, and a codec-defined replacement character is encoded in its place.
Usually this will be a question mark character, but not necessarily.

For decoding, the input data may or may nor be well-formed; thus the error handling mechanism is used when malformed or
invalid input is encountered. If the error behavior is \tt{"strict"}, a \tt{UnicodeError} is thrown. If the error
behavior is \tt{"ignore"}, the invalid input is skipped. If the error behavior is \tt{"replace"}, the invalid input is
skipped, and the Unicode Replacement Character (U+00FFFD) is used in its place.

\b{Built-in Encodings}

This library comes with a few encodings built-in. Here is a table of those encodings, as well as their aliases and what
they are:

\table
	\row
		\cell \b{Name}
		\cell \b{Aliases}
		\cell \b{Description}
	\row
		\cell \tt{"ascii"}
		\cell
		\cell 7-bit ASCII (no characters > 127!).
	\row
		\cell \tt{"latin1"}
		\cell \tt{"latin-1", "iso8859-1", "cp819"}
		\cell An 8-bit encoding that maps exactly to the first 255 Unicode codepoints.
	\row
		\cell \tt{"utf-8"}
		\cell \tt{"utf8"}
		\cell UTF-8!
	\row
		\cell \tt{"utf-8-sig"}
		\cell \tt{"utf8-sig"}
		\cell UTF-8, but on encoding, a signature (0xEF 0xBB 0xBF) is prepended, and on decoding, any signature is
			stripped.
	\row
		\cell \tt{"utf-16"}
		\cell \tt{"utf16"}
		\cell UTF-16. On encoding, always outputs in native byte order with a BOM before the text. On decoding, checks
			for a BOM and can decode little- or big-endian UTF-16.
	\row
		\cell \tt{"utf-16-be"}
		\cell \tt{"utf16-be"}
		\cell Big-endian UTF-16. No BOM is written or read.
	\row
		\cell \tt{"utf-16-le"}
		\cell \tt{"utf16-le"}
		\cell Little-endian UTF-16. No BOM is written or read.
	\row
		\cell \tt{"utf-32"}
		\cell \tt{"utf32"}
		\cell UTF-32. On encoding, always outputs in native byte order with a BOM before the text. On decoding, checks
			for a BOM and can decode little- or big-endian UTF-32.
	\row
		\cell \tt{"utf-32-be"}
		\cell \tt{"utf32-be"}
		\cell Big-endian UTF-32. No BOM is written or read.
	\row
		\cell \tt{"utf-32-le"}
		\cell \tt{"utf32-le"}
		\cell Little-endian UTF-32. No BOM is written or read.
\endtable */
module text

// =====================================================================================================================
// dumpVal

local function outputString(o, v: string)
{
	o.write('"')

	foreach(c; v)
	{
		// TODO: make this faster for common case
		switch(c)
		{
			case '\'': o.write("\\\'"); break
			case '\"': o.write("\\\""); break
			case '\\': o.write("\\\\"); break
			case '\n': o.write("\\n");  break
			case '\r': o.write("\\r");  break
			case '\t': o.write("\\t");  break

			default:
				if(ascii.isAscii(c) and ascii.isPrint(c))
					o.write(c)
				else if(c.ord() <= 0xFFFF)
					o.writef("\\u{:4x}", c.ord())
				else
					o.writef("\\U{:8x}", c.ord())
				break
		}
	}

	o.write('"')
}

// Forward declare
local outputRepr

local function outputTable(o, tab: table, shown: table)
{
	if(tab in shown)
	{
		o.write("{...}")
		return
	}

	shown[tab] = true
	o.write("{")

	if(#tab > 0)
	{
		local first = true

		foreach(k, v; tab)
		{
			if(first)
				first = false
			else
				o.write(", ")


			o.write("[")
			outputRepr(o, k, shown)
			o.write("] = ")
			outputRepr(o, v, shown)
		}
	}

	o.write("}")
	shown[tab] = false
}

local function outputNamespace(o, ns: namespace)
{
	o.write(toString(ns), " { ")

	if(#ns > 0)
	{
		local first = true

		foreach(k, _; ns)
		{
			if(first)
				first = false
			else
				o.write(", ")

			o.write(k)
		}
	}

	o.write(" }")
}

local function outputArray(o, arr: array, shown: table)
{
	if(arr in shown)
	{
		o.write("[...]")
		return
	}

	shown[arr] = true
	o.write("[")

	if(#arr > 0)
	{
		outputRepr(o, arr[0], shown)

		for(i; 1 .. #arr)
		{
			o.write(", ")
			outputRepr(o, arr[i], shown)
		}
	}

	o.write("]")
	shown[arr] = null
}

outputRepr = function(o, val, shown: table)
{
	switch(typeof(val))
	{
		case "weakref":
			o.write("weakref(")
			outputRepr(o, deref(val), shown)
			o.write(")")
			break

		case "string":    outputString(o, val);       break
		case "table":     outputTable(o, val, shown); break
		case "namespace": outputNamespace(o, val);    break
		case "array":     outputArray(o, val, shown); break

		default:
			o.write(toString(val))
	}
}

// This stack mechanism is in case something yields out of its toString metamethod (when that becomes possible...) and
// then dumpVal is called from another thread, or if something calls dumpVal *in* its toString metamethod.
local shownStack = [{} {} {} {}]
local shownStackIdx = 0

/** Dumps an exhaustive string representation of the given value to the console. This is also exported in the global
namespace for convenience.

\blist
	\li \b{\tt{weakrefs}} will be displayed as \tt{"weakref(value)"} where \tt{value} is the exhaustive representation
		of the value the weakref points to.
	\li \b{\tt{strings}} will print non-printable and non-ASCII characters with Croc-like \tt{\\uxxxx} and
		\tt{\\UXXXXXXXX} escape sequences.
	\li \b{\tt{tables} and \tt{arrays}} will be recursed into safely, so you don't need to worry about infinite
		recursion.
	\li \b{\tt{namespaces}} will have the names of their fields printed, but not the values.
	\li \b{All other types} will have \link{toString} called on them.
\endlist

\param[val] is the value to print.
\param[printNewline] controls whether or not a newline will be output after the representation.
\param[output] should be a \link{stream.TextWriter}-like object which implements \tt{write}, \tt{writeln}, and
	\tt{flush} methods. */
function dumpVal(val: any, printNewline: bool = true, output = console.stdout)
{
	assert(shownStackIdx <= #shownStack)

	if(shownStackIdx == #shownStack)
		shownStack.append({})

	local shown = shownStack[shownStackIdx]
	shownStackIdx++

	assert(#shown == 0)
	scope(exit)
	{
		hash.clear(shown)
		shownStackIdx--
	}

	outputRepr(output, val, shown)
	output.flush()

	if(printNewline)
		output.writeln()
}

// Export globally
_G.dumpVal = dumpVal

// =====================================================================================================================
// Unicode gunk

/** \returns the number of bytes needed to encode the first codepoint of the given string in UTF-8, or 0 if the
codepoint is out of the valid range of Unicode. */
function charUtf8Length(c: string)
{
	local i = c.ord()

	if(i < 0x80)
		return 1
	else if(i < 0x800)
		return 2
	else if(i < 0x10000)
		return 3
	else if(i <= 0x10FFFF)
		return 4
	else
		return 0
}

local Utf8StartCharLengths =
[
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
	2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
	3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
	4 4 4 4 4 4 4 4 0 0 0 0 0 0 0 0
];

/** Given the value of an initial UTF-8 code unit, returns how many bytes long this character is, or 0 if this is an
invalid initial code unit.

\throws[exceptions.RangeError] if \tt{firstByte} is not in the range \tt{[0 .. 255]}. */
function utf8SequenceLength(firstByte: int)
{
	if(firstByte < 0 || firstByte > 255)
		throw RangeError("{} is not in the range 0 to 255 inclusive".format(firstByte))

	return Utf8StartCharLengths[firstByte]
}

/** UTF-8 "BOM", not so much a byte-order mark as it is a UTF-8 tag. Sometimes appears at the beginning of UTF-8 encoded
text. */
global BOM_UTF8 = memblock.fromArray([0xEF 0xBB 0xBF])

/** A string representation of the above. */
global BOM_UTF8_STR = "\uFEFF"

/** Little-endian UTF-16 BOM. */
global BOM_UTF16_LE = memblock.fromArray([0xFF 0xFE])

/** Big-endian UTF-16 BOM. */
global BOM_UTF16_BE = memblock.fromArray([0xFE 0xFF])

/** Little-endian UTF-32 BOM. */
global BOM_UTF32_LE = memblock.fromArray([0xFF 0xFE 0x00 0x00])

/** Big-endian UTF-32 BOM. */
global BOM_UTF32_BE = memblock.fromArray([0x00 0x00 0xFE 0xFF])

/** Native and byte-swapped UTF-16 and UTF-32 BOMs. These are just aliases for the above globals, and which is "native"
and which is "byte-swapped" is determined automatically for you. */
global BOM_UTF16, BOM_UTF16_BS

/// ditto
global BOM_UTF32, BOM_UTF32_BS

if(BOM_UTF16_LE.readUInt16(0) == 0xFEFF)
{
	BOM_UTF16 = BOM_UTF16_LE
	BOM_UTF32 = BOM_UTF32_LE
	BOM_UTF16_BS = BOM_UTF16_BE
	BOM_UTF32_BS = BOM_UTF32_BE
}
else
{
	BOM_UTF16 = BOM_UTF16_BE
	BOM_UTF32 = BOM_UTF32_BE
	BOM_UTF16_BS = BOM_UTF16_LE
	BOM_UTF32_BS = BOM_UTF32_LE
}

/** Given a slice of a memblock containing encoded text, detects any BOMs at the beginning of the text, returning which
UTF encoding it believes the text to be in.

If there is no BOM, or if the memblock is too short to contain one, returns \tt{null}.

\param[mb] is the memblock to test.
\param[lo] and
\param[hi] define the slice of \tt{mb} to test.
\returns one of \tt{"utf-8"}, \tt{"utf-16"}, \tt{"utf-32"}, or \tt{null}. This doesn't return \tt{"utf-16-be"} or the
	like, as those codecs do not expect a BOM at the beginning.

\throws[BoundsError] if \tt{lo} or \tt{hi} are invalid. */
function detectBOM(mb: memblock, lo: int = 0, hi: int = #mb)
{
	if(lo < 0 or lo > hi or hi > #mb)
		throw BoundsError("Invalid memblock slice indices {} .. {} (length: {})".format(lo, hi, #mb))

	local length = hi - lo

	if(length >= 2)
	{
		if(BOM_UTF16.compare(0, mb, lo, #BOM_UTF16) == 0 or BOM_UTF16_BS.compare(0, mb, lo, #BOM_UTF16_BS) == 0)
			return "utf-16"

		if(length >= 3)
		{
			if(BOM_UTF8.compare(0, mb, lo, #BOM_UTF8) == 0)
				return "utf-8"

			if(length >= 4)
			{
				if(BOM_UTF32.compare(0, mb, lo, #BOM_UTF32) == 0 or BOM_UTF32_BS.compare(0, mb, lo, #BOM_UTF32_BS) == 0)
					return "utf-32"
			}
		}
	}

	return null
}

// =====================================================================================================================
// Codecs

local textCodecs = {}

/** Register a text codec of the given name. The codec can then be retrieved with \link{getCodec}.

\throws[exceptions.LookupError] if there is already a codec registered named \tt{name}. */
function registerCodec(name: string, codec)
{
	if(name in textCodecs)
		throw LookupError("Already a codec for '{}' registered".format(name))

	textCodecs[name] = codec
}

/** Re-registers an already-registered codec with one or more alternate names.

For instance, if you wanted the codec "foobar" to be accessible also as "foo-bar" or "FOOBAR", you could use:

\code
aliasCodec("foobar", "foo-bar", "FOOBAR")
\endcode

Then \tt{getCodec("foo-bar")} and \tt{getCodec("FOOBAR")} would give the same codec as \tt{getCodec("foobar")}.

\param[name] is the name of the codec to alias. It must have been previously registered with \link{registerCodec}.
\param[vararg] is one or more strings that will be registered as aliases to the given codec.

\throws[exceptions.ParamError] if you don't pass at least one variadic argument.
\throws[exceptions.TypeError] if any of the variadic arguments are not strings. */
function aliasCodec(name: string, vararg)
{
	local c = getCodec(name)

	if(#vararg == 0)
		throw ParamError("Must have at least one variadic argument")

	for(i; 0 .. #vararg)
	{
		local rename = vararg[i]

		if(!isString(rename))
			throw TypeError("All variadic arguments must be strings")

		registerCodec(rename, c)
	}
}

/** Gets the codec object that was registered with the given name.

\throws[exceptions.LookupError] if there was no codec registered with the given name. */
function getCodec(name: string)
{
	if(local ret = textCodecs[name])
		return ret

	throw LookupError("No codec registered for '{}'".format(name))
}

/** Gets an alphabetically sorted array of the names of all available codecs (including aliases). */
function getAllCodecNames() =
	hash.keys(textCodecs).sort()

/** Gets an alphabetically sorted array of arrays. Each sub-array has the name of the codec as the first element and the
codec itself as the second. */
function getAllCodecs() =
	[[k, v] foreach k, v; textCodecs].sort(\a, b -> a[0] <=> b[0])

/** \returns whether or not a codec of the given name has been registered. */
function hasCodec(name: string) =
	name in textCodecs

/** The base class for all text codecs which are registered with this module. This class defines an interface which all
codecs must implement. */
class TextCodec
{
	/** The name of the text encoding that this codec implements. */
	name = ""

	/** Encodes a string object into a string encoding, placing the encoded data into a memblock.

	\param[str] is the string to be encoded.
	\param[dest] is the memblock that will hold the encoded data. The memblock will be resized so that the end of the
		memblock coincides with the end of the encoded data. The beginning of the encoded data is specified by..
	\param[start] ..this parameter. This is the byte offset into \tt{dest} where the first byte of encoded data will be
		placed. This can be equal to \tt{#dest}, which means the encoded data will be appended to the end of \tt{dest}.
	\param[errors] controls the error handling behavior of the encoder; see this module's docs for more info.

	\returns \tt{dest}. */
	function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict")
	{
		throw NotImplementedError()
	}

	/** Same as calling \link{encodeInto} with a new, empty memblock and a starting index of 0. */
	function encode(str: string, errors: string = "strict") =
		:encodeInto(str, memblock.new(0), 0, errors)

	/** Decodes an encoded string from a memblock into a string.

	\param[src] is the memblock that holds the encoded string data.
	\param[lo] and
	\param[hi] are slice indices into \tt{src}; this slice is the data to be decoded.
	\param[errors] controls the error handling behavior of the decoder; see this module's docs for more info.

	\returns the decoded text as a string.

	\throws[exceptions.ValueError] if the given slice of data cannot be consumed in its entirety, such as if there
		is an incomplete character encoding at the end of the data. If you need to be able to decode data piecemeal,
		such as in a stream decoding situation, this is what \link{incrementalDecoder} is for. */
	function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		throw NotImplementedError()
	}

	/** Same as calling \link{decodeRange} with a slice of the entire memblock. */
	function decode(src: memblock, errors: string = "strict") =
		:decodeRange(src, 0, #src, errors)

	/** \returns a new instance of a class derived from \link{IncrementalEncoder} that allows you to encode a stream of
	text incrementally. See that class's docs for more info. */
	function incrementalEncoder(errors: string = "strict")
	{
		throw NotImplementedError()
	}

	/** \returns a new instance of a class derived from \link{IncrementalDecoder} that allows you to decode a stream of
	text incrementally. See that class's docs for more info. */
	function incrementalDecoder(errors: string = "strict")
	{
		throw NotImplementedError()
	}
}

/** The base class for incremental text encoders, which are returned from \link{TextCodec.incrementalEncoder} methods.

An incremental encoder does the same thing as \link{TextCodec.encodeInto} except its operation can be split up over
multiple calls instead of being done all at once. This way large pieces of data can be encoded without having to have
either the source or the output entirely in memory. */
class IncrementalEncoder
{
	/** Instead of specifying the error behavior on each call, incremental encoders have it specified once in the
	constructor. */
	this(errors: string = "strict")
	{
		throw NotImplementedError()
	}

	/** Similar to \link{TextCodec.encodeInto}.

	The \tt{final} parameter tells the function whether or not this is the last piece of string to be encoded. This way
	the encoder can throw an error if there's insufficient input or whatever. Also, if the \tt{final} parameter is true,
	the encoder is expected to be reset to its initial state after this method returns.

	\param[str] same as in \link{TextCodec.encodeInto}.
	\param[dest] same as in \link{TextCodec.encodeInto}.
	\param[start] same as in \link{TextCodec.encodeInto}.
	\param[final] is explained above.

	\returns \tt{dest}. */
	function encodeInto(str: string, dest: memblock, start: int, final: bool = false)
	{
		throw NotImplementedError()
	}

	/** Same as caling \link{encodeInto} with a new, empty memblock and a starting index of 0. */
	function encode(str: string, final: bool = false) =
		:encodeInto(str, memblock.new(0), 0, final)

	/** Resets any internal state to its initial state so that this encoder object can be used to encode a new string.
	This will be called automatically by \link{encodeInto} if its \tt{final} param was \tt{true}. */
	function reset()
	{
		throw NotImplementedError()
	}
}

/** The base class for incremental text decoders, which are returned from \link{TextCodec.incrementalDecoder} methods.

An incremental decoder does the same thing as \link{TextCodec.decodeRange} except its operation can be split up over
multiple calls instead of being done all at once. This way large pieces of data can be decoded without having to have
either the source or the output entirely in memory. */
class IncrementalDecoder
{
	/** Instead of specifying the error behavior on each call, incremental decoders have it specified once in the
	constructor. */
	this(errors: string = "strict")
	{
		throw NotImplementedError()
	}

	/** Similar to \link{TextCodec.decodeRange}.

	The \tt{final} parameter tells the function whether or not this is the last piece of string to be decoded. This way
	the decoder can throw an error if there's insufficient input or whatever. Also, if the \tt{final} parameter is true,
	the decoder is expected to be reset to its initial state after this method returns.

	If the given slice of data ends with an incomplete character encoding, it is the decoder's responsibility to keep
	this data around for the next call to this method. Then it can resume decoding by using the stored data as the
	beginning of the next character.

	\param[src] same as in \link{TextCodec.decodeRange}.
	\param[lo] same as in \link{TextCodec.decodeRange}.
	\param[hi] same as in \link{TextCodec.decodeRange}.
	\param[final] is explained above.

	\returns as much of the data as could be decoded as a string. */
	function decodeRange(src: memblock, lo: int, hi: int, final: bool = false)
	{
		throw NotImplementedError()
	}

	/** Same as calling \link{decodeRange} with a slice of the entire memblock. */
	function decode(src: memblock, final: bool = false) =
		:decodeRange(src, 0, #src, final)

	/** Resets any internal state to its initial state so that this encoder object can be used to encode a new string.
	This will be called automatically by \link{decodeRange} if its \tt{final} param was \tt{true}. */
	function reset()
	{
		throw NotImplementedError()
	}
}

/** A base class for incremental decoders which share a common behavior: needing to save partial character encodings
from the end of a data block for use in the next call.

Subclasses need only implement the \link{_bufferedDecode} method. */
class BufferedIncrementalDecoder : IncrementalDecoder
{
	_errors
	_scratch

	override this(errors: string = "strict")
	{
		:_errors = errors
		:_scratch = memblock.new(0)
	}

	/** Subclasses just implement this method. Note that it takes both an \tt{errors} parameter \em{and} a \tt{final}
	parameter.

	This method should return two values. The first is the decoded string (or the empty string if there was not enough
	data to decode anything). The second is the number of bytes of the given slice that were consumed during decoding.

	When this method is given a memblock slice, it's possible that there is incomplete encoded data at the end of the
	slice. For instance, in a multibyte character encoding scheme (like UTF-8), there might only be the first byte of a
	four-byte character at the end of the slice. Suppose the slice is 16 bytes long. In this case, this method would
	return the decoded version of the first 15 bytes, then the number 15 (to indicate that only 15 of 16 bytes were
	decoded).

	With this information, this class can save that 1 byte into an internal buffer, and then on the next call to
	\link{decodeRange}, it will concatenate that byte to the front of the new input slice, and call this method with
	the concatenated data.

	If all the bytes were decoded from the given slice, then this method should return \tt{hi - lo} as the number of
	bytes consumed.

	\returns two values: the decoded string (or an empty string if nothing was decoded) and the number of bytes consumed
		from the given slice of the memblock. */
	function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false)
	{
		throw NotImplementedError()
	}

	/// Implementation of the \link{IncrementalDecoder.decodeRange} method.
	override function decodeRange(src: memblock, lo: int, hi: int, final: bool = false)
	{
		if(#:_scratch > 0)
		{
			local m = memblock.new(#:_scratch + (hi - lo))
			m.copy(0, :_scratch, 0, #:_scratch)
			m.copy(#:_scratch, src, lo, hi - lo)
			src = m
			lo = 0
			hi = #src
		}

		local ret, eaten = :_bufferedDecode(src, lo, hi, :_errors, final)
		local sliceLen = hi - lo

		if(eaten < sliceLen)
		{
			if(final)
				throw ValueError("Incomplete text at end of data")

			#:_scratch = sliceLen - eaten
			:_scratch.copy(0, src, lo + eaten, #:_scratch)
		}
		else
			#:_scratch = 0

		return ret
	}

	override function reset()
	{
		#:_scratch = 0
	}
}

// =====================================================================================================================
// Ascii

local asciiEncodeInternal, asciiDecodeInternal = _texttmp.asciiEncodeInternal, _texttmp.asciiDecodeInternal

local class AsciiIncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		asciiEncodeInternal(str, dest, start, :_errors)

	override function reset() {}
}

local class AsciiIncrementalDecoder : IncrementalDecoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function decodeRange(src: memblock, lo: int, hi: int, final: bool = false) =
		asciiDecodeInternal(src, lo, hi, :_errors)

	override function reset() {}
}

class AsciiCodec : TextCodec
{
	override name = "ascii"

	override function incrementalEncoder(errors: string = "strict") =
		AsciiIncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		AsciiIncrementalDecoder(errors)
}

object.addMethodOverride(AsciiCodec, "encodeInto", asciiEncodeInternal)
object.addMethodOverride(AsciiCodec, "decodeRange", asciiDecodeInternal)

registerCodec("ascii", AsciiCodec())

// =====================================================================================================================
// Latin-1

local latin1EncodeInternal, latin1DecodeInternal = _texttmp.latin1EncodeInternal, _texttmp.latin1DecodeInternal

local class Latin1IncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		latin1EncodeInternal(str, dest, start, :_errors)

	override function reset() {}
}

local class Latin1IncrementalDecoder : IncrementalDecoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function decodeRange(src: memblock, lo: int, hi: int, final: bool = false) =
		latin1DecodeInternal(src, lo, hi, :_errors)

	override function reset() {}
}

class Latin1Codec : TextCodec
{
	override name = "latin1"

	override function incrementalEncoder(errors: string = "strict") =
		Latin1IncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Latin1IncrementalDecoder(errors)
}

object.addMethodOverride(Latin1Codec, "encodeInto", latin1EncodeInternal)
object.addMethodOverride(Latin1Codec, "decodeRange", latin1DecodeInternal)

registerCodec("latin1", Latin1Codec())
aliasCodec("latin1", "latin-1", "iso8859-1", "cp819")

// =====================================================================================================================
// "Raw" UTF-8

local utf8EncodeInternal, utf8DecodeInternal = _texttmp.utf8EncodeInternal, _texttmp.utf8DecodeInternal

local class Utf8IncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		utf8EncodeInternal(str, dest, start, :_errors)

	override function reset() {}
}

local class Utf8IncrementalDecoder : BufferedIncrementalDecoder
{
	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false) =
		utf8DecodeInternal(src, lo, hi, errors)
}

class Utf8Codec : TextCodec
{
	override name = "utf-8"

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		local ret, eaten = utf8DecodeInternal(src, lo, hi, errors)

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf8IncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf8IncrementalDecoder(errors)
}

object.addMethodOverride(Utf8Codec, "encodeInto", utf8EncodeInternal)

registerCodec("utf-8", Utf8Codec())
aliasCodec("utf-8", "utf8")

// =====================================================================================================================
// UTF-8 with a signature

local class Utf8SigIncrementalEncoder : IncrementalEncoder
{
	_errors
	_first = true

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false)
	{
		if(!:_first)
			return utf8EncodeInternal(str, dest, start, :_errors)
		else
		{
			:_first = false
			return utf8EncodeInternal(BOM_UTF8_STR ~ str, dest, start, :_errors)
		}
	}

	override function reset()
	{
		:_first = true
	}
}

local class Utf8SigIncrementalDecoder : BufferedIncrementalDecoder
{
	_first = true

	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false)
	{
		local prefix = 0

		if(:_first)
		{
			local sliceLen = hi - lo

			if(sliceLen < 3)
			{
				if(BOM_UTF8.compare(0, src, lo, sliceLen) == 0)
					return "", 0
				else
					:_first = false
			}
			else
			{
				:_first = false

				if(BOM_UTF8.compare(0, src, lo, 3) == 0)
				{
					lo += 3
					prefix = 3
				}
			}
		}

		local ret, eaten = utf8DecodeInternal(src, lo, hi, errors)
		return ret, prefix + eaten
	}

	override function reset()
	{
		(BufferedIncrementalDecoder.reset)(with this)
		:_first = true
	}
}

class Utf8SigCodec : TextCodec
{
	override name = "utf-8-sig"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict") =
		utf8EncodeInternal(BOM_UTF8_STR ~ str, dest, start, errors)

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		if((hi - lo) >= 3 && BOM_UTF8.compare(0, src, lo, 3) == 0)
			lo += 3

		local ret, eaten = utf8DecodeInternal(src, lo, hi, errors)

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf8SigIncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf8SigIncrementalDecoder(errors)
}

registerCodec("utf-8-sig", Utf8SigCodec())
aliasCodec("utf-8-sig", "utf8-sig")

// =====================================================================================================================
// UTF-16 (BOM + native on encoding, BOM + either on decoding)

local utf16EncodeInternal, utf16DecodeInternal = _texttmp.utf16EncodeInternal, _texttmp.utf16DecodeInternal

local class Utf16IncrementalEncoder : IncrementalEncoder
{
	_errors
	_first = true

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false)
	{
		if(!:_first)
			return utf16EncodeInternal(str, dest, start, :_errors)
		else
		{
			:_first = false

			if(start + #BOM_UTF16 > #dest)
				#dest = start + #BOM_UTF16

			dest.copy(start, BOM_UTF16, 0, #BOM_UTF16)
			return utf16EncodeInternal(str, dest, start + #BOM_UTF16, :_errors)
		}
	}

	override function reset()
	{
		:_first = true
	}
}

local class Utf16IncrementalDecoder : BufferedIncrementalDecoder
{
	_first = true
	_order = 'n'

	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false)
	{
		local prefix = 0

		if(:_first)
		{
			if(hi - lo < #BOM_UTF16)
				return "", 0

			:_first = false

			if(BOM_UTF16.compare(0, src, lo, #BOM_UTF16) == 0)
			{
				lo += #BOM_UTF16
				prefix = #BOM_UTF16
			}
			else if(BOM_UTF16_BS.compare(0, src, lo, #BOM_UTF16_BS) == 0)
			{
				lo += #BOM_UTF16_BS
				prefix = #BOM_UTF16_BS
				:_order = 's'
			}
			else
				throw UnicodeError("UTF-16 encoded text has no BOM")
		}

		local ret, eaten = utf16DecodeInternal(src, lo, hi, errors, :_order)
		return ret, prefix + eaten
	}

	override function reset()
	{
		(BufferedIncrementalDecoder.reset)(with this)
		:_first = true
		:_order = 'n'
	}
}

class Utf16Codec : TextCodec
{
	override name = "utf-16"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict")
	{
		if(start + #BOM_UTF16 > #dest)
			#dest = start + #BOM_UTF16

		dest.copy(start, BOM_UTF16, 0, #BOM_UTF16)
		return utf16EncodeInternal(str, dest, start + #BOM_UTF16, errors)
	}

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		if(hi - lo < #BOM_UTF16)
			throw UnicodeError("UTF-16 encoded text is too short to have a BOM")

		local ret, eaten

		if(BOM_UTF16.compare(0, src, lo, #BOM_UTF16) == 0)
			ret, eaten = utf16DecodeInternal(src, lo + #BOM_UTF16, hi, errors)
		else if(BOM_UTF16_BS.compare(0, src, lo, #BOM_UTF16_BS) == 0)
			ret, eaten = utf16DecodeInternal(src, lo + #BOM_UTF16_BS, hi, errors, 's')
		else
			throw UnicodeError("UTF-16 encoded text has no BOM")

		eaten += #BOM_UTF16

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf16IncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf16IncrementalDecoder(errors)
}

registerCodec("utf-16", Utf16Codec())
aliasCodec("utf-16", "utf16")

// =====================================================================================================================
// UTF-16 Little Endian (no BOM on either encoding or decoding)

local class Utf16LEIncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		utf16EncodeInternal(str, dest, start, :_errors, 'l')

	override function reset() {}
}

local class Utf16LEIncrementalDecoder : BufferedIncrementalDecoder
{
	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false) =
		utf16DecodeInternal(src, lo, hi, errors, 'l')
}

class Utf16LECodec : TextCodec
{
	override name = "utf-16-le"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict") =
		utf16EncodeInternal(str, dest, start, errors, 'l')

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		local ret, eaten = utf16DecodeInternal(src, lo, hi, errors, 'l')

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf16LEIncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf16LEIncrementalDecoder(errors)
}

registerCodec("utf-16-le", Utf16LECodec())
aliasCodec("utf-16-le", "utf16le")

// =====================================================================================================================
// UTF-16 Big Endian (no BOM on either encoding or decoding)

local class Utf16BEIncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		utf16EncodeInternal(str, dest, start, :_errors, 'b')

	override function reset() {}
}

local class Utf16BEIncrementalDecoder : BufferedIncrementalDecoder
{
	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false) =
		utf16DecodeInternal(src, lo, hi, errors, 'b')
}

class Utf16BECodec : TextCodec
{
	override name = "utf-16-be"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict") =
		utf16EncodeInternal(str, dest, start, errors, 'b')

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		local ret, eaten = utf16DecodeInternal(src, lo, hi, errors, 'b')

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf16BEIncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf16BEIncrementalDecoder(errors)
}

registerCodec("utf-16-be", Utf16BECodec())
aliasCodec("utf-16-be", "utf16be")

// =====================================================================================================================
// UTF-32 (BOM + native on encoding, BOM + either on decoding)

local utf32EncodeInternal, utf32DecodeInternal = _texttmp.utf32EncodeInternal, _texttmp.utf32DecodeInternal

local class Utf32IncrementalEncoder : IncrementalEncoder
{
	_errors
	_first = true

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false)
	{
		if(!:_first)
			return utf32EncodeInternal(str, dest, start, :_errors)
		else
		{
			:_first = false

			if(start + #BOM_UTF32 > #dest)
				#dest = start + #BOM_UTF32

			dest.copy(start, BOM_UTF32, 0, #BOM_UTF32)
			return utf32EncodeInternal(str, dest, start + #BOM_UTF32, :_errors)
		}
	}

	override function reset()
	{
		:_first = true
	}
}

local class Utf32IncrementalDecoder : BufferedIncrementalDecoder
{
	_first = true
	_order = 'n'

	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false)
	{
		local prefix = 0

		if(:_first)
		{
			if(hi - lo < #BOM_UTF32)
				return "", 0

			:_first = false

			if(BOM_UTF32.compare(0, src, lo, #BOM_UTF32) == 0)
			{
				lo += #BOM_UTF32
				prefix = #BOM_UTF32
			}
			else if(BOM_UTF32_BS.compare(0, src, lo, #BOM_UTF32_BS) == 0)
			{
				lo += #BOM_UTF32_BS
				prefix = #BOM_UTF32_BS
				:_order = 's'
			}
			else
				throw UnicodeError("UTF-32 encoded text has no BOM")
		}

		local ret, eaten = utf32DecodeInternal(src, lo, hi, errors, :_order)
		return ret, prefix + eaten
	}

	override function reset()
	{
		(BufferedIncrementalDecoder.reset)(with this)
		:_first = true
		:_order = 'n'
	}
}

class Utf32Codec : TextCodec
{
	override name = "utf-32"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict")
	{
		if(start + #BOM_UTF32 > #dest)
			#dest = start + #BOM_UTF32

		dest.copy(start, BOM_UTF32, 0, #BOM_UTF32)
		return utf32EncodeInternal(str, dest, start + #BOM_UTF32, errors)
	}

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		if(hi - lo < #BOM_UTF32)
			throw UnicodeError("UTF-32 encoded text is too short to have a BOM")

		local ret, eaten

		if(BOM_UTF32.compare(0, src, lo, #BOM_UTF32) == 0)
			ret, eaten = utf32DecodeInternal(src, lo + #BOM_UTF32, hi, errors)
		else if(BOM_UTF32_BS.compare(0, src, lo, #BOM_UTF32_BS) == 0)
			ret, eaten = utf32DecodeInternal(src, lo + #BOM_UTF32_BS, hi, errors, 's')
		else
			throw UnicodeError("UTF-32 encoded text has no BOM")

		eaten += #BOM_UTF32

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf32IncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf32IncrementalDecoder(errors)
}

registerCodec("utf-32", Utf32Codec())
aliasCodec("utf-32", "utf32")

// =====================================================================================================================
// UTF-32 Little Endian (no BOM on either encoding or decoding)

local class Utf32LEIncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		utf32EncodeInternal(str, dest, start, :_errors, 'l')

	override function reset() {}
}

local class Utf32LEIncrementalDecoder : BufferedIncrementalDecoder
{
	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false) =
		utf32DecodeInternal(src, lo, hi, errors, 'l')
}

class Utf32LECodec : TextCodec
{
	override name = "utf-32-le"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict") =
		utf32EncodeInternal(str, dest, start, errors, 'l')

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		local ret, eaten = utf32DecodeInternal(src, lo, hi, errors, 'l')

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf32LEIncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf32LEIncrementalDecoder(errors)
}

registerCodec("utf-32-le", Utf32LECodec())
aliasCodec("utf-32-le", "utf32le")

// =====================================================================================================================
// UTF-32 Big Endian (no BOM on either encoding or decoding)

local class Utf32BEIncrementalEncoder : IncrementalEncoder
{
	_errors

	override this(errors: string = "strict")
	{
		:_errors = errors
	}

	override function encodeInto(str: string, dest: memblock, start: int, final: bool = false) =
		utf32EncodeInternal(str, dest, start, :_errors, 'b')

	override function reset() {}
}

local class Utf32BEIncrementalDecoder : BufferedIncrementalDecoder
{
	override function _bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false) =
		utf32DecodeInternal(src, lo, hi, errors, 'b')
}

class Utf32BECodec : TextCodec
{
	override name = "utf-32-be"

	override function encodeInto(str: string, dest: memblock, start: int, errors: string = "strict") =
		utf32EncodeInternal(str, dest, start, errors, 'b')

	override function decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")
	{
		local ret, eaten = utf32DecodeInternal(src, lo, hi, errors, 'b')

		if(eaten < (hi - lo))
			throw ValueError("Incomplete text at end of data")

		return ret
	}

	override function incrementalEncoder(errors: string = "strict") =
		Utf32BEIncrementalEncoder(errors)

	override function incrementalDecoder(errors: string = "strict") =
		Utf32BEIncrementalDecoder(errors)
}

registerCodec("utf-32-be", Utf32BECodec())
aliasCodec("utf-32-be", "utf32be")