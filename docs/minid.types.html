<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>minid.types</title>
	</head><body>
	<h1>minid.types</h1>
	<!-- Generated by Ddoc from minid/types.d -->
The main header file of the MiniD interpreter.  This file defines all the basic <u>types</u>
of MiniD, as well as the MDState type, which is the interpreter (and doubles as the
'thread' type for coroutines).
<br><br>
<b>License:</b><br>
Copyright (c) 2007 Jarrett Billingsley
<br><br>

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
<br><br>

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:
<br><br>

    1. The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software in a
	product, an acknowledgment in the product documentation would be
	appreciated but is not required.
<br><br>

    2. Altered source versions must be plainly marked as such, and must not
	be misrepresented as being the original software.
<br><br>

    3. This notice may not be removed or altered from any source distribution.
<br><br>

<dl><dt><big>class <u>MDException</u>: Exception;
</big></dt>
<dd>The root of the MiniD exception hierarchy.
<br><br>
All exceptions in MiniD derive from this class.  In order to be compatible with the scripting language,
where values of any type can be thrown as exceptions, it has a public member which exposes this value.
<br><br>

<dl><dt><big>MDValue <u>value</u>;
</big></dt>
<dd>The MiniD <u>value</u> which is used if the exception is caught by a catch statement in MiniD code.
	
<br><br>

</dd>
<dt><big>this(char[] fmt,...);
</big></dt>
<dd>Construct an MDException using a format string and a list of arguments, using Tango-style formatting.
	The string will be formatted, and assigned into the value member as well.
	
<br><br>

</dd>
<dt><big>this(char[] fmt, TypeInfo[] arguments, va_list argptr);
</big></dt>
<dd>Like above, but for when you already have the two variadic parameters from another variadic function.
	
<br><br>

</dd>
<dt><big>this(MDValue val);
</big></dt>
<dd>Construct an MDException from an MDValue.  It will be assigned to the value member, and the string
	representation of it (not calling toString metamethods) will be used as the exception message.
	
<br><br>

</dd>
<dt><big>this(MDValue* val);
</big></dt>
<dd>Like above, but for MDValue pointers instead.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDCompileException</u>: MDException;
</big></dt>
<dd>Thrown by the compiler whenever there's a compilation error.
<br><br>
The message will be in the form "filename(line:colunm): error message".
<br><br>

<dl><dt><big>bool <u>atEOF</u>;
</big></dt>
<dd>Indicates whether the compiler threw this at the end of the file or not.  If this is
	<b>true</b>, this might be because the compiler ran out of input, in which case the code could
	be made to compile by adding more code.
	
<br><br>

</dd>
<dt><big>this(Location loc, char[] fmt,...);
</big></dt>
<dd>Takes the location of the error, and a variadic list of Tango-style formatted arguments.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDRuntimeException</u>: MDException;
</big></dt>
<dd>Thrown to indicate an error at run-time, often by the interpreter but not always.
<br><br>
This class includes a location of where the exception was thrown.
<br><br>

<dl><dt><big>Location <u>location</u>;
</big></dt>
<dd>The <u>location</u> of where the exception was thrown.  This may not be entirely accurate,
	depending on whether or not debug information was compiled into the bytecode, who
	threw the exception etc.
	
<br><br>

</dd>
<dt><big>this(Location loc, MDValue* val);
</big></dt>
<dd>Constructs the exception from a location and an MDValue pointer to the value to be thrown.
	
<br><br>

</dd>
<dt><big>this(Location loc, char[] fmt,...);
</big></dt>
<dd>Constructs the exception from a location and Tango-style formatted arguments.
	
<br><br>

</dd>
<dt><big>this(Location loc, char[] fmt, TypeInfo[] arguments, va_list argptr);
</big></dt>
<dd>Like above, but takes the variadic function parameters instead.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Overridden to include the location in the error message.  Note that the result of this
	is in the format "filename(line:instruction): error message".  The 'instruction' in this
	message is the index of the instruction in the bytecode that caused the exception, and
	is mostly meant for low-level debugging.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>MDValue</u>;
</big></dt>
<dd>The basic variant data type which represents a MiniD value.
<br><br>
This structure is the underlying representation of every variable, array slot, table key/value
etc. that appears in the language.  It is a variant type which can hold any of the language types.
It's a simple tagged union, with a 4-byte type and an 8-byte data segment (large enough to hold
a double-precision floating-point value, the largest type that it can hold).
<br><br>

<dl><dt><big>enum <u>Type</u>;
</big></dt>
<dd>Enumerates the basic datatypes of MiniD.  See the 'Types' section of the spec for more info.
	
<br><br>

<dl></dl>
</dd>
<dt><big>MDValue <u>nullValue</u>;
</big></dt>
<dd>A static MDValue instance which should always, always hold '<b>null</b>'.  There is an invariant
	which ensures this.  This is mostly used by functions which need to return a pointer to a
	<b>null</b> MDValue, rather than returning an actual <b>null</b> pointer.  You can also use this any time
	you need a <b>null</b> MDValue in your D code.
	
<br><br>

</dd>
<dt><big>template <u>opCall</u>(T)</big></dt>
<dd>The "constructor" for the struct.  It's templated based on the parameter, and all it does is
	call opAssign, so see opAssign for more info.
	
<br><br>

<dl></dl>
</dd>
<dt><big>int <u>opEquals</u>(MDValue* <i>other</i>);
</big></dt>
<dd>Returns <b>true</b> if this and the <i>other</i> value are exactly the same type and the same value.  The semantics
	of this are exactly the same as the 'is' expression in MiniD.
	
<br><br>

</dd>
<dt><big>int <u>opCmp</u>(MDValue* <i>other</i>);
</big></dt>
<dd>This is mostly overridden for using MDValues as AA keys.  You probably shouldn't use this for
	comparing MDValues in general, because (1) it will return 'less' or 'greater' for values which are
	different types, which doesn't really make sense, and (2) will not call <u>opCmp</u> metamethods.
	
<br><br>

</dd>
<dt><big>int <u>compare</u>(MDValue* <i>other</i>);
</big></dt>
<dd>Compares this to another MDValue in a more sensible way.  If the two objects are different types, and are not
	both numeric types (int or float), an exception will be thrown.  Integers will automatically be cast to floats
	when comparing an int and a float.  This function still does not call opCmp metamethods, however; you should use
	the APIs in the MDState class for the best comparison.
	
<br><br>

</dd>
<dt><big>hash_t <u>toHash</u>();
</big></dt>
<dd>Overridden to allow the use of MDValues as AA keys.
	
<br><br>

</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Gets the <u>length</u> of the MDValue, which will fail (throw an exception) if getting the <u>length</u>
	makes no sense for the MDValue's type.  Does not call opLength metamethods.
	
<br><br>

</dd>
<dt><big>Type <u>type</u>();
</big></dt>
<dd>Returns the current <u>type</u> of this value, as a value from the MDValue.Type enumeration.
	
<br><br>

</dd>
<dt><big>dchar[] <u>typeString</u>(Type <i>type</i>);
</big></dt>
<dd>A static method which, given a value from the MDValue.Type enumeration, will give the
	string representation of that <i>type</i>.
	
<br><br>

</dd>
<dt><big>dchar[] <u>typeString</u>();
</big></dt>
<dd>Gets a string representation of the type of this value.  Differs from passing the type
	into the static <u>typeString</u>() function in that it will include the name of the class if
	this is a class or instance value.
	
<br><br>

</dd>
<dt><big>bool <u>isNull</u>();
<br>bool <u>isBool</u>();
<br>bool <u>isNum</u>();
<br>bool <u>isInt</u>();
<br>bool <u>isFloat</u>();
<br>bool <u>isChar</u>();
<br>bool <u>isObj</u>();
<br>bool <u>isString</u>();
<br>bool <u>isTable</u>();
<br>bool <u>isArray</u>();
<br>bool <u>isFunction</u>();
<br>bool <u>isClass</u>();
<br>bool <u>isInstance</u>();
<br>bool <u>isNamespace</u>();
<br>bool <u>isThread</u>();
</big></dt>
<dd>These return <b>true</b> if this is the given type, and <b>false</b> otherwise.
	
<br><br>

</dd>
<dt><big>bool <u>isFalse</u>();
</big></dt>
<dd>Returns <b>true</b> if this value is <b>false</b> (<b>null</b>, '<b>false</b>', an integer with the value 0, a float
	with the value 0.0, or a NUL ('\0') character).
	
<br><br>

</dd>
<dt><big>bool <u>isTrue</u>();
</big></dt>
<dd>Returns the opposite of isFalse().
	
<br><br>

</dd>
<dt><big>template <u>canCastTo</u>(T)</big></dt>
<dd>A templated method which checks if this value can be converted to the given D type.  Array
	and AA types will check the entire contents of the Array or Table (if the value is one) to make
	sure all the elements can be cast as well, so this can be a non-trivial operation for the container
	types.  .<u>canCastTo</u>!(floating point type)() will return <b>true</b> if the value is either a float or an int.
	If the value is an instance, it will check that it can be downcast to the given class instance type.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>as</u>(T)</big></dt>
<dd>A templated method which converts this value to the given D type.  This is kind of a power-user
	method, used for converting a MiniD value to a D value <u>as</u> long <u>as</u> you know in advance that this
	conversion can be done.  If the conversion can't be done, an assertion will be thrown in debug
	builds, but the behavior is undefined in release builds.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>to</u>(T)</big></dt>
<dd>A 'safer' version of .as(), this will do basically the same thing, but will throw an exception on
	a failed conversion.
	
<br><br>

<dl></dl>
</dd>
<dt><big>void <u>setNull</u>();
</big></dt>
<dd>Sets this value to <b>null</b>.  You can also set a value to <b>null</b> by assigning it the D '<b>null</b>' value.
	
<br><br>

</dd>
<dt><big>template <u>opAssign</u>(T)</big></dt>
<dd>A templated <u>opAssign</u> which allows the assignment of many D types into an MDValue.  All reasonable
	assignments are valid.  Assignment of an array or AA to an MDValue will convert it into a MiniD
	array or table.  You can assign '<b>null</b>' into an MDValue as well.  An invalid type will trigger
	a compile-time error.
	
<br><br>

<dl></dl>
</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Returns the string representation of the value.  Does not call toString metamethods.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDObject</u>;
</big></dt>
<dd>The base class for all the object (reference) types in MiniD.
<br><br>

<dl><dt><big>int <u>compare</u>(MDObject <i>o1</i>, MDObject <i>o2</i>);
</big></dt>
<dd>Given two MDObject references, compares them.  Doesn't call opCmp metamethods, and
	throws an exception if the two objects are of different types.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDString</u>: MDObject;
</big></dt>
<dd>The class that represents the MiniD 'string' type.
<br><br>
This holds an immutable string.  The hash for this string is calculated once upon creation,
improving speed when used as the key to an AA (which, in MiniD, is very often -- all namespaces
use MDStrings as keys).  Immutability also avoids the problem of using a string as an AA key
and then changing it, which would result in undefined behavior.
<br><br>

<dl><dt><big>this(dchar[] data);
<br>this(wchar[] data);
<br>this(char[] data);
</big></dt>
<dd>These construct an MDString from the given D string.  The data is duplicated, so you don't
	have to worry about changing the source data after the MDString has been created.
	
<br><br>

</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Gets the <u>length</u> of the string in characters (codepoints?  code units?  it's all so confusing).
	
<br><br>

</dd>
<dt><big>int <u>opIn_r</u>(dchar <i>c</i>);
</big></dt>
<dd>If the given character is in the string, returns the index of its first occurrence; otherwise
	returns -1.
	
<br><br>

</dd>
<dt><big>MDString <u>opCat</u>(MDString <i>other</i>);
</big></dt>
<dd>Concatenates two MDStrings, resulting in a new MDString.
	
<br><br>

</dd>
<dt><big>MDString <u>opCat</u>(dchar <i>c</i>);
<br>MDString <u>opCat_r</u>(dchar <i>c</i>);
</big></dt>
<dd>Concatenates an MDString with a single character, resulting in a new MDString.
	
<br><br>

</dd>
<dt><big>hash_t <u>toHash</u>();
</big></dt>
<dd>Returns the hash of the string (which was computed at construction).
	
<br><br>

</dd>
<dt><big>int <u>opEquals</u>(Object <i>o</i>);
</big></dt>
<dd>Returns <b>true</b> if this and another string are identical; <b>false</b> otherwise.
	Checks to see if the hashes diff first, which can save a lot of time.
	
<br><br>

</dd>
<dt><big>int <u>opEquals</u>(char[] <i>v</i>);
<br>int <u>opEquals</u>(wchar[] <i>v</i>);
<br>int <u>opEquals</u>(dchar[] <i>v</i>);
</big></dt>
<dd>Returns <b>true</b> if this MDString's data is identical to the given D string; <b>false</b> otherwise.
	
<br><br>

</dd>
<dt><big>int <u>opCmp</u>(Object <i>o</i>);
</big></dt>
<dd>Compares this string to another MDString by character values (i.e. it doesn't do a full lexicographical
	language-correct comparison).
	
<br><br>

</dd>
<dt><big>int <u>opCmp</u>(char[] <i>v</i>);
<br>int <u>opCmp</u>(wchar[] <i>v</i>);
<br>int <u>opCmp</u>(dchar[] <i>v</i>);
</big></dt>
<dd>Same as above, but for D string arguments.
	
<br><br>

</dd>
<dt><big>dchar <u>opIndex</u>(uint <i>index</i>);
</big></dt>
<dd>Gets the character at the given <i>index</i>.
	
<br><br>

</dd>
<dt><big>MDString <u>opSlice</u>(uint <i>lo</i>, uint <i>hi</i>);
</big></dt>
<dd>Slices this string, returning a new MDString.  Thanks to immutability, the
	new string's data will simply point into the old string's, meaning the only memory
	allocation is for the new string's instance.
	
<br><br>

</dd>
<dt><big>char[] <u>asUTF8</u>();
<br>wchar[] <u>asUTF16</u>();
<br>dchar[] <u>asUTF32</u>();
</big></dt>
<dd>These convert this string into the given UTF encoding.  The returned value will never
	reference the data inside the instance, to preserve immutability.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Returns the UTF-8 string representation of the string; basically just returns .asUTF8().
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDClosure</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'function' type.
<br><br>
This is a closure, that is a function and all the environment it needs to execute correctly.
It can hold either a MiniD closure (a "script closure"), or a reference to a native D function
(a "native closure").  In virtually all cases this distinction is transparent, except when it
comes to coroutines.  You cannot yield out of a coroutine across the boundary of a native function
call.
<br><br>

In addition to their executable function, closures also have what's called the "environment."
In the global lookup process (in script functions, that is), the first step is to check if the
global exists in the 'this' parameter.  If it doesn't, the next step goes to the closure's
environment.  This is a namespace which usually is the module in which the function was defined.
Global lookup begins at the environment, and travels up the chain of namespaces (since each
namespace can have a parent namespace) until the chain is exhausted.  The environment is important
for global lookup in script closures, but it's usually not that important in native closures.
Furthermore, if a function is called as a non-method (a plain function call), and is not given
an explicit context with the 'with' keyword, its environment will be passed as the 'this' parameter.
<br><br>

<dl><dt><big>this(MDNamespace environment, MDFuncDef def);
</big></dt>
<dd>Constructs a script closure.
<br><br>
<b>Params:</b><br>
<table><tr><td>environment</td>
<td>The environment of the closure.  See the description of this class for info.</td></tr>
<tr><td>def</td>
<td>The MDFuncDef, which was either loaded from a file or just compiled, which holds the
			bytecode representation of the closure.</td></tr>
</table><br>

</dd>
<dt><big>this(MDNamespace environment, int delegate(MDState, uint) dg, dchar[] name, MDValue[] upvals = null);
<br>this(MDNamespace environment, int(* func)(MDState, uint), dchar[] name, MDValue[] upvals = null);
</big></dt>
<dd>Constructs a native closure.  Both function pointers and delegates are allowed; using delegates will be
	slightly faster when the closure is called.
<br><br>
All native functions which interact with the API follow the same signature.  They take two Params:
	an MDValue which represents the thread from which this closure was called, and the number of parameters
	(not including the context 'this' parameter, which is always present) with which the function was called.
	The MDState parameter contains all the parameters which were passed to the function, as well as being a
	very important interface through which much of the native API is used.  Native functions return an integer,
	which is how many values they are returning (which were pushed onto the MDState's stack prior to returning).

<br><br>
<b>Params:</b><br>
<table><tr><td>environment</td>
<td>The environment of the closure.  See the description of this class for info.</td></tr>
<tr><td>dg</td>
<td>(or func) The delegate or function pointer of the native function.</td></tr>
<tr><td>name</td>
<td>The name of the function, which will be used in error messages and when its toString is called.</td></tr>
<tr><td>upvals</td>
<td>An optional array of MDValues which serve as the upvalues to the closure.  In MiniD, upvalues
			are automatic, and are simply local variables declared in enclosing functions.  In native code,
			you can achieve similar results by either creating an instance of a struct on the heap and using
			one of its methods as the delegate for the closure, and keep the closure's upvalues in there; or
			by passing an array of MDValues to this constructor.  The array of upvalues will be available
			through the MDState parameter to the native function.</td></tr>
</table><br>

</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Getting the <u>length</u> of a closure makes no sense; this just throws an exception.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Gets a string representation of the closure.  For native closures, it looks something like "native function name";
	for script closures, "script function name(location defined)".
	
<br><br>

</dd>
<dt><big>bool <u>isNative</u>();
</big></dt>
<dd>Returns whether or not this is a native closure.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>environment</u>();
<br>void <u>environment</u>(MDNamespace <i>env</i>);
</big></dt>
<dd>Gets or sets the <u>environment</u> of the closure.  See the class description for info.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDTable</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'table' type.
<br><br>
This is basically an AA which is indexed by and holds MDValues.  Null MDValues cannot be
used as indices.  Assigning a <b>null</b> value to a key-value pair removes that pair from the
table, and accessing a key which doesn't exist will return a <b>null</b> value.
<br><br>

<dl><dt><big>this();
</big></dt>
<dd>Creates a new table.
<br><br>

</dd>
<dt><big>template <u>create</u>(T...)</big></dt>
<dd>Create a table from a templated list of variadic arguments.  There must be an even
	number of arguments.  Each pair of arguments is interpreted as a key-value pair, and
	the types of these must be convertible to MiniD types.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>fromAA</u>(K,V)</big></dt>
<dd>Create a table from an associative array.  The key and value types must be convertible
	to MiniD types.
	
<br><br>

<dl></dl>
</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Gets the number of key-value pairs in the table.
	
<br><br>

</dd>
<dt><big>MDTable <u>dup</u>();
</big></dt>
<dd>Creates a shallow copy of the table.  The keys and values in the new table will be the same;
	they are not recursively duplicated.
	
<br><br>

</dd>
<dt><big>MDArray <u>keys</u>();
</big></dt>
<dd>Gets an MDArray of all the <u>keys</u> of the table.
	
<br><br>

</dd>
<dt><big>MDArray <u>values</u>();
</big></dt>
<dd>Gets an MDArray of all the <u>values</u> of the table.
	
<br><br>

</dd>
<dt><big>void <u>remove</u>(ref MDValue <i>index</i>);
</big></dt>
<dd>Removes a key-value pair from the table with the given key.  If the key doesn't exist, this
	simply returns.  You can also <u>remove</u> a pair by assigning a <b>null</b> value to it.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIn_r</u>(ref MDValue <i>index</i>);
</big></dt>
<dd>Returns a pointer to the value given the key.  Returns a <b>null</b> pointer if the key doesn't exist.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIndex</u>(ref MDValue <i>index</i>);
</big></dt>
<dd>Returns a pointer to the value given the key.  Throws an exception if the key is a <b>null</b> MDValue.
	Never returns a <b>null</b> MDValue*; if the key doesn't exist, returns a pointer to a <b>null</b> MDValue instead.
	
<br><br>

</dd>
<dt><big>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, ref MDValue <i>index</i>);
</big></dt>
<dd>Assigns a <i>value</i> to a key-<i>value</i> pair.  Throws an exception if the key is a <b>null</b> MDValue.  Removes
	the pair, if it exists, if the <i>value</i> is a <b>null</b> MDValue.
	
<br><br>

</dd>
<dt><big>int <u>opApply</u>(int delegate(ref MDValue key, ref MDValue value) <i>dg</i>);
</big></dt>
<dd>Overloaded <u>opApply</u> so you can use a foreach loop on an MDTable.  They key and value are both
	MDValues.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Returns a string representation of the table, in the format "table 0x00000000", where the number
	is the hexidecimal representation of the 'this' pointer.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDArray</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'array' type.
<br><br>
This is a very simple and straightforward class.  It's basically a mutable, resizable array of MDValues.
<br><br>

<dl><dt><big>this(uint size);
</big></dt>
<dd>Construct this array with a given size.  All the elements will be the <b>null</b> MDValue.
	
<br><br>

</dd>
<dt><big>template <u>create</u>(T...)</big></dt>
<dd>Create an MDArray from a templated list of variadic arguments.  All the arguments must have types
	which are convertible to MiniD types.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>fromArray</u>(T)</big></dt>
<dd>Create an MDArray from a D array.  The element type must be convertible to a MiniD type.  Multi-dimensional
	arrays work as well.
	
<br><br>

<dl></dl>
</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Gets the number of elements in the array.
	
<br><br>

</dd>
<dt><big>uint <u>length</u>(int <i>newLength</i>);
</big></dt>
<dd>Sets the <u>length</u> of the array.  If the new <u>length</u> is longer than the old, the new elements will
	be filled in with the <b>null</b> MDValue.
	
<br><br>

</dd>
<dt><big>void <u>sort</u>();
</big></dt>
<dd>Sorts the array.  All the elements must be the same type for this to succeed; throws an exception on failure.
	
<br><br>

</dd>
<dt><big>void <u>sort</u>(bool delegate(MDValue, MDValue) <i>predicate</i>);
</big></dt>
<dd>Sorts the array, using a custom <i>predicate</i>.  This <i>predicate</i> takes two values and should return '<b>true</b>'
	if the first is less than the second, and '<b>false</b>' otherwise.
	
<br><br>

</dd>
<dt><big>void <u>reverse</u>();
</big></dt>
<dd>Reverses the order of the array.
	
<br><br>

</dd>
<dt><big>MDArray <u>dup</u>();
</big></dt>
<dd>Performs a shallow copy of the array.
	
<br><br>

</dd>
<dt><big>int <u>opCmp</u>(Object <i>o</i>);
</big></dt>
<dd>Compares this array to another array.  Comparison works just like on D arrays.  As long as the
	length and data are identical, the arrays will compare equal.  If all the elements of both arrays
	are the same type, you can even compare for ordering; smaller arrays and arrays with smaller elements
	will compare less than larger arrays.  If the elements are different types, comparing for ordering
	doesn't make much sense, but equality still works.
	
<br><br>

</dd>
<dt><big>int <u>opEquals</u>(Object <i>o</i>);
</big></dt>
<dd>Sees if this array is identical to another array.
	
<br><br>

</dd>
<dt><big>int <u>opIn_r</u>(ref MDValue <i>v</i>);
</big></dt>
<dd>If the given value is in the array, returns the index of the first instance; otherwise, returns -1.
	
<br><br>

</dd>
<dt><big>int <u>opApply</u>(int delegate(ref MDValue value) <i>dg</i>);
<br>int <u>opApply</u>(int delegate(ref uint index, ref MDValue value) <i>dg</i>);
</big></dt>
<dd><u>opApply</u> overloads to allow using foreach on an MDArray.  Both index-value and value-only forms are
	available.  The value type is an MDValue.
	
<br><br>

</dd>
<dt><big>MDArray <u>opCat</u>(MDArray <i>other</i>);
</big></dt>
<dd>Concatenates two arrays into a new array.  The data is always copied from
	the source arrays.
	
<br><br>

</dd>
<dt><big>MDArray <u>opCat</u>(ref MDValue <i>elem</i>);
<br>MDArray <u>opCat_r</u>(ref MDValue <i>elem</i>);
</big></dt>
<dd>Concatenates an array with a single element.  Always copies from the source array.
	
<br><br>

</dd>
<dt><big>MDArray <u>opCatAssign</u>(MDArray <i>other</i>);
</big></dt>
<dd>Appends another array onto the end of this one.  No new array is created; this array is
	just resized.
	
<br><br>

</dd>
<dt><big>MDArray <u>opCatAssign</u>(ref MDValue <i>elem</i>);
</big></dt>
<dd>Appends a single element to the end of this array.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIndex</u>(int <i>index</i>);
</big></dt>
<dd>Gets a pointer to the value stored at the given <i>index</i>.  Returns a pointer instead of a plain
	MDValue so that the array data can be updated after the fact.
	
<br><br>

</dd>
<dt><big>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, uint <i>index</i>);
</big></dt>
<dd>Assigns a <i>value</i> into the given <i>index</i>.
	
<br><br>

</dd>
<dt><big>MDArray <u>opSlice</u>(uint <i>lo</i>, uint <i>hi</i>);
</big></dt>
<dd>Creates a new array which is a slice into this array's data.  Modifying the contents of the
	sliced array will modify the contents of this array (unless this array is resized, in which
	case it may not).
	
<br><br>

</dd>
<dt><big>void <u>opSliceAssign</u>(ref MDValue <i>value</i>, uint <i>lo</i>, uint <i>hi</i>);
</big></dt>
<dd>Assigns a single <i>value</i> to a range of indices.
	
<br><br>

</dd>
<dt><big>void <u>opSliceAssign</u>(MDArray <i>arr</i>, uint <i>lo</i>, uint <i>hi</i>);
</big></dt>
<dd>Copies the data from another MDArray into this one.  The length of the other array must be the
	same as the length of the slice indicated by the indices.
	
<br><br>

</dd>
<dt><big>void <u>opSliceAssign</u>(ref MDValue <i>value</i>);
</big></dt>
<dd>Assigns a single <i>value</i> to every element of this array.
	
<br><br>

</dd>
<dt><big>void <u>opSliceAssign</u>(MDArray <i>arr</i>);
</big></dt>
<dd>Copies the data from another array into this one.  Both arrays must have the same length.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Returns a string representation of the array, in the format "array 0x00000000", where the number
	is the hexidecimal representation of the 'this' pointer.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDClass</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'class' type.
<br><br>
Classes hold two namespaces: one for fields and one for methods.  The method namespace is shared among
all instances of the class, while the field namespace is duplicated for each instance.  Classes can
inherit from other classes.
<br><br>

When assigning members to the class, they will automatically be put into the proper namespace based on their
type -- closures go into the method namespace, all others into the fields namespace.  You can also get
references to each of these namespaces.
<br><br>

<dl><dt><big>this(dchar[] guessedName, MDClass baseClass = null);
</big></dt>
<dd>Creates a new class.
<br><br>
<b>Params:</b><br>
<table><tr><td>guessedName</td>
<td>The name of the class.  This is called "guessed" mostly because in MiniD code, classes
			do not have any intrinsic name associated with them, and sometimes the compiler will generate a
			name for an anonymous class.  For any classes that you create from native code, though, you'll
			probably given them a real name.</td></tr>
<tr><td>baseClass</td>
<td>An optional base class from which this one should derive.  If you skip this parameter or
			pass <b>null</b>, the class will have no base class.  Otherwise, it will copy the fields and methods
			from the base class into its own namespaces, which you can then overwrite (override) with your
			own versions.</td></tr>
</table><br>

</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Throws an exception since classes do not have a <u>length</u>.
	
<br><br>

</dd>
<dt><big>MDValue <u>superClass</u>();
</big></dt>
<dd>Returns an MDValue containing the base class.  Returns a <b>null</b> MDValue if it has no base class.
	
<br><br>

</dd>
<dt><big>MDInstance <u>newInstance</u>();
</big></dt>
<dd>Creates a new instance of this class; this doesn't, however, run the constructor, so the instance
	may be incompletely initialized.  The fields are copied from the class into the new instance; the
	instance's method namespace simply points to this class's method namespace.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIndex</u>(MDString <i>index</i>);
<br>MDValue* <u>opIndex</u>(dchar[] <i>index</i>);
</big></dt>
<dd>Look up a member of the class.  This will look in the methods, the fields, and then continue the
	search in the base class if there is any.  Returns a <b>null</b> pointer (not a pointer to a <b>null</b> MDValue)
	if the member wasn't found.
	
<br><br>

</dd>
<dt><big>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, MDString <i>index</i>);
<br>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, dchar[] <i>index</i>);
</big></dt>
<dd>Sets a member of a class.  If the <i>value</i> is a function, it'll be put into the methods namespace;
	otherwise, it'll be put into the fields namespace.
	
<br><br>

</dd>
<dt><big>dchar[] <u>getName</u>();
</big></dt>
<dd>Returns the guessed name (a duplicate of the internal name, so it can't be corrupted).
	
<br><br>

</dd>
<dt><big>MDNamespace <u>fields</u>();
</big></dt>
<dd>Returns the namespace that contains the <u>fields</u> for this class.  Manually adding members to the returned
	namespace is not recommended, as this bypasses some caching logic that MDClass performs with a normal
	member add.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>methods</u>();
</big></dt>
<dd>Returns the namespace that contains the <u>methods</u> for this class.  Manually adding members to the returned
	namespace is not recommended, as this bypasses some caching logic that MDClass performs with a normal
	member add.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Returns a string representation of the class in the form "class name".
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDInstance</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'instance' type.
<br><br>
Instances are a bit different from other types in that they also have a class type from which they were
instantiated.  This class defines the methods which can be called on its instances, as well as the
fields which they given when they are created.  You can query the runtime type of an instance, as well
as see if a given class is anywhere in its inheritance hierarchy (or if it is an instance of that class
itself).
<br><br>

Instances must be created through a class; you cannot instantiate an instance on its own.
<br><br>

<dl><dt><big>uint <u>length</u>();
</big></dt>
<dd>Getting the <u>length</u> of an instance <i>could</i> make sense, if the instance had an opLength method.
	However, none of these class methods call (or can call) metamethods, so this just throws an
	exception.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIndex</u>(MDString <i>index</i>);
<br>MDValue* <u>opIndex</u>(dchar[] <i>index</i>);
</big></dt>
<dd>Looks up a member in the instance.  If the member doesn't exist, returns a <b>null</b> pointer.
	
<br><br>

</dd>
<dt><big>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, MDString <i>index</i>);
<br>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, dchar[] <i>index</i>);
</big></dt>
<dd>Sets a member in an instance.  You cannot reassign instance methods; attempting to do so will
	result in an exception being thrown.  You also can't add fields to the class instance which
	it didn't have to begin with (also throws an error).
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Gets a string representation of the instance, in the form "instance of class classname".  Does
	not call toString metamethods.
	
<br><br>

</dd>
<dt><big>bool <u>castToClass</u>(MDClass <i>cls</i>);
</big></dt>
<dd>Given a reference to a class, sees if this instance can be cast to the given class.
<br><br>
<b>Returns:</b><br>
'this' if it can be cast; <b>null</b> otherwise.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>fields</u>();
</big></dt>
<dd>Get a reference to the field namespace of this instance.  Every instance has its own field namespace.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>methods</u>();
</big></dt>
<dd>Get a reference to the method namespace of this instance.  All instances of a class and the class itself
	share the method namespace.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDNamespace</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'namespace' type.
<br><br>
Namespaces are kind of like tables, but have somewhat different semantics.  They are a mapping from strings to
values; only string keys are allowed.  Namespaces may hold <b>null</b> values, so assigning a <b>null</b> value to a key-value
pair does not remove that pair from the namespace.  Accessing a key-value pair which has not yet been inserted
will throw an exception instead of returning <b>null</b> as tables do.  Namespaces can have a name.  Lastly namespaces
can also have a parent namespace, which is used in global lookup.
<br><br>

Namespaces are used as symbol tables throughout MiniD.  Modules, packages, class fields, and class methods are all
held in namespaces.  They are also used as function closure environments.  When global lookup reaches the closure's
environment, it looks up the global in that namespace; if it's not found, it goes to that namespace's parent
namespace, all the way up the chain of namespaces until either the global is found or the namespace chain ends.
<br><br>

<dl><dt><big>this(dchar[] name = null, MDNamespace parent = null);
</big></dt>
<dd>Construct a new namespace.
<br><br>
<b>Params:</b><br>
<table><tr><td>name</td>
<td>The optional name of the namespace.  It can be <b>null</b>, in which case the namespace will be anonymous.
			class method and field namespaces are anonymous, for example.</td></tr>
<tr><td>parent</td>
<td>The optional parent of the namespace.  The parent is used for global lookup (see the description
			of this class).  If the namespace won't be being used as the environment for a function, the parent
			is mostly purposeless, except for debugging, when the parent's name will be included in the namespace's
			name.  The parent can be <b>null</b>, which means global lookup will terminate after searching this namespace.</td></tr>
</table><br>

</dd>
<dt><big>template <u>create</u>(T...)</big></dt>
<dd>Create a namespace from a variadic list of arguments.  This is similar to the MDTable.<u>create</u>() function,
	in that there must be an even number of arguments, and each pair is interpreted as a key-value pair.
	This has the additional requirement that the keys must all be strings.  The name and parent parameters
	are the same as in the constructor.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>addList</u>(T...)</big></dt>
<dd>Similar to create(), but just adds a list of key-value pairs to an already-created namespace.
	
<br><br>

<dl></dl>
</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>Gets the number of key-value pairs in the namespace.
	
<br><br>

</dd>
<dt><big>dchar[] <u>name</u>();
</big></dt>
<dd>Gets the <u>name</u> of the namespace (not including the parent's <u>name</u>).
	
<br><br>

</dd>
<dt><big>MDNamespace <u>parent</u>();
</big></dt>
<dd>Gets the <u>parent</u> of this namespace.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIn_r</u>(MDString <i>key</i>);
<br>MDValue* <u>opIn_r</u>(dchar[] <i>key</i>);
</big></dt>
<dd>Looks up a value in the namespace from a string <i>key</i>.  As usual for D's 'in', returns <b>null</b> if
	the value isn't found, and a pointer to the value if it is.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>dup</u>();
</big></dt>
<dd>Duplicate this namespace, performing a shallow copy of all the key-value pairs.
	
<br><br>

</dd>
<dt><big>MDArray <u>keys</u>();
</big></dt>
<dd>Gets an MDArray of all the <u>keys</u> in the namespace.
	
<br><br>

</dd>
<dt><big>MDArray <u>values</u>();
</big></dt>
<dd>Gets an MDArray of all the <u>values</u> in the namespace.
	
<br><br>

</dd>
<dt><big>MDValue* <u>opIndex</u>(MDString <i>key</i>);
<br>MDValue* <u>opIndex</u>(dchar[] <i>key</i>);
</big></dt>
<dd>Looks up a value from the namespace.  Returns a <b>null</b> pointer if the <i>key</i> doesn't exist.
	
<br><br>

</dd>
<dt><big>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, MDString <i>key</i>);
<br>void <u>opIndexAssign</u>(ref MDValue <i>value</i>, dchar[] <i>key</i>);
</big></dt>
<dd>Assigns a <i>value</i> to a <i>key</i> n the namespace.  Will insert the pair if the <i>key</i> doesn't exist
	already.  Assigning a <b>null</b> <i>value</i> to a <i>key</i>-<i>value</i> pair will <i>not</i> remove the pair from
	the namespace as it does with tables.
	
<br><br>

</dd>
<dt><big>void <u>remove</u>(MDString <i>key</i>);
<br>void <u>remove</u>(dchar[] <i>key</i>);
</big></dt>
<dd>Remove the given <i>key</i> from the namespace.  Throws an exception if they <i>key</i> does not exist.
	
<br><br>

</dd>
<dt><big>int <u>opApply</u>(int delegate(ref MDString, ref MDValue) <i>dg</i>);
</big></dt>
<dd>Overload of <u>opApply</u> to allow using foreach over a namespace.  The keys are MDStrings, and
	the values are MDValues.
	
<br><br>

</dd>
<dt><big>dchar[] <u>nameString</u>();
</big></dt>
<dd>Gets a more complete name of the namespace, including the name of all parent namespaces.
	So if namespace 'b's parent is namespace 'a', this will return a string like "a.b".
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Gets a string representation of the namespace in the form "namespace full.name".
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Location</u>;
</big></dt>
<dd>A struct that holds a location (a filename, a line number, and a column number) of
a piece of code.  Used by the compiler and in runtime debug locations.
<br><br>

<dl><dt><big>Location <u>opCall</u>(dchar[] <i>fileName</i>, int <i>line</i> = 1, int <i>column</i> = 1);
</big></dt>
<dd>Create a location with the given filename, <i>line</i>, and <i>column</i>.  Lines and columns start
	at 1.  A <i>line</i>, <i>column</i> pair of -1, -1 has the special meaning of "in a native function."
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Gets a string representation of the location.  If the line and column are both -1, the
	string is formatted like "fileName(native)", meaning that the location came from a native
	function (i.e. a native function may have thrown an exception).  Otherwise, it's in
	the form "fileName(line:column)".  For runtime debug locations, 'column' is actually
	replaced by the index of the bytecode instruction.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDModuleDef</u>;
</big></dt>
<dd>A definition of a MiniD module.
<br><br>
This is really just a name and the code for the top-level function of the module.  This can
be serialized and deserialized using the minid.utils serialization protocol.  This can also
be loaded by the MDContext class, but that's a very low-level API.
<br><br>

<dl><dt><big>dchar[] <u>name</u>();
</big></dt>
<dd>Gets the <u>name</u> of the module.  This is the <u>name</u> given in the module declaration.
	
<br><br>

</dd>
<dt><big>void <u>serialize</u>(IWriter <i>s</i>);
</big></dt>
<dd>Serialize this module to some kind of output.  To be used with the minid.utils serialization
	protocol.
	
<br><br>

</dd>
<dt><big>MDModuleDef <u>deserialize</u>(IReader <i>s</i>);
</big></dt>
<dd>Deserialize this module from some kind of input.  To be used with the minid.utils serialization
	protocol.
	
<br><br>

</dd>
<dt><big>MDModuleDef <u>loadFromFile</u>(char[] <i>filename</i>);
</big></dt>
<dd>Load a module definition from a <i>filename</i>.  This is a low-level API that you probably won't have
	to deal with.
	
<br><br>

</dd>
<dt><big>void <u>writeToFile</u>(char[] <i>filename</i>);
</big></dt>
<dd>Save this module to a <i>filename</i>.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDFuncDef</u>;
</big></dt>
<dd>A class which holds a script function's byte code, as well as all (most) of the information needed to
instantiate a closure of it, and some debug info as well.
<br><br>
You probably won't need to worry about using this class that much.
<br><br>

<dl></dl>
</dd>
<dt><big>class <u>MDContext</u>;
</big></dt>
<dd>A class which represents an execution context for MiniD code.  It holds a global namespace hierarchy into
which modules can be imported, as well as a set of type metatables.  Also provides a state which can be
used to run code.
<br><br>
You can create multiple, independent MiniD execution contexts.  These are not the same as states.  A state
is simply a thread of execution, and there can be multiple states associated with a single context.
When you create a context, a default state (its "main thread") is created for you.  This thread can spawn
other threads with the creation of coroutines.
<br><br>

A context is useful for creating a "sandbox."  What you can do is create a context, and only load into it
libraries which you know are safe.  Then you can execute untrusted code in this sandbox, and it won't have
access to potentially dangerous functionality.  Then you can have a separate context for executing trusted
code.
<br><br>

You can instantiate this class directly, and then load the standard libraries into it manually, but there
is minid.minid.NewContext, a helper function which will load standard libraries into the context based on
a flags parameter, which is a bit more compact.
<br><br>

<dl><dt><big>struct <u>_Globals</u>;
</big></dt>
<dd>This struct isn't meant to be used as a type in its own right; it's just a helper for accessing globals.
	
<br><br>

<dl><dt><big>template <u>opIndex</u>(T = MDValue*)<br>alias <u>get</u>;
</big></dt>
<dd>Attempts to get a global of the given name from the global namespace.  Throws an exception if the
		global does not exist.  This is a templated function and returns an MDValue* by default.  If you
		want to get another type, you can use the 'get' alias to this function and call it as a templated
		method.
		
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>opIndexAssign</u>(T)</big></dt>
<dd>Set a global in the global namespace.
		
<br><br>

<dl></dl>
</dd>
<dt><big>MDNamespace <u>ns</u>();
</big></dt>
<dd>Get the underlying MDNamespace which actually holds the globals.
		
<br><br>

</dd>
</dl>
</dd>
<dt><big>_Globals <u>globals</u>;
</big></dt>
<dd>An instance of the above struct.  You can access globals by writing things like "context.globals["x"d] = 5".
	
<br><br>

</dd>
<dt><big>MDNamespace <u>getMetatable</u>(MDValue.Type <i>type</i>);
<br>void <u>setMetatable</u>(MDValue.Type <i>type</i>, MDNamespace <i>table</i>);
</big></dt>
<dd>Gets or sets the metatable for the given <i>type</i>.  Every <i>type</i> has a metatable associated with it where metamethods
	are looked up after any normal method indexing mechanisms fail.  For example, the 'string' standard library sets
	itself as the metatable for the 'string' <i>type</i>, making it possible to call the library functions as if they were
	methods of the string objects themselves.
	
<br><br>

</dd>
<dt><big>MDState <u>mainThread</u>();
</big></dt>
<dd>Gets the main thread of execution.  This thread is created when the context is created,
	and is the default thread of execution.
	
<br><br>

</dd>
<dt><big>MDClosure <u>newClosure</u>(MDFuncDef <i>def</i>);
</big></dt>
<dd>Create a new closure in the global namespace from the given script function definition.
	
<br><br>

</dd>
<dt><big>MDClosure <u>newClosure</u>(int delegate(MDState, uint) <i>dg</i>, dchar[] <i>name</i>, MDValue[] <i>upvals</i> = null);
<br>MDClosure <u>newClosure</u>(int(* <i>func</i>)(MDState, uint), dchar[] <i>name</i>, MDValue[] <i>upvals</i> = null);
</big></dt>
<dd>Create a new closure in the global namespace from the given native closure information.  See
	MDClosure.this() for info on these parameters.
	
<br><br>

</dd>
<dt><big>void <u>addImportPath</u>(char[] <i>path</i>);
</big></dt>
<dd>Add a <i>path</i> to be searched when performing an import.  See importModule() for information on the
	import mechanism.
	
<br><br>

</dd>
<dt><big>void <u>setModuleLoader</u>(dchar[] <i>name</i>, MDClosure <i>loader</i>);
</big></dt>
<dd>Sets a module <i>loader</i> for a given module <i>name</i>.  The <i>name</i> should be in the format of a module declaration
	<i>name</i>, such as "fork.knife.spoon".
<br><br>
The closure takes two Params: the <i>name</i> of the module to load (so that multiple modules can be loaded
	by the same function), and a namespace in which to place the loaded module symbols.  It is not expected to
	return anything.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>importModule</u>(dchar[] <i>name</i>, MDState <i>s</i> = null);
</big></dt>
<dd>Import a given module.  The process goes something like this.
<br><br>
1. See if the module has been loaded.  Module names are case sensitive.  If the module <i>name</i> is found
		in the internal list of loaded modules, the process stops here.
<br><br>

	2. If the module hasn't been loaded, see if a loader was registered for it with setModuleLoader().  If one
		has been, the loader is called with the module <i>name</i> and the namespace in which to place the module'<i>s</i>
		symbols.  The process ends here if this succeeds.
<br><br>

	3. If there'<i>s</i> no registered loader, it attempts to load the module from disk, from either a source file or
		a compiled binary module file.  This is where the search paths come in.  The first path it attempts is
		the current working directory.  If the module'<i>s</i> <i>name</i> is multipartite, the parts before the final part
		become directory names.  So for example, the <i>name</i> is "fork.knife.spoon", it will look in "fork/knife/"
		for both "spoon.md" and "spoon.mdm".  If both a source and a binary file are found, it will load the
		one with the more recent modification time.  After the current directory is tried, it will go through
		the list of custom directories (in no particular order) attempting the same process.
<br><br>

	4. <b>Not implemented in this release.</b> If no source or binary module could be found, the last attempt is
		to try to load a dynamic library with the same <i>name</i> as the module (with a similar pattern as with the
		source/binary search; "fork.knife.spoon" will look in fork/knife for the module named "spoon").
<br><br>

	If all these steps fail, the import process fails.

<br><br>
<b>Params:</b><br>
<table><tr><td>dchar[] <i>name</i></td>
<td>The <i>name</i> of the module to load, in the format "fork.knife.spoon".</td></tr>
<tr><td>MDState <i>s</i></td>
<td>The state to use to load the module.  This is used when calling any custom module loader functions,
			or if the module being loaded is a script module, in which case the top-level function will be called.
			Defaults to <b>null</b>, in which case the main thread will be used.</td></tr>
</table><br>
<b>Returns:</b><br>
The namespace which holds the module'<i>s</i> symbols.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>initializeModule</u>(MDState <i>s</i>, MDModuleDef <i>def</i>, MDValue[] <i>params</i>);
</big></dt>
<dd>Initialize a module given the module'<i>s</i> definition and a list of parameters which will be
	passed as vararg parameters to the top-level function.  This is a very low-level API.
<br><br>
<b>Params:</b><br>
<table><tr><td>MDState <i>s</i></td>
<td>The state to use to call the top-level module function.</td></tr>
<tr><td>MDModuleDef <i>def</i></td>
<td>The module definition, which was compiled from source or loaded from a file.</td></tr>
<tr><td>MDValue[] <i>params</i></td>
<td>An array of parameters which will be passed as varargs to the top-level function.</td></tr>
</table><br>
<b>Returns:</b><br>
The namespace of the module.
	
<br><br>

</dd>
<dt><big>char[] <u>getTracebackString</u>();
</big></dt>
<dd>Gets traceback info of the most recently-thrown exception, and clears the traceback
	info.  This method is here because exceptions can propagate through multiple states
	and through coroutine calls.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MDState</u>: MDObject;
</big></dt>
<dd>The class which represents the MiniD 'thread' type.  Also probably the singularly most important class
in the native API, this is passed as a "context" to all native functions and contains the script interpreter.
Also keeps track of the script call call stack and locals stack.
<br><br>

<dl><dt><big>enum <u>State</u>;
</big></dt>
<dd>An enumeration of all the valid states a thread can be in, for coroutine support.
	
<br><br>

<dl><dt><big><u>Initial</u></big></dt>
<dd>Means the coroutine has been instantiated, but not yet called with the initial parameters.
		When called, the context parameter that is passed will be saved, and the coroutine's function
		will begin execution.
		
<br><br>

</dd>
<dt><big><u>Waiting</u></big></dt>
<dd>Means that the coroutine resumed another coroutine and is waiting for it to yield or return.
		
<br><br>

</dd>
<dt><big><u>Running</u></big></dt>
<dd>Means that the coroutine is currently executing.  You can only get this state if a coroutine
		queries its own state.
		
<br><br>

</dd>
<dt><big><u>Suspended</u></big></dt>
<dd>Means that the coroutine executed a yield expression, and is waiting to be resumed.
		
<br><br>

</dd>
<dt><big><u>Dead</u></big></dt>
<dd>Means that the coroutine was exited, either by returning or by having an exception propagate
		out of the coroutine.  The coroutine can be reset to the initial state and restarted.
		
<br><br>

</dd>
</dl>
</dd>
<dt><big>this(MDContext context);
</big></dt>
<dd>Construct a new thread.  A default thread of execution, the 'main thread', is created for
	you by MDContext, so you'll really only need this for creating coroutines.
<br><br>
If you pass a script function closure to this constructor, this thread will be a coroutine.  It
	can then be subsequently resumed by calling it with another MDState (just like how you call
	threads to resume them in MiniD).
<br><br>

	Attempting to pass a native function closure will throw an exception.
<br><br>

	Passing <b>null</b> as the closure (the default) will simply create a new state with no special
	properties.  Not all that useful.
	
<br><br>

</dd>
<dt><big>uint <u>length</u>();
</big></dt>
<dd>You can't get the <u>length</u> of a state.  Throws an exception.
	
<br><br>

</dd>
<dt><big>char[] <u>toUtf8</u>();
</big></dt>
<dd>Returns a string representation of the thread, in the form "thread 0x00000000", where the number
	is the hexadecimal representation of the 'this' pointer.
	
<br><br>

</dd>
<dt><big>State <u>state</u>();
</big></dt>
<dd>Gets the current coroutine <u>state</u> of the <u>state</u> as a member of the State enumeration.
	
<br><br>

</dd>
<dt><big>MDString <u>stateString</u>();
</big></dt>
<dd>Gets a string representation of the current state of the coroutine.
	
<br><br>

</dd>
<dt><big>uint <u>pushNull</u>();
</big></dt>
<dd>Push a <b>null</b> value onto the value stack.
<br><br>
<b>Returns:</b><br>
The stack index of the just-pushed value.
	
<br><br>

</dd>
<dt><big>template <u>push</u>(T)</big></dt>
<dd>Push a value onto the value stack.  This is a templated method which can accept any type which can be
	converted to a MiniD type.
<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to <u>push</u>.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the just-pushed value.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>pop</u>(T = MDValue)</big></dt>
<dd>Pop a value off the value stack.  This is templated so that you can <u>pop</u> any type that can be converted from
	a MiniD type, but it defaults to MDValue.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>easyCall</u>(F,T...)</big></dt>
<dd>Call any callable MiniD type with a simple interface.  There are multiple callable types in MiniD.  Functions are the
	most obvious.  You can also call threads, which will resume them.  You can call classes to create instances of them.
	And you can call any object which has an opCall metamethod.
<br><br>
Once the call completes, you must pop any return values off the stack.

<br><br>
<b>Params:</b><br>
<table><tr><td>func</td>
<td>Any callable type.  This is templated to allow any type.</td></tr>
<tr><td>numReturns</td>
<td>How many return values you want from this function call.  If &gt;= 0, will leave exactly that many values
			on the value stack which you can then pop.  If this is -1, indicates that you want as many return values that
			the call gives back, in which case you can get how many it returned by getting the return value of this method.</td></tr>
<tr><td>context</td>
<td>All calls require a context which will be passed as the 'this' parameter to the function.  Only significant
			for functions.  Classes, threads, and objects with opCall will overwrite the context with their own value, so
			it's alright to pass <b>null</b> as the context for those.</td></tr>
<tr><td>params</td>
<td>A variadic list of parameters to be passed to the function.  All values must be convertible to MiniD types.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of return values from this call.  If the numReturns parameter was &gt;= 0, this is the same as that parameter,
		and isn't particularly useful.  But if the numReturns parameter was -1, this is very useful, as it indicates how many
		values the call gave back.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>callMethod</u>(T...)<br>template <u>callMethod</u>(T...)</big></dt>
<dd>Very similar to the easyCall method, this will call a method of any object.
<br><br>
<b>Params:</b><br>
<table><tr><td>val</td>
<td>The object whose method you would like to call.</td></tr>
<tr><td>methodName</td>
<td>The name of the method to call.</td></tr>
<tr><td>numReturns</td>
<td>See easyCall for a description of this parameter.</td></tr>
<tr><td>params</td>
<td>See easyCall for a description of this parameter.</td></tr>
</table><br>
<b>Returns:</b><br>
See easyCall for a description of the return value.
	
<br><br>

<dl></dl>
</dd>
<dt><big>uint <u>call</u>(uint <i>slot</i>, int <i>numParams</i>, int <i>numReturns</i>);
</big></dt>
<dd>Perform a slightly lower-level <u>call</u> to any callable type.
<br><br>
This interface makes slightly less code bloat than the easyCall, as it doesn't require the use of a
	variadic templated function.  The protocol for calling something is as follows:
<br><br>

<pre class="d_code">	<font color=green>// 1. Push the object you're calling onto the stack, and save its stack index.
</font>	<font color=blue>auto</font> funcIdx = s.push(something);

	<font color=green>// 2. Push the context.  You must always have a context.
</font>	s.push(someContext);

	<font color=green>// 3. Push any parameters.
</font>	s.push(param1);
	s.push(param2);

	<font color=green>// 4. Make the call.
</font>	s.<u>call</u>(funcIdx, 3, 1);

	<font color=green>// 5. Pop any return values.
</font>	<font color=blue>auto</font> ret = s.pop!(<font color=blue>int</font>);
</pre>

<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>slot</i></td>
<td>The stack <i>slot</i> of the object to <u>call</u>.  Usually you get this from a push.</td></tr>
<tr><td>int <i>numParams</i></td>
<td>How many parameters, including the context, you are passing to the function.
			Since you always need context, this must always be at least 1.</td></tr>
<tr><td>int <i>numReturns</i></td>
<td>See easyCall for an explanation of this parameter.</td></tr>
</table><br>
<b>Returns:</b><br>
See easyCall for an explanation of this return value.
	
<br><br>

</dd>
<dt><big>template <u>setUpvalue</u>(T)</big></dt>
<dd>This is to be used from native closures which were created with a list of upvalues.  Sets the
	value of the upvalue at the given integer index (upvalues are like an array).
<br><br>
<b>Params:</b><br>
<table><tr><td>index</td>
<td>The index of the upvalue to set.</td></tr>
<tr><td>value</td>
<td>The value, which must have a type convertible to a MiniD type, to be set to the upvalue.</td></tr>
</table><br>

<dl></dl>
</dd>
<dt><big>template <u>getUpvalue</u>(T = MDValue*)</big></dt>
<dd>The opposite of setUpvalue.  This is templated to return any type, and by default will return an
	MDValue*.  You can then modify the contents of this return value and the changes will be reflected
	in the internal upvalue array.
<br><br>
<b>Params:</b><br>
<table><tr><td>index</td>
<td>The index of the upvalue to get.</td></tr>
</table><br>
<b>Returns:</b><br>
The value of the upvalue, templated to return whatever you'd like it to.  Defaults to MDValue*.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>isParam</u>(char[] type)</big></dt>
<dd>A quirky function which lets you check if the parameter at the given index is of a certain type.
	This is a templated method which takes a string that indicates the type you'd like to check for.
	Possible values are "<b>null</b>", "bool", "int", "float", "char", "string", "table", "array", "function",
	"class", "instance", "namespace", and "thread".  Any other value will give a compile-time error.
<br><br>
<b>Params:</b><br>
<table><tr><td>index</td>
<td>The 0-based index of the parameter whose type you'd like to check.  Throws an error
			if this index is invalid.</td></tr>
</table><br>
<b>Returns:</b><br>
True if the parameter is of the given type; <b>false</b> otherwise.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>getParam</u>(T = MDValue)</big></dt>
<dd>Gets the value of a parameter off the stack.
<br><br>
<b>Params:</b><br>
<table><tr><td>index</td>
<td>The index of the parameter to get.  Throws an error if this index is invalid.</td></tr>
</table><br>
<b>Returns:</b><br>
The value of the parameter, templated to whatever type you'd like.  Throws an error if it
		can't be converted to your desired type.  Defaults to MDValue.
	
<br><br>

<dl></dl>
</dd>
<dt><big>template <u>getContext</u>(T = MDValue)</big></dt>
<dd>Gets the context (what would be the 'this' pointer in MiniD code) with which the function was called.
	The context, being special, is not included with the rest of the parameters.
<br><br>
<b>Returns:</b><br>
The context, whose type is templated to whatever you'd like.
	
<br><br>

<dl></dl>
</dd>
<dt><big>MDValue[] <u>getParams</u>(int <i>lo</i>, int <i>hi</i>);
</big></dt>
<dd>Gets a slice of the parameters as an array.  Throws an error if the slice boundaries are invalid.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>lo</i></td>
<td>The low index of the slice.  Can be negative, which means "from the end," i.e. -1 would mean
			"begin at the very last parameter."  Inclusive.</td></tr>
<tr><td>int <i>hi</i></td>
<td>The high index of the slice.  Can be negative, which means "from the end," i.e. -1 would mean
			"end after the very last parameter".  Noninclusive.</td></tr>
</table><br>
<b>Returns:</b><br>
An array containing the parameter values.  Because of the way the stack works, this is not (and cannot
		be) a slice into the internal stack, but is instead a copy.
	
<br><br>

</dd>
<dt><big>MDValue[] <u>getAllParams</u>();
</big></dt>
<dd>Gets all the parameters passed to the function as an array.  Equivalent to calling getParams(0, -1).
<br><br>
<b>Returns:</b><br>
An array of all the parameters.  It's a copy of the internal stack.
	
<br><br>

</dd>
<dt><big>template <u>safeCode</u>(T)</big></dt>
<dd>An odd sort of protective function.  You can use this function to wrap a call to a library function etc. which
	could throw an exception, but when you don't want to have to bother with catching the exception yourself.  Useful
	for writing native MiniD libraries.
<br><br>
Say you had a function which opened a file:
<br><br>

<pre class="d_code">	File f = OpenFile(<font color=red>"filename"</font>);
</pre>

	Say this function could throw an exception if it failed.  Since the interpreter can only catch (and make meaningful
	stack traces about) exceptions which derive from MDException, any exceptions that this throws would just percolate
	up out of the interpreter stack.  You could catch the exception yourself, but that's kind of tedious, especially when
	you call a lot of native functions.
<br><br>

	Instead, you can wrap the call to this unsafe function with a call to <u>safeCode</u>().
<br><br>

<pre class="d_code">	File f = s.<u>safeCode</u>(OpenFile(<font color=red>"filename"</font>));
</pre>

	What <u>safeCode</u>() does is it tries to execute the code it is passed.  If it succeeds, it simply returns any value that
	the code returns.  If it throws an exception derived from MDException, it rethrows the exception.  And if it throws
	an exception that derives from Exception, it throws a new MDException with the original exception's message as the
	message.
<br><br>

	<u>safeCode</u>() is templated to allow any return value.

<br><br>
<b>Params:</b><br>
<table><tr><td>code</td>
<td>The code to be executed.  This is a lazy parameter, so it's not actually executed until inside the call to
			<u>safeCode</u>.</td></tr>
</table><br>
<b>Returns:</b><br>
Whatever the code parameter returns.
	
<br><br>

<dl></dl>
</dd>
<dt><big>void <u>throwRuntimeException</u>(MDValue* <i>val</i>);
<br>void <u>throwRuntimeException</u>(char[] <i>fmt</i>,...);
</big></dt>
<dd>Throws a new runtime exception, starting the debug traceback with the current debug location.
	
<br><br>

</dd>
<dt><big>MDNamespace <u>environment</u>(int <i>depth</i> = 0);
</big></dt>
<dd>Gets the <u>environment</u> of a closure on the call stack.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>depth</i></td>
<td>The <i>depth</i> into the call stack of the closure whose <u>environment</u> to get.  Defaults to 0, which
			means the currently-executing closure.  A <i>depth</i> of 1 would mean the closure which called this
			closure, 2 the closure that called that one etc.</td></tr>
</table><br>
<b>Returns:</b><br>
The closure's <u>environment</u>.
	
<br><br>

</dd>
<dt><big>size_t <u>callDepth</u>();
</big></dt>
<dd>Gets the current call depth, that is, how many functions are currently on the call stack which
	have yet to return.
	
<br><br>

</dd>
<dt><big>MDString <u>valueToString</u>(ref MDValue <i>value</i>);
</big></dt>
<dd>Get a string representation of any MiniD <i>value</i>.  This is different from MDValue.toUtf8() in that it will call
	any toString metamethods defined for the object.
<br><br>
<b>Params:</b><br>
<table></table><br>
<b>Returns:</b><br>
The string representation of the <i>value</i>.
	
<br><br>

</dd>
<dt><big>bool <u>opin</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
</big></dt>
<dd>Determines if the value <i>a</i> is in the container <i>b</i>.  Returns <b>true</b> if so, <b>false</b> if not.
	
<br><br>

</dd>
<dt><big>int <u>cmp</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
</big></dt>
<dd>Compares the two values, calling any opCmp metamethods, and returns the result.
	
<br><br>

</dd>
<dt><big>MDValue <u>idx</u>(ref MDValue <i>src</i>, ref MDValue <i>index</i>);
</big></dt>
<dd>Indexes <i>src</i> with <i>index</i>, and gives the result.  Like writing <i>src</i>[<i>index</i>] in MiniD.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>void <u>idxa</u>(ref MDValue <i>dest</i>, ref MDValue <i>index</i>, ref MDValue <i>src</i>);
</big></dt>
<dd>Index-assigns <i>src</i> into the <i>index</i> slot of <i>dest</i>.  Like writing <i>dest</i>[<i>index</i>] = <i>src</i> in MiniD.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>len</u>(ref MDValue <i>val</i>);
</big></dt>
<dd>Gets the length of <i>val</i>.  Like #<i>val</i> in MiniD.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>slice</u>(ref MDValue <i>src</i>, ref MDValue <i>lo</i>, ref MDValue <i>hi</i>);
</big></dt>
<dd>Slice <i>src</i> from <i>lo</i> to <i>hi</i>.  Like <i>src</i>[<i>lo</i> .. <i>hi</i>] in MiniD.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>void <u>slicea</u>(ref MDValue <i>dest</i>, ref MDValue <i>lo</i>, ref MDValue <i>hi</i>, ref MDValue <i>src</i>);
</big></dt>
<dd>Assign a slice <i>src</i> to <i>dest</i> from <i>lo</i> to <i>hi</i>.  Like <i>dest</i>[<i>lo</i> .. <i>hi</i>] = <i>src</i> in MiniD.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>add</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>sub</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>mul</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>div</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>mod</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
</big></dt>
<dd>Performs an arithmetic operation on the two values and returns the result.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>neg</u>(ref MDValue <i>a</i>);
</big></dt>
<dd>Negates the argument.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>void <u>addeq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>subeq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>muleq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>diveq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>modeq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
</big></dt>
<dd>Performs <i>a</i> reflexive arithmetic operation on <i>a</i>, with <i>b</i> as the right hand side.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>and</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>or</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>xor</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>shl</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>shr</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>MDValue <u>ushr</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
</big></dt>
<dd>Performs <i>a</i> binary operation on the two values <u>and</u> returns the result.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>com</u>(ref MDValue <i>a</i>);
</big></dt>
<dd>Performs <i>a</i> bitwise complement of the argument.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>void <u>andeq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>oreq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>xoreq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>shleq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>shreq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
<br>void <u>ushreq</u>(ref MDValue <i>a</i>, ref MDValue <i>b</i>);
</big></dt>
<dd>Performs <i>a</i> reflexive bitwise operation on <i>a</i>, with <i>b</i> as the right hand side.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>MDValue <u>cat</u>(MDValue[] <i>vals</i>);
</big></dt>
<dd>Concatenates the list of values (which must be at least two items long) into a single value and
	returns it.  Calls metamethods.
	
<br><br>

</dd>
<dt><big>void <u>cateq</u>(ref MDValue <i>dest</i>, MDValue[] <i>vals</i>);
</big></dt>
<dd>Appends the list of values (which must have at least one item) to the end of the value held in <i>dest</i>.
	Calls metamethods.
	
<br><br>

</dd>
<dt><big>uint <u>yield</u>(uint <i>numReturns</i>, MDValue[] <i>values</i>...);
</big></dt>
<dd>Yields from a native function acting as a coroutine, just like using the <u>yield</u>() expression
	in MiniD.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>numReturns</i></td>
<td>How many returns you'd like to get from the <u>yield</u> operation.  -1 means as many
			<i>values</i> as are passed to this coroutine when it's resumed, in which case the return value
			of this method becomes significant.</td></tr>
<tr><td>MDValue[] <i>values</i></td>
<td>A list of <i>values</i> to <u>yield</u>.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of return <i>values</i> to be popped off the stack.  If <i>numReturns</i> was -1, this is how many
		<i>values</i> you must pop.  If <i>numReturns</i> was &gt;= 0, it's the same as <i>numReturns</i>.
	
<br><br>

</dd>
<dt><big>void <u>reset</u>();
</big></dt>
<dd>Resets this coroutine.  Only works if this coroutine is in the Dead state.
	
<br><br>

</dd>
<dt><big>MDContext <u>context</u>();
</big></dt>
<dd>Gets the <u>context</u> which owns this thread.
	
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. </small>
	</body></html>
