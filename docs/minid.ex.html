
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>minid.ex</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("minid.ex");</script>
	<table class="content">
		<tr><td id="docbody"><h1>minid.ex</h1><!-- Generated by Ddoc from minid\ex.d -->
This module contains the "extension" API, which is a bunch of useful
functionality built on top of the "raw" API.
<br><br>
<b>License:</b><br><pre class="license">Copyright (c) 2008 Jarrett Billingsley
<br><br>

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
<br><br>

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:
<br><br>

    1. The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software in a
	product, an acknowledgment in the product documentation would be
	appreciated but is not required.
<br><br>

    2. Altered source versions must be plainly marked as such, and must not
	be misrepresented as being the original software.
<br><br>

    3. This notice may not be removed or altered from any source distribution.
</pre><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">makeModule</span>
<script>explorer.outline.addDecl('makeModule');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">name</span>, uint function(MDThread*, uint) <span class="funcparam">loader</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Simple function that attempts to create a custom <span class="funcparam">loader</span> (by making an entry in modules.customLoaders) for a
module.  Throws an exception if a <span class="funcparam">loader</span> for the given module <span class="funcparam">name</span> already exists.
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">name</span></td>

               
<td>The <span class="funcparam">name</span> of the module.  If it's a nested module, include all <span class="funcparam">name</span> components (like "foo.bar.baz").</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">uint function(MDThread*, uint) <span class="funcparam">loader</span></td>

               
<td>The module's <span class="funcparam">loader</span> function.  Serves as the top-level function when the module is imported, and any
		globals defined in it become the module's public symbols.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">CreateClass</span>
<script>explorer.outline.addDecl('CreateClass');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A little helper object for making native classes.  Just removes some of the boilerplate involved.
<br><br>
You use it like so:
<br><br>

<pre class="d_code"><pre class="d_comment">// Make a class named ClassName with no base class
</pre><pre class="d_psymbol">CreateClass</pre>(t, <pre class="d_string">"ClassName"</pre>, (<pre class="d_psymbol">CreateClass</pre>* c)
{
	<pre class="d_comment">// Some normal methods
</pre>	c.method(<pre class="d_string">"blah"</pre>, &amp;blah);
	c.method(<pre class="d_string">"forble"</pre>, &amp;forble);

	<pre class="d_comment">// A method with one upval.  Push it, then call c.method
</pre>	pushInt(t, 0);
	c.method(<pre class="d_string">"funcWithUpval"</pre>, &amp;funcWithUpval, 1);
});

<pre class="d_comment">// At this point, the class is sitting on top of the stack, so we have to store it
</pre>newGlobal(t, <pre class="d_string">"ClassName"</pre>);

<pre class="d_comment">// Make a class that derives from ClassName
</pre><pre class="d_psymbol">CreateClass</pre>(t, <pre class="d_string">"DerivedClass"</pre>, <pre class="d_string">"ClassName"</pre>, (<pre class="d_psymbol">CreateClass</pre>* c) {});
newGlobal(t, <pre class="d_string">"DerivedClass"</pre>);
</pre>

If you pop the class inside the callback delegate accidentally, it'll check for that and
throw an error.
<br><br>

You can, of course, modify the class object after creating it, like if you need to add a finalizer or allocator.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">name</span>, void delegate(CreateClass*) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static void 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">name</span>, char[] <span class="funcparam">base</span>, void delegate(CreateClass*) <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><br><br>
</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">method</span>
<script>explorer.outline.addDecl('method');</script>

(char[] <span class="funcparam">name</span>, uint function(MDThread*, uint) <span class="funcparam">f</span>, uint <span class="funcparam">numUpvals</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Register a 
<span class="currsymbol">method</span>
<script>explorer.outline.addDecl('method');</script>

.
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">name</span></td>

               
<td>Method <span class="funcparam">name</span>.  The actual <span class="funcparam">name</span> that the native function closure will be created with is
			the class's <span class="funcparam">name</span> concatenated with a period and then the 
<span class="currsymbol">method</span>
<script>explorer.outline.addDecl('method');</script>

 <span class="funcparam">name</span>, so that in the example
			code above, the "blah" 
<span class="currsymbol">method</span>
<script>explorer.outline.addDecl('method');</script>

 would be named "ClassName.blah".</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">uint function(MDThread*, uint) <span class="funcparam">f</span></td>

               
<td>The native function.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">numUpvals</span></td>

               
<td>How many upvalues this function needs.  There should be this many values sitting on
			the stack.</td></tr>
</table><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uword 
<span class="currsymbol">BasicClassAllocator</span>
<script>explorer.outline.addDecl('BasicClassAllocator');</script>

(uword numFields, Members)(MDThread* <span class="funcparam">t</span>, uword <span class="funcparam">numParams</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A standard class allocator for when you need to allocate some extra fields/bytes in a class instance.
Allocates the new instance with the given number of extra fields and bytes, then calls the ctor.
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">numFields</td>

               
<td>The number of extra fields to allocate in the instance.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">Members</td>

               
<td>Any type.  Members.sizeof extra bytes will be allocated in the instance, and those bytes
		will be initialized to Members.init.</td></tr>
</table><br>
<b>Example:</b><br>
<pre class="d_code">newClass(t, <pre class="d_string">"Foob"</pre>);
	<pre class="d_comment">// ...
</pre>
	<pre class="d_comment">// We need 1 extra field, and SomeStruct will be used as the extra bytes
</pre>	newFunction(t, &amp;<pre class="d_psymbol">BasicClassAllocator</pre>!(1, SomeStruct), <pre class="d_string">"Foob.allocator"</pre>);
	setAllocator(t, -2);
newGlobal(t, <pre class="d_string">"Foob"</pre>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uword 
<span class="currsymbol">BasicClassAllocator</span>
<script>explorer.outline.addDecl('BasicClassAllocator');</script>

(uword numFields, uword numBytes)(MDThread* <span class="funcparam">t</span>, uword <span class="funcparam">numParams</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Similar to above, but instead of a type for the extra bytes, just takes a number of bytes.  In this case
the extra bytes will be uninitialized.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T* 
<span class="currsymbol">getMembers</span>
<script>explorer.outline.addDecl('getMembers');</script>

(T)(MDThread* <span class="funcparam">t</span>, word <span class="funcparam">index</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>For the instance at the given index, gets the extra bytes and returns them cast to a pointer to the
given type.  Checks that the number of extra bytes is at least the size of the given type, but
this should not be used as a foolproof way of identifying the type of instances.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">StrBuffer</span>
<script>explorer.outline.addDecl('StrBuffer');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A utility structure for building up strings out of several pieces more efficiently than by just pushing
all the bits and concatenating.  This struct keeps an internal buffer so that strings are built up in
large chunks.
<br><br>
This struct uses the stack of a thread to hold its intermediate results, so if you perform any stack
manipulation to calls to this struct's functions, make sure your stack operations are balanced, or you
will mess up the string building.  Also, negative stack indices may change where they reference during
string building since the stack may grow, so be sure to use absolute (positive) indices where necessary.
<br><br>

A typical use looks something like this:
<br><br>

<pre class="d_code"><pre class="d_keyword">auto</pre> buf = <pre class="d_psymbol">StrBuffer</pre>(t);
buf.addString(someString);
buf.addChar(someChar);
<pre class="d_comment">// ...
</pre><pre class="d_keyword">auto</pre> strIdx = buf.finish();
<pre class="d_comment">// The stack is how it was before we created the buffer, except with the result string is on top.
</pre></pre>
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">static StrBuffer 
<span class="currsymbol">opCall</span>
<script>explorer.outline.addDecl('opCall');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Create an instance of this struct.  The struct is bound to a single thread.
	
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">addChar</span>
<script>explorer.outline.addDecl('addChar');</script>

(dchar <span class="funcparam">c</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Add a character to the internal buffer.
	
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">addString</span>
<script>explorer.outline.addDecl('addString');</script>

(char[] <span class="funcparam">s</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Add a string to the internal buffer.
	
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">addTop</span>
<script>explorer.outline.addDecl('addTop');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Add the value on top of the stack to the buffer.  This is the only function that breaks the
	rule of leaving the stack balanced.  For this function to work, you must have exactly one
	value on top of the stack, and it must be a string or a char.
	
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">sink</span>
<script>explorer.outline.addDecl('sink');</script>

(char[] <span class="funcparam">s</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A convenience function for hooking up to the Tango IO and formatting facilities.  You can pass
	"&buf.sink" to many Tango functions that expect a sink function for string data.
	
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">finish</span>
<script>explorer.outline.addDecl('finish');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Indicate that the string building is complete.  This function will leave just the finished string
	on top of the stack.  The StrBuffer will also be in a state to build a new string if you so desire.
	
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">lookup</span>
<script>explorer.outline.addDecl('lookup');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Look up some value using a <span class="funcparam">name</span> that looks like a chain of dot-separated identifiers (like a MiniD expression).
The name must follow the regular expression "\w[\w\d]*(\.\w[\w\d]*)*".  No spaces are allowed.  The looked-up
value is left at the top of the stack.
<br><br>
This functions behaves just as though you were evaluating this expression in MiniD.  Global lookup and opField
metamethods are respected.
<br><br>

<pre class="d_code"><pre class="d_keyword">auto</pre> slot = <pre class="d_psymbol">lookup</pre>(<pre class="d_param">t</pre>, <pre class="d_string">"time.Timer"</pre>);
pushNull(<pre class="d_param">t</pre>);
rawCall(<pre class="d_param">t</pre>, slot, 1);
<pre class="d_comment">// We now have an instance of time.Timer on top of the stack.
</pre></pre>

If you want to set a long name, such as "foo.bar.baz.quux", you just lookup everything but the last name and
use 'fielda' to set it:
<br><br>

<pre class="d_code"><pre class="d_keyword">auto</pre> slot = <pre class="d_psymbol">lookup</pre>(<pre class="d_param">t</pre>, <pre class="d_string">"foo.bar.baz"</pre>);
pushInt(<pre class="d_param">t</pre>, 5);
fielda(<pre class="d_param">t</pre>, slot, <pre class="d_string">"quux"</pre>);
</pre>

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">name</span></td>

               
<td>The dot-separated name of the value to look up.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the looked-up value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">word 
<span class="currsymbol">lookupCT</span>
<script>explorer.outline.addDecl('lookupCT');</script>

(char[] name)(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Very similar to lookup, this function trades a bit of code bloat for the benefits of checking that the name is valid
at compile time and of being faster.  The name is validated and translated directly into a series of API calls, meaning
this function will be likely to be inlined.  The usage is exactly the same as lookup, except the name is now a template
parameter instead of a normal parameter.
<br><br>
<b>Returns:</b><br>
The stack index of the looked-up value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">getRegistryVar</span>
<script>explorer.outline.addDecl('getRegistryVar');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes the variable that is stored in the registry with the given <span class="funcparam">name</span> onto the stack.  An error will be thrown if the variable
does not exist in the registry.
<br><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">setRegistryVar</span>
<script>explorer.outline.addDecl('setRegistryVar');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pops the value off the top of the stack and sets it into the given registry variable.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">loadString</span>
<script>explorer.outline.addDecl('loadString');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">code</span>, bool <span class="funcparam">customEnv</span> = false, char[] <span class="funcparam">name</span> = "&lt;loaded by 
<span class="currsymbol">loadString</span>
<script>explorer.outline.addDecl('loadString');</script>

&gt;");
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Similar to the loadString function in the MiniD base library, this compiles some statements
into a function that takes variadic arguments and pushes that function onto the stack.
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">code</span></td>

               
<td>The source code of the function.  This should be one or more statements.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">customEnv</span></td>

               
<td>If <b>true</b>, expects the value on top of the stack to be a namespace which will be
		set as the environment of the new function.  The namespace will be replaced.  Defaults
		to <b>false</b>, in which case the current function's environment will be used.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">name</span></td>

               
<td>The name to give the function.  Defaults to "<loaded by loadString>".</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-compiled function.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">runString</span>
<script>explorer.outline.addDecl('runString');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">code</span>, bool <span class="funcparam">customEnv</span> = false, char[] <span class="funcparam">name</span> = "&lt;loaded by 
<span class="currsymbol">runString</span>
<script>explorer.outline.addDecl('runString');</script>

&gt;");
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This is a quick way to run some MiniD <span class="funcparam">code</span>.  Basically this just calls loadString and then runs
the resulting function with no parameters.  This function's parameters are the same as loadString's.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">eval</span>
<script>explorer.outline.addDecl('eval');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">code</span>, int <span class="funcparam">numReturns</span> = 1, bool <span class="funcparam">customEnv</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Similar to the eval function in the MiniD base library, this compiles an expression, evaluates it,
and leaves the result(s) on the stack.
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">code</span></td>

               
<td>The source code of the expression.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">numReturns</span></td>

               
<td>How many return values you want from the expression.  Defaults to 1.  Works just like
		the numReturns parameter of the call functions; -1 gets all return values.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">customEnv</span></td>

               
<td>If <b>true</b>, expects the value on top of the stack to be a namespace which will be
		used as the environment of the expression.  The namespace will be replaced.  Defaults
		to <b>false</b>, in which case the current function's environment will be used.</td></tr>
</table><br>
<b>Returns:</b><br>
If <span class="funcparam">numReturns</span> &gt;= 0, returns <span class="funcparam">numReturns</span>.  If <span class="funcparam">numReturns</span> == -1, returns how many values the expression
	returned.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">runFile</span>
<script>explorer.outline.addDecl('runFile');</script>

(MDThread* <span class="funcparam">t</span>, char[] <span class="funcparam">filename</span>, uint <span class="funcparam">numParams</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Imports a module or file and runs any main() function in it.
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">char[] <span class="funcparam">filename</span></td>

               
<td>The name of the file or module to load.  If it's a path to a file, it must end in .md or .mdm.
		It will be compiled or deserialized as necessary. If it's a module name, it must be in dotted form and
		not end in md or mdm.  It will be imported as normal.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">numParams</span></td>

               
<td>How many arguments you have to pass to the main() function.  If you want to pass params, they
		must be on top of the stack when you call this function.</td></tr>
</table><br>
<b>Example:</b><br>
<pre class="d_code"><pre class="d_comment">// We want to load "foo.bar.baz" and pass it "a" and "b" as params.
</pre><pre class="d_comment">// Push the params first.
</pre>pushString(<pre class="d_param">t</pre>, <pre class="d_string">"a"</pre>);
pushString(<pre class="d_param">t</pre>, <pre class="d_string">"b"</pre>);
<pre class="d_comment">// Run the file and tell it we have two params.
</pre><pre class="d_psymbol">runFile</pre>(<pre class="d_param">t</pre>, <pre class="d_string">"foo.bar.baz"</pre>, 2);
</pre>

<pre class="d_code"><pre class="d_comment">// Just showing how you'd execute a module by filename instead of module name.
</pre><pre class="d_psymbol">runFile</pre>(<pre class="d_param">t</pre>, <pre class="d_string">"foo/bar/baz.md"</pre>);
</pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">mdtry</span>
<script>explorer.outline.addDecl('mdtry');</script>

(MDThread* <span class="funcparam">t</span>, void delegate() <span class="funcparam">try_</span>, void delegate(MDException, int) <span class="funcparam">catch_</span>, void delegate() <span class="funcparam">finally_</span> = null);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This function abstracts away some of the boilerplate code that is usually associated with try-catch blocks
that handle MiniD exceptions in D code.
<br><br>
This function will store the stack size of the given thread when it is called, before the try code is executed.
If an exception occurs, the stack will be restored to that size, the MiniD exception will be caught (with
catchException), and the catch code will be called with the D exception object and the MiniD exception object's
stack index as parameters.  The catch block is expected to leave the stack balanced, that is, it should be the
same size upon exit as it was upon entry (an error will be thrown if this is not the case).  Lastly, the given
finally code, if any, will be executed as a finally block usually is.
<br><br>

This function is best used with anonymous delegates, like so:
<br><br>

<pre class="d_code"><pre class="d_psymbol">mdtry</pre>(<pre class="d_param">t</pre>,
<pre class="d_comment">// try block
</pre>{
	<pre class="d_comment">// foo bar baz
</pre>},
<pre class="d_comment">// catch block
</pre>(MDException e, word mdEx)
{
	<pre class="d_comment">// deal with exception here
</pre>},
<pre class="d_comment">// finally block
</pre>{
	<pre class="d_comment">// cleanup, whatever
</pre>});
</pre>

It can be easy to forget that those blocks are actually delegates, and returning from them just returns from
the delegate instead of from the enclosing function.  Hey, don'<span class="funcparam">t</span> look at me; it's D's fault for not having
AST macros ;)
<br><br>

If you just need a try-finally block, you don'<span class="funcparam">t</span> need this function, and please don'<span class="funcparam">t</span> call it with a <b>null</b>
<span class="funcparam">catch_</span> parameter.  Just use a normal try-finally block in that case (or better yet, a scope(exit) block).

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">void delegate() <span class="funcparam">try_</span></td>

               
<td>The try code.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">void delegate(MDException, int) <span class="funcparam">catch_</span></td>

               
<td>The catch code.  It takes two parameters - the D exception object and the stack index of the caught
		MiniD exception object.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">void delegate() <span class="funcparam">finally_</span></td>

               
<td>The optional finally code.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">stackCheck</span>
<script>explorer.outline.addDecl('stackCheck');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">diff</span>, void delegate() <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A useful wrapper for code where you want to ensure that the stack is balanced, that is, it is the same size after
some set of operations as before it.  Having a balanced stack is more than just good practice - it prevents stack
overflows and underflows.
<br><br>
You can also use this function when your code requires that the stack be a certain number of slots larger or smaller
after some stack operations - for instance, a function which always returns two values, regardless of multiple
execution paths.
<br><br>

If the stack size is not correct after running the code, an exception will be thrown in the passed-in thread.

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">diff</span></td>

               
<td>How many more (or fewer) items there should be on the stack after running the code.  If 0, it means that
		the stack size after running the code should be exactly as it was before (there is an overload for this common
		case below).  Positive numbers mean the stack should be bigger, and negative numbers mean it should be smaller.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">void delegate() <span class="funcparam">dg</span></td>

               
<td>The code to run.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><pre class="d_comment">// check that the stack is two bigger after the code than before
</pre><pre class="d_psymbol">stackCheck</pre>(<pre class="d_param">t</pre>, 2,
{
	pushNull(<pre class="d_param">t</pre>);
	pushInt(<pre class="d_param">t</pre>, 5);
}); <pre class="d_comment">// it is indeed 2 slots bigger, so it succeeds.
</pre>
<pre class="d_comment">// check that the stack shrinks by 1 slot
</pre><pre class="d_psymbol">stackCheck</pre>(<pre class="d_param">t</pre>, -1,
{
	pushString(<pre class="d_param">t</pre>, <pre class="d_string">"foobar"</pre>);
}); <pre class="d_comment">// oh noes, it's 1 slot bigger instead - throws an exception.
</pre></pre>
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">stackCheck</span>
<script>explorer.outline.addDecl('stackCheck');</script>

(MDThread* <span class="funcparam">t</span>, void delegate() <span class="funcparam">dg</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An overload of the above which simply calls it with a difference of 0 (i.e. the stack is completely balanced).
This is the most common case.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">allocArray</span>
<script>explorer.outline.addDecl('allocArray');</script>

(T)(MDThread* <span class="funcparam">t</span>, uword <span class="funcparam">length</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Wraps the allocMem API.  Allocates an array of the given type with the given length.
You'll have to explicitly specify the type of the array.
<br><br>
<pre class="d_code"><pre class="d_keyword">auto</pre> arr = <pre class="d_psymbol">allocArray</pre>!(<pre class="d_keyword">int</pre>)(t, 10); <pre class="d_comment">// arr is an int[] of length 10
</pre></pre>

The array returned by this function should not have its length set or be appended to (~=).

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">length</td>

               
<td>The length, in items, of the array to allocate.</td></tr>
</table><br>
<b>Returns:</b><br>
The new array.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">resizeArray</span>
<script>explorer.outline.addDecl('resizeArray');</script>

(T)(MDThread* <span class="funcparam">t</span>, ref T[] <span class="funcparam">arr</span>, uword <span class="funcparam">length</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Wraps the resizeMem API.  Resizes an array to the new length.  Use this instead of using .length on
the array.  <b>Only call this on arrays which have been allocated by the MiniD allocator.</b>
<br><br>
Calling this function on a 0-length array is legal and will allocate a new array.  Resizing an existing array to 0
is legal and will deallocate the array.
<br><br>

The array returned by this function through the arr parameter should not have its length set or be appended to (~=).
<br><br>

<pre class="d_code"><pre class="d_psymbol">resizeArray</pre>(t, arr, 4); <pre class="d_comment">// arr.length is now 4
</pre></pre>

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">arr</td>

               
<td>A reference to the array you want to resize.  This is a reference so that the original array
		reference that you pass in is updated.  This can be a 0-length array.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">length</td>

               
<td>The length, in items, of the new size of the array.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T[] 
<span class="currsymbol">dupArray</span>
<script>explorer.outline.addDecl('dupArray');</script>

(T)(MDThread* <span class="funcparam">t</span>, T[] <span class="funcparam">arr</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Wraps the dupMem API.  Duplicates an array.  This is safe to call on arrays that were not allocated by the MiniD
allocator.  The new array will be the same length and contain the same data as the old array.
<br><br>
The array returned by this function should not have its length set or be appended to (~=).
<br><br>

<pre class="d_code"><pre class="d_keyword">auto</pre> newArr = <pre class="d_psymbol">dupArray</pre>(t, arr); <pre class="d_comment">// newArr has the same data as arr
</pre></pre>

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">arr</td>

               
<td>The array to duplicate.  This is not required to have been allocated by the MiniD allocator.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">freeArray</span>
<script>explorer.outline.addDecl('freeArray');</script>

(T)(MDThread* <span class="funcparam">t</span>, ref T[] <span class="funcparam">arr</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Wraps the freeMem API.  Frees an array.  <b>Only call this on arrays which have been allocated by the MiniD allocator.</b>
Freeing a 0-length array is legal.
<br><br>
<pre class="d_code"><pre class="d_psymbol">freeArray</pre>(t, arr);
<pre class="d_psymbol">freeArray</pre>(t, newArr);
</pre>

<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">arr</td>

               
<td>A reference to the array you want to free.  This is a reference so that the original array
		reference that you pass in is updated.  This can be a 0-length array.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">RefManager</span>
<script>explorer.outline.addDecl('RefManager');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A class that makes it possible to automatically remove references to MiniD objects.  You should create a <b>SCOPE</b> instance
of this class, which you can then use to create references to MiniD objects.  This class is not itself marked scope so that
you can pass references to it around, but you should still <b>ALWAYS</b> create instances of it as scope.
<br><br>
By using the reference objects that this manager creates, you can be sure that any MiniD objects you reference using it
will be dereferenced by the time the instance of 
<span class="currsymbol">RefManager</span>
<script>explorer.outline.addDecl('RefManager');</script>

 goes out of scope.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">Ref</span>
<script>explorer.outline.addDecl('Ref');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>An actual reference object.  This is basically an object-oriented wrapper around a MiniD reference identifier.  You
	don't create instances of this directly; see .
	
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">remove</span>
<script>explorer.outline.addDecl('remove');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Removes the reference using .  You can call this manually, or it will be called
		automatically when this object is collected or when its owning manager leaves scope.
		
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">push</span>
<script>explorer.outline.addDecl('push');</script>

();
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Push the reference using .  It is pushed onto the current thread of the VM in which
		it was created.
<br><br>
<b>Returns:</b><br>
The stack index of the object that was pushed.
		
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Ref 
<span class="currsymbol">create</span>
<script>explorer.outline.addDecl('create');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">idx</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Create a reference object to refer to the object at slot <span class="funcparam">idx</span> in thread <span class="funcparam">t</span> using .  The
	given thread's VM is associated with the reference object.
<br><br>
<b>Returns:</b><br>
A new reference object.
	
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">checkAnyParam</span>
<script>explorer.outline.addDecl('checkAnyParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Check that there is any parameter at the given <span class="funcparam">index</span>.  You can use this to ensure that a minimum number
of parameters were passed to your function.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">checkBoolParam</span>
<script>explorer.outline.addDecl('checkBoolParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
<br>long 
<span class="currsymbol">checkIntParam</span>
<script>explorer.outline.addDecl('checkIntParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
<br>double 
<span class="currsymbol">checkFloatParam</span>
<script>explorer.outline.addDecl('checkFloatParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
<br>dchar 
<span class="currsymbol">checkCharParam</span>
<script>explorer.outline.addDecl('checkCharParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
<br>char[] 
<span class="currsymbol">checkStringParam</span>
<script>explorer.outline.addDecl('checkStringParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These all check that a parameter of the given type was passed at the given <span class="funcparam">index</span>, and return the value
of that parameter.  Very simple.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">checkNumParam</span>
<script>explorer.outline.addDecl('checkNumParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks that the parameter at the given <span class="funcparam">index</span> is an int or a float, and returns the value as a float,
casting ints to floats as necessary.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">checkInstParam</span>
<script>explorer.outline.addDecl('checkInstParam');</script>

()(MDThread* <span class="funcparam">t</span>, word <span class="funcparam">index</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks that the parameter at the given index is an instance.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">checkInstParam</span>
<script>explorer.outline.addDecl('checkInstParam');</script>

()(MDThread* <span class="funcparam">t</span>, word <span class="funcparam">index</span>, char[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks that the parameter at the given index is an instance of the class given by name.  name must
be a dotted-identifier name suitable for passing into lookup().
<br><br>
<b>Params:</b><br><table class="params"><tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">index</td>

               
<td>The stack index of the parameter to check.</td></tr>
<tr>
<td class = "paramname" nowrap valign="top" style="padding-right: 8px">name</td>

               
<td>The name of the class from which the given parameter must be derived.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">T* 
<span class="currsymbol">checkInstParam</span>
<script>explorer.outline.addDecl('checkInstParam');</script>

(T)(MDThread* <span class="funcparam">t</span>, word <span class="funcparam">index</span>, char[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but also takes a template type parameter that should be a struct the same size as the
given instance's extra bytes.  Returns the extra bytes cast to a pointer to that struct type.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">checkParam</span>
<script>explorer.outline.addDecl('checkParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, Type <span class="funcparam">type</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Checks that the parameter at the given <span class="funcparam">index</span> is of the given <span class="funcparam">type</span>.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">paramTypeError</span>
<script>explorer.outline.addDecl('paramTypeError');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, char[] <span class="funcparam">expected</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Throws an informative exception about the parameter at the given <span class="funcparam">index</span>, telling the parameter <span class="funcparam">index</span> ('this' for
parameter 0), the <span class="funcparam">expected</span> type, and the actual type.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">optBoolParam</span>
<script>explorer.outline.addDecl('optBoolParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, bool <span class="funcparam">def</span>);
<br>long 
<span class="currsymbol">optIntParam</span>
<script>explorer.outline.addDecl('optIntParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, long <span class="funcparam">def</span>);
<br>double 
<span class="currsymbol">optFloatParam</span>
<script>explorer.outline.addDecl('optFloatParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, double <span class="funcparam">def</span>);
<br>dchar 
<span class="currsymbol">optCharParam</span>
<script>explorer.outline.addDecl('optCharParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, dchar <span class="funcparam">def</span>);
<br>char[] 
<span class="currsymbol">optStringParam</span>
<script>explorer.outline.addDecl('optStringParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, char[] <span class="funcparam">def</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These all get an optional parameter of the given type at the given <span class="funcparam">index</span>.  If no parameter was passed to that
<span class="funcparam">index</span> or if '<b>null</b>' was passed, '<span class="funcparam">def</span>' is returned; otherwise, the passed parameter must match the given type
and its value is returned.  This is the same behavior as in MiniD.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">optNumParam</span>
<script>explorer.outline.addDecl('optNumParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, double <span class="funcparam">def</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Just like the above, allowing ints or floats, and returns the value cast to a float, casting ints
to floats as necessary.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">optParam</span>
<script>explorer.outline.addDecl('optParam');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">index</span>, Type <span class="funcparam">type</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Similar to above, but works for any <span class="funcparam">type</span>.  Returns <b>false</b> to mean that no parameter was passed,
and <b>true</b> to mean that one was.
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Jul 16 22:47:49 2009

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModuleFull("minid.alloc");
	explorer.packageExplorer.addModuleFull("minid.api");
	explorer.packageExplorer.addModuleFull("minid.ast");
	explorer.packageExplorer.addModuleFull("minid.bind");
	explorer.packageExplorer.addModuleFull("minid.commandline");
	explorer.packageExplorer.addModuleFull("minid.compiler");
	explorer.packageExplorer.addModuleFull("minid.ex");
	explorer.packageExplorer.addModuleFull("minid.interpreter");
	explorer.packageExplorer.addModuleFull("minid.serialization");
	explorer.packageExplorer.addModuleFull("minid.types");
	explorer.packageExplorer.addModuleFull("minid.utils");
	explorer.packageExplorer.addModuleFull("minid.vm");</script>
</body></html>


