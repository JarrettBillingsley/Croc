
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>minid.interpreter</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("minid.interpreter");</script>
	<table class="content">
		<tr><td id="docbody"><h1>minid.interpreter</h1><!-- Generated by Ddoc from minid\interpreter.d -->
<b>License:</b><br>
Copyright (c) 2008 Jarrett Billingsley
<br><br>

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
<br><br>

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:
<br><br>

    1. The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software in a
	product, an acknowledgment in the product documentation would be
	appreciated but is not required.
<br><br>

    2. Altered source versions must be plainly marked as such, and must not
	be misrepresented as being the original software.
<br><br>

    3. This notice may not be removed or altered from any source distribution.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">State 
<span class="currsymbol">state</span>
<script>explorer.outline.addDecl('state');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the current coroutine 
<span class="currsymbol">state</span>
<script>explorer.outline.addDecl('state');</script>

 of the thread as a member of the MDThread.State enumeration.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">dchar[] 
<span class="currsymbol">stateString</span>
<script>explorer.outline.addDecl('stateString');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets a string representation of the current coroutine state of the thread.
<br><br>
The string returned is not on the MiniD heap, it's just a string literal.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">MDVM* 
<span class="currsymbol">getVM</span>
<script>explorer.outline.addDecl('getVM');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the VM that the thread is associated with.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushNull</span>
<script>explorer.outline.addDecl('pushNull');</script>

(MDThread* <span class="funcparam">t</span>);
<br>int 
<span class="currsymbol">pushBool</span>
<script>explorer.outline.addDecl('pushBool');</script>

(MDThread* <span class="funcparam">t</span>, bool <span class="funcparam">v</span>);
<br>int 
<span class="currsymbol">pushInt</span>
<script>explorer.outline.addDecl('pushInt');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">v</span>);
<br>int 
<span class="currsymbol">pushFloat</span>
<script>explorer.outline.addDecl('pushFloat');</script>

(MDThread* <span class="funcparam">t</span>, double <span class="funcparam">v</span>);
<br>int 
<span class="currsymbol">pushChar</span>
<script>explorer.outline.addDecl('pushChar');</script>

(MDThread* <span class="funcparam">t</span>, dchar <span class="funcparam">v</span>);
<br>int 
<span class="currsymbol">pushString</span>
<script>explorer.outline.addDecl('pushString');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">v</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These push a value of the given type onto the stack.
<br><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushFormat</span>
<script>explorer.outline.addDecl('pushFormat');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">fmt</span>,...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Push a formatted string onto the stack.  This works exactly like tango.text.convert.Layout (and in fact
calls it), except that the destination buffer is a MiniD string.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">fmt</span></td>

               
<td>The Tango-style format string.
	... = The arguments to be formatted.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed string.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushVFormat</span>
<script>explorer.outline.addDecl('pushVFormat');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">fmt</span>, TypeInfo[] <span class="funcparam">arguments</span>, void* <span class="funcparam">argptr</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A version of pushFormat meant to be called from variadic functions.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">fmt</span></td>

               
<td>The Tango-style format string.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">TypeInfo[] <span class="funcparam">arguments</span></td>

               
<td>The array of TypeInfo for the variadic arguments.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">void* <span class="funcparam">argptr</span></td>

               
<td>The platform-specific argument pointer.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed string.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newTable</span>
<script>explorer.outline.addDecl('newTable');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">size</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new table object and pushes it onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">size</span></td>

               
<td>The number of slots to preallocate in the table, as an optimization.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created table.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newArray</span>
<script>explorer.outline.addDecl('newArray');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">length</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new array object and pushes it onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">length</span></td>

               
<td>The <span class="funcparam">length</span> of the new array.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created array.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newFunction</span>
<script>explorer.outline.addDecl('newFunction');</script>

(MDThread* <span class="funcparam">t</span>, uint function(MDThread*, uint) <span class="funcparam">func</span>, dchar[] <span class="funcparam">name</span>, uint <span class="funcparam">numUpvals</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new native closure and pushes it onto the stack.
<br><br>
If you want to associate upvalues with the function, you should push them in order on
the stack before calling 
<span class="currsymbol">newFunction</span>
<script>explorer.outline.addDecl('newFunction');</script>

 and then pass how many upvalues you pushed.
An example:
<br><br>

<pre class="d_code"><font color=green>// 1. Push any upvalues.  Here we have two.  Note that they are pushed in order:
</font><font color=green>// upvalue 0 will be 5 and upvalue 1 will be "hi" once the closure is created.
</font>pushInt(<i>t</i>, 5);
pushString(<i>t</i>, <font color=red>"hi"</font>);

<font color=green>// 2. Call newFunction.
</font><u>newFunction</u>(<i>t</i>, &amp;myFunc, <font color=red>"myFunc"</font>, 2);

<font color=green>// 3. Store the resulting closure somewhere.
</font>setGlobal(<i>t</i>, <font color=red>"myFunc"</font>);
</pre>

This function pops any upvalues off the stack and leaves the new closure in their place.
<br><br>

The function's environment is, by default, the current environment (see pushEnvironment).
To use a different environment, see newFunctionWithEnv.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint function(MDThread*, uint) <span class="funcparam">func</span></td>

               
<td>The native function to be used in the closure.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name to be given to the function.  This is just the 'debug' name that
		shows up in error messages.  In order to make the function accessible, you have
		to actually put the resulting closure somewhere, like in the globals, or in
		a namespace.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">numUpvals</span></td>

               
<td>How many upvalues there are on the stack under the name to be associated
		with this closure.  Defaults to 0.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created closure.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newFunctionWithEnv</span>
<script>explorer.outline.addDecl('newFunctionWithEnv');</script>

(MDThread* <span class="funcparam">t</span>, uint function(MDThread*, uint) <span class="funcparam">func</span>, dchar[] <span class="funcparam">name</span>, uint <span class="funcparam">numUpvals</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new native closure with an explicit environment and pushes it onto the stack.
<br><br>
Very similar to newFunction, except that it also expects the environment for the function
(a namespace) to be on top of the stack.  Using newFunction's example, one would push
the environment namespace after step 1, and step 2 would call 
<span class="currsymbol">newFunctionWithEnv</span>
<script>explorer.outline.addDecl('newFunctionWithEnv');</script>

 instead.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint function(MDThread*, uint) <span class="funcparam">func</span></td>

               
<td>The native function to be used in the closure.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name to be given to the function.  This is just the 'debug' name that
		shows up in error messages.  In order to make the function accessible, you have
		to actually put the resulting closure somewhere, like in the globals, or in
		a namespace.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">numUpvals</span></td>

               
<td>How many upvalues there are on the stack under the name and environment to
		be associated with this closure.  Defaults to 0.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created closure.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newObject</span>
<script>explorer.outline.addDecl('newObject');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">proto</span>, dchar[] <span class="funcparam">name</span> = null, uint <span class="funcparam">numValues</span> = cast(uint)0, uint <span class="funcparam">extraBytes</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new object and pushes it onto the stack.
<br><br>
MiniD objects can have two kinds of extra data associated with them for use by the host: extra
MiniD values and arbitrary bytes.  The structure of a MiniD object is something like this:
<br><br>

<pre class="d_code"><font color=green>// ---------
</font><font color=green>// |       |
</font><font color=green>// |       | The data that's part of every object - the fields, proto, name, and attributes.
</font><font color=green>// |       |
</font><font color=green>// +-------+
</font><font color=green>// |0: "x" | Extra MiniD values which can point into the MiniD heap.
</font><font color=green>// |1: 5   |
</font><font color=green>// +-------+
</font><font color=green>// |...    | Arbitrary byte data.
</font><font color=green>// ---------
</font></pre>

Both extra sections are optional, and no objects created by scripts will have them.
<br><br>

Extra MiniD values are useful for adding "members" to the object which are not visible to the
scripts but which can still hold MiniD objects.  They will be scanned by the GC, so objects
referenced by these members will not be collected.  If you want to hold a reference to a native
D object, for instance, this would be the place to put it (wrapped in a NativeObject).
<br><br>

The arbitrary bytes associated with an object are not scanned by either the D or the MiniD GC,
so don't store references to GC'ed objects there.  These bytes are useable for just about anything,
such as storing values which can't be stored in MiniD values -- structs, complex numbers, long
integers, whatever.
<br><br>

You can store references to <b>heap</b> objects in the extra bytes, but you must not store references
to <b>GC'ed</b> objects there.  That is, you can 'malloc' some data and store the pointer in the
extra bytes, since that's not GC'ed memory.  You must however perform your own memory management for
such memory.  You can set up a finalizer function for objects in which you can perform memory management
for these references.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">proto</span></td>

               
<td>The stack index of the proto object.  The proto can be `<b>null</b>`, in which case Object (defined
		in the base library and which lives in the global namespace) will be used.  Otherwise it must
		be an object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the new object.  If this parameter is <b>null</b> or the empty string, the name will
		be taken from the proto.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">numValues</span></td>

               
<td>How many extra MiniD values will be associated with the object.  See above.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">extraBytes</span></td>

               
<td>How many extra bytes to attach to the object.  See above.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newNamespace</span>
<script>explorer.outline.addDecl('newNamespace');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new namespace object and pushes it onto the stack.
<br><br>
The parent of the new namespace will be the current function environment, exactly
as in MiniD when you declare a namespace without an explicit parent.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the namespace.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created namespace.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newNamespace</span>
<script>explorer.outline.addDecl('newNamespace');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">parent</span>, dchar[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new namespace object with an explicit <span class="funcparam">parent</span> and pushes it onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">parent</span></td>

               
<td>The stack index of the parent.  The parent can be <b>null</b>, in which case
		the new namespace will not have a parent.  Otherwise it must be a namespace.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the namespace.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created namespace.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newNamespaceNoParent</span>
<script>explorer.outline.addDecl('newNamespaceNoParent');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new namespace object with no parent and pushes it onto the stack.
<br><br>
This is very similar to newNamespace but creates a namespace without a parent.
This function expects no values to be on the stack.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the namespace.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created namespace.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">newThread</span>
<script>explorer.outline.addDecl('newThread');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">func</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Creates a new thread object (coroutine) and pushes it onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">func</span></td>

               
<td>The slot which contains the function to be used as the coroutine's body.
		This can be either a MiniD or native function.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-created thread.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushThread</span>
<script>explorer.outline.addDecl('pushThread');</script>

(MDThread* <span class="funcparam">t</span>, MDThread* <span class="funcparam">o</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Push the given thread onto this thread's stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">MDThread* <span class="funcparam">o</span></td>

               
<td>The thread to push.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushNativeObj</span>
<script>explorer.outline.addDecl('pushNativeObj');</script>

(MDThread* <span class="funcparam">t</span>, Object <span class="funcparam">o</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Push a reference to a native (D) object onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">Object <span class="funcparam">o</span></td>

               
<td>The object to push.</td></tr>
</table><br>
<b>Returns:</b><br>
The index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">dup</span>
<script>explorer.outline.addDecl('dup');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span> = -1);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Duplicate a value at the given stack index and push it onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot to duplicate.  Defaults to -1, which means the top of the stack.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed slot.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">insert</span>
<script>explorer.outline.addDecl('insert');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Insert the value at the top of the stack into the given slot, shifting up the values in that slot
and everything after it up by a slot.  This means the stack will stay the same size.  Similar to a
"rotate" operation common to many stack machines.
<br><br>
Throws an error if '<span class="funcparam">slot</span>' corresponds to the 'this' parameter.  'this' can never be modified.
<br><br>

If '<span class="funcparam">slot</span>' corresponds to the top-of-stack (but not 'this'), this function is a no-op.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot in which the value at the top will be inserted.  If this refers to the top of the
		stack, this function does nothing.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">insertAndPop</span>
<script>explorer.outline.addDecl('insertAndPop');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Similar to insert, but combines the insertion with a pop operation that pops everything after the
newly-inserted value off the stack.
<br><br>
Throws an error if '<span class="funcparam">slot</span>' corresponds to the 'this' parameter.  'this' can never be modified.
<br><br>

If '<span class="funcparam">slot</span>' corresponds to the top-of-stack (but not 'this'), this function is a no-op.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">pop</span>
<script>explorer.outline.addDecl('pop');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">n</span> = cast(uint)1);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pop a number of items off the stack.  Throws an error if you try to 
<span class="currsymbol">pop</span>
<script>explorer.outline.addDecl('pop');</script>

 more items than there are
on the stack.  'this' is not counted; so if there is 'this' and one value, and you try to 
<span class="currsymbol">pop</span>
<script>explorer.outline.addDecl('pop');</script>

 2
values, an error is thrown.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">n</span></td>

               
<td>The number of items to pop.  Defaults to 1.  Must be greater than 0.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">rawCall</span>
<script>explorer.outline.addDecl('rawCall');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, int <span class="funcparam">numReturns</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Calls the object at the given slot.  The parameters (including 'this') are assumed to be all the
values after that slot to the top of the stack.
<br><br>
The 'this' parameter is, according to the language specification, <b>null</b> if no explicit context is given.
You must still push this <b>null</b> value, however.
<br><br>

An example of calling a function:
<br><br>

<pre class="d_code"><font color=green>// Let's translate `x = f(5, "hi")` into API calls.
</font>
<font color=green>// 1. Push the function (or any callable object -- like objects, threads).
</font><font color=blue>auto</font> <i>slot</i> = pushGlobal(<i>t</i>, <font color=red>"f"</font>);

<font color=green>// 2. Push the 'this' parameter.  This is 'null' if you don'_t care.  Notice in the MiniD code, we didn'_t
</font><font color=green>// put a 'with', so 'null' will be used as the context.
</font>pushNull(<i>t</i>);

<font color=green>// 3. Push any params.
</font>pushInt(<i>t</i>, 5);
pushString(<i>t</i>, <font color=red>"hi"</font>);

<font color=green>// 4. Call it.
</font><u>rawCall</u>(<i>t</i>, <i>slot</i>, 1);

<font color=green>// 5. Do something with the return values.  setGlobal pops the return value off the stack, so now the
</font><font color=green>// stack is back the way it was when we started.
</font>setGlobal(<i>t</i>, <font color=red>"x"</font>);
</pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot containing the object to call.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">numReturns</span></td>

               
<td>How many return values you want.  Can be -1, which means you'll get all returns.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of return values given by the function.  If <span class="funcparam">numReturns</span> was -1, this is exactly how
	many returns the function gave.  If <span class="funcparam">numReturns</span> was &gt;= 0, this is the same as <span class="funcparam">numReturns</span> (and
	not exactly useful since you already know it).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">methodCall</span>
<script>explorer.outline.addDecl('methodCall');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, dchar[] <span class="funcparam">name</span>, int <span class="funcparam">numReturns</span>, bool <span class="funcparam">customThis</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Calls a method of an object at the given slot.  The parameters (including a spot for 'this') are assumed
to be all the values after that slot to the top of the stack.
<br><br>
This function behaves identically to a method call within the language, including calling opMethod
metamethods if the method is not found.
<br><br>

The process of calling a method is very similar to calling a normal function.
<br><br>

<pre class="d_code"><font color=green>// Let's translate `o.f(3)` into API calls.
</font>
<font color=green>// 1. Push the object on which the method will be called.
</font><font color=blue>auto</font> <i>slot</i> = pushGlobal(<i>t</i>, <font color=red>"o"</font>);

<font color=green>// 2. Make room for 'this'.  If you want to call the method with a custom 'this', push it here.
</font><font color=green>// Otherwise, we'll let MiniD figure out the 'this' and we can just push null.
</font>pushNull(<i>t</i>);

<font color=green>// 3. Push any params.
</font>pushInt(<i>t</i>, 3);

<font color=green>// 4. Call it with the method name.  We didn'_t push a custom 'this', so we don'_t pass '_true' for that param.
</font><u>methodCall</u>(<i>t</i>, <i>slot</i>, <font color=red>"f"</font>, 0);

<font color=green>// We didn'_t ask for any return values, so the stack is how it was before we began.
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot containing the object on which the method will be called.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the method to call.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">numReturns</span></td>

               
<td>How many return values you want.  Can be -1, which means you'll get all returns.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">customThis</span></td>

               
<td>If <b>true</b>, the 'this' parameter you push after the object will be respected and
		passed as 'this' to the method (though the method will still be looked up in the object).
		The default is <b>false</b>, where the context will be determined automatically (i.e. it's
		the object on which the method is being called).</td></tr>
</table><br>
<b>Returns:</b><br>
The number of return values given by the function.  If <span class="funcparam">numReturns</span> was -1, this is exactly how
	many returns the function gave.  If <span class="funcparam">numReturns</span> was &gt;= 0, this is the same as <span class="funcparam">numReturns</span> (and
	not exactly useful since you already know it).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">methodCall</span>
<script>explorer.outline.addDecl('methodCall');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, int <span class="funcparam">numReturns</span>, bool <span class="funcparam">customThis</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but expects the name of the method to be on top of the stack (after the parameters).
<br><br>
The parameters and return value are the same as above.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">superCall</span>
<script>explorer.outline.addDecl('superCall');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, dchar[] <span class="funcparam">name</span>, int <span class="funcparam">numReturns</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Performs a super call.  This function will only work if the currently-executing function was called as
a method of a value of type 'object'.
<br><br>
This function works similarly to other kinds of calls, but it's somewhat odd.  Other calls have you push the
thing to call followed by 'this' or a spot for it.  This call requires you to just give it two empty slots.
It will fill them in (and what it puts in them is really kind of scary).  Regardless, when the super method is
called (if there is one), its 'this' parameter will be the currently-executing function's 'this' parameter.
<br><br>

The process of performing a supercall is not really that much different from other kinds of calls.
<br><br>

<pre class="d_code"><font color=green>// Let's translate `super.f(3)` into API calls.
</font>
<font color=green>// 1. Push a null.
</font><font color=blue>auto</font> <i>slot</i> = pushNull(<i>t</i>);

<font color=green>// 2. Push another null.  You can'_t call a super method with a custom 'this'.
</font>pushNull(<i>t</i>);

<font color=green>// 3. Push any params.
</font>pushInt(<i>t</i>, 3);

<font color=green>// 4. Call it with the method name.
</font><u>superCall</u>(<i>t</i>, <i>slot</i>, <font color=red>"f"</font>, 0);

<font color=green>// We didn'_t ask for any return values, so the stack is how it was before we began.
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The first empty slot.  There should be another one on top of it.  Then come any parameters.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the method to call.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">numReturns</span></td>

               
<td>How many return values you want.  Can be -1, which means you'll get all returns.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of return values given by the function.  If <span class="funcparam">numReturns</span> was -1, this is exactly how
	many returns the function gave.  If <span class="funcparam">numReturns</span> was &gt;= 0, this is the same as <span class="funcparam">numReturns</span> (and
	not exactly useful since you already know it).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">superCall</span>
<script>explorer.outline.addDecl('superCall');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, int <span class="funcparam">numReturns</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but expects the method name to be at the top of the stack (after the parameters).
<br><br>
The parameters and return value are the same as above.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">setUpval</span>
<script>explorer.outline.addDecl('setUpval');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">idx</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sets an upvalue in the currently-executing closure.  The upvalue is set to the value on top of the
stack, which is popped.
<br><br>
This function will fail if called at top-level (that is, outside of any executing closures).

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">idx</span></td>

               
<td>The index of the upvalue to set.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">getUpval</span>
<script>explorer.outline.addDecl('getUpval');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">idx</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes an upvalue from the currently-executing closure.
<br><br>
This function will fail if called at top-level (that is, outside of any executing closures).

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">idx</span></td>

               
<td>The index of the upvalue to set.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isNull</span>
<script>explorer.outline.addDecl('isNull');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is <b>null</b>.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isBool</span>
<script>explorer.outline.addDecl('isBool');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a bool.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isInt</span>
<script>explorer.outline.addDecl('isInt');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is an int.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isFloat</span>
<script>explorer.outline.addDecl('isFloat');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a float.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isNum</span>
<script>explorer.outline.addDecl('isNum');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is an int or a float.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isChar</span>
<script>explorer.outline.addDecl('isChar');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a char.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isString</span>
<script>explorer.outline.addDecl('isString');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a string.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isTable</span>
<script>explorer.outline.addDecl('isTable');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a table.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isArray</span>
<script>explorer.outline.addDecl('isArray');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is an array.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isFunction</span>
<script>explorer.outline.addDecl('isFunction');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a function.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isObject</span>
<script>explorer.outline.addDecl('isObject');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is an object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isNamespace</span>
<script>explorer.outline.addDecl('isNamespace');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a namespace.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isThread</span>
<script>explorer.outline.addDecl('isThread');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a thread.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isNativeObj</span>
<script>explorer.outline.addDecl('isNativeObj');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the value at the given slot is a native object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isTrue</span>
<script>explorer.outline.addDecl('isTrue');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the truth value of the value at the given slot.  <b>null</b>, <b>false</b>, integer 0, floating point 0.0,
and character '\0' are considered <b>false</b>; everything else is considered <b>true</b>.  This is the same behavior
as within the language.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Type 
<span class="currsymbol">type</span>
<script>explorer.outline.addDecl('type');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the type of the value at the given slot.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushTypeString</span>
<script>explorer.outline.addDecl('pushTypeString');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes the string representation of the type of the value at the given slot.
<br><br>
<b>Returns:</b><br>
The stack index of the newly-pushed string.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">getBool</span>
<script>explorer.outline.addDecl('getBool');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the boolean value at the given slot, or throws an error if it isn't one.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">getInt</span>
<script>explorer.outline.addDecl('getInt');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the integer value at the given slot, or throws an error if it isn't one.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">double 
<span class="currsymbol">getFloat</span>
<script>explorer.outline.addDecl('getFloat');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the float value at the given slot, or throws an error if it isn't one.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">dchar 
<span class="currsymbol">getChar</span>
<script>explorer.outline.addDecl('getChar');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the character value at the given slot, or throws an error if it isn't one.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">dchar[] 
<span class="currsymbol">getString</span>
<script>explorer.outline.addDecl('getString');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the string value at the given slot, or throws an error if it isn't one.
<br><br>
The returned string points into the MiniD heap.  It should NOT be modified in any way.  The returned
array reference should also not be stored on the D heap, as once the string object is removed from the
MiniD stack, there is no guarantee that the string data will be valid (MiniD might collect it, as it
has no knowledge of the reference held by D).  If you need the string value for a longer period of time,
you should dup it.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">Object 
<span class="currsymbol">getNativeObj</span>
<script>explorer.outline.addDecl('getNativeObj');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the native D object at the given slot, or throws an error if it isn't one.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">numExtraVals</span>
<script>explorer.outline.addDecl('numExtraVals');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Finds out how many extra values an object has (see newObject for info on that).  Throws an error
if the value at the given slot isn't an object.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The stack index of the object whose number of values is to be retrieved.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of extra values associated with the given object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushExtraVal</span>
<script>explorer.outline.addDecl('pushExtraVal');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, uint <span class="funcparam">idx</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes the <span class="funcparam">idx</span> th extra value from the object at the given slot.  Throws an error if the value at
the given slot isn't an object, or if the index is out of bounds.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The object whose value is to be retrieved.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">idx</span></td>

               
<td>The index of the extra value to get.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">setExtraVal</span>
<script>explorer.outline.addDecl('setExtraVal');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, uint <span class="funcparam">idx</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pops the value off the top of the stack and places it in the <span class="funcparam">idx</span> th extra value in the object at the
given slot.  Throws an error if the value at the given slot isn't an object, or if the index is out
of bounds.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The object whose value is to be set.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">idx</span></td>

               
<td>The index of the extra value to set.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void[] 
<span class="currsymbol">getExtraBytes</span>
<script>explorer.outline.addDecl('getExtraBytes');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets a void array of the extra bytes associated with the object at the given slot.  If the object has
no extra bytes, returns <b>null</b>.  Throws an error if the value at the given slot isn't an object.
<br><br>
The returned void array points into the MiniD heap, so you should not store the returned reference
anywhere.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The object whose data is to be retrieved.</td></tr>
</table><br>
<b>Returns:</b><br>
A void array of the data, or <b>null</b> if the object has none.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushEnvironment</span>
<script>explorer.outline.addDecl('pushEnvironment');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">depth</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes the environment of a closure on the call stack.
<br><br>
Note that if tailcalls have occurred, environments of certain functions will be unavailable, and attempting
to get them will throw an error.
<br><br>

If the depth you specify if deeper than the call stack, or if there are no functions on the call stack,
the global namespace will be pushed.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">depth</span></td>

               
<td>The depth into the call stack of the closure whose environment to get.  Defaults to 0, which
		means the currently-executing closure.  A depth of 1 would mean the closure which called this
		closure, 2 the closure that called that one etc.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed environment.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushGlobal</span>
<script>explorer.outline.addDecl('pushGlobal');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes a global variable with the given <span class="funcparam">name</span>.  Throws an error if the global cannot be found.
<br><br>
This function respects typical global lookup - that is, it starts at the current
function's environment and goes up the chain.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the global to get.</td></tr>
</table><br>
<b>Returns:</b><br>
The index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">getGlobal</span>
<script>explorer.outline.addDecl('getGlobal');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as pushGlobal, except expects the name of the global to be on top of the stack.  If the value
at the top of the stack is not a string, an error is thrown.  Replaces the name with the value of the
global if found.
<br><br>
<b>Returns:</b><br>
The index of the retrieved value (the stack top).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">setGlobal</span>
<script>explorer.outline.addDecl('setGlobal');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sets a global variable with the given name to the value on top of the stack, and pops that value.
Throws an error if the global cannot be found.  Remember that if this is the first time you are
trying to set the global, you have to use newGlobal instead, just like using a global declaration
in MiniD.
<br><br>
This function respects typical global lookup - that is, it starts at the current function's
environment and goes up the chain.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the global to set.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">setGlobal</span>
<script>explorer.outline.addDecl('setGlobal');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but expects the name of the global to be on the stack just below the value to set.
Pops both the name and the value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">newGlobal</span>
<script>explorer.outline.addDecl('newGlobal');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">name</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Declares a global variable with the given name, sets it to the value on top of the stack, and pops
that value.  Throws an error if the global has already been declared.
<br><br>
This function works just like a global variable declaration in MiniD.  It creates a new entry
in the current environment if it succeeds.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the global to set.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">newGlobal</span>
<script>explorer.outline.addDecl('newGlobal');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but expects the name of the global to be on the stack under the value to be set.  Pops
both the name and the value off the stack.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">findGlobal</span>
<script>explorer.outline.addDecl('findGlobal');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">name</span>, uint <span class="funcparam">depth</span> = cast(uint)0);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Searches for a global of the given name.
<br><br>
By default, this follows normal global lookup, starting with the currently-executing function's environment,
but you can change where the lookup starts by using the <span class="funcparam">depth</span> parameter.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the global to look for.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">depth</span></td>

               
<td>The depth into the call stack of the closure in whose environment lookup should begin.  Defaults
		to 0, which means the currently-executing closure.  A depth of 1 would mean the closure which called
		this closure, 2 the closure that called that one etc.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the global was found, in which case the containing namespace is on the stack.  False otherwise,
	in which case nothing will be on the stack.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">callDepth</span>
<script>explorer.outline.addDecl('callDepth');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Find how many calls deep the currently-executing function is nested.  Tailcalls are taken into account.
<br><br>
If called at top-level, returns 0.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">uint 
<span class="currsymbol">stackSize</span>
<script>explorer.outline.addDecl('stackSize');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns the number of items on the stack.  Valid positive stack indices range from [0 .. stackSize(<span class="funcparam">t</span>).
Valid negative stack indices range from [-stackSize(<span class="funcparam">t</span>) .. 0.
<br><br>
Note that 'this' (stack index 0 or -stackSize(<span class="funcparam">t</span>)) may not be overwritten or changed, although it can be used
with functions that don't modify their argument.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushToString</span>
<script>explorer.outline.addDecl('pushToString');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Push a string representation of any MiniD value onto the stack.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The stack index of the value to convert to a string.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">raw</span></td>

               
<td>If <b>true</b>, will not call toString metamethods.  Defaults to <b>false</b>, which means toString
		metamethods will be called.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed string.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">opin</span>
<script>explorer.outline.addDecl('opin');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">item</span>, int <span class="funcparam">container</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>See if <span class="funcparam">item</span> is in <span class="funcparam">container</span>.  Works like the MiniD 'in' operator.  Calls opIn metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">item</span></td>

               
<td>The item to look for (the lhs of 'in').</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The object in which to look (the rhs of 'in').</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if <span class="funcparam">item</span> is in <span class="funcparam">container</span>, <b>false</b> otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">cmp</span>
<script>explorer.outline.addDecl('cmp');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compare two values at the given indices, and give the comparison value (negative for <span class="funcparam">a</span> &lt; <span class="funcparam">b</span>, positive for <span class="funcparam">a</span> &gt; <span class="funcparam">b</span>,
and 0 if <span class="funcparam">a</span> == <span class="funcparam">b</span>).  This is the exact behavior of the '&lt;=&gt;' operator in MiniD.  Calls opCmp metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">a</span></td>

               
<td>The index of the first object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">b</span></td>

               
<td>The index of the second object.</td></tr>
</table><br>
<b>Returns:</b><br>
The comparison value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">equals</span>
<script>explorer.outline.addDecl('equals');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Test two values at the given indices for equality.  This is the exact behavior of the '==' operator in MiniD.
Calls opEquals metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">a</span></td>

               
<td>The index of the first object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">b</span></td>

               
<td>The index of the second object.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if equal, <b>false</b> otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">opis</span>
<script>explorer.outline.addDecl('opis');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Test two values at the given indices for identity.  This is the exact behavior of the 'is' operator in MiniD.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">a</span></td>

               
<td>The index of the first object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">b</span></td>

               
<td>The index of the second object.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if identical, <b>false</b> otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">idx</span>
<script>explorer.outline.addDecl('idx');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Index the container at the given index with the value at the top of the stack.  Replaces the value on the
stack with the result.  Calls opIndex metamethods.
<br><br>
<pre class="d_code"><font color=green>// x = a[6]
</font><font color=blue>auto</font> cont = pushGlobal(<i>t</i>, <font color=red>"a"</font>);
pushInt(<i>t</i>, 6);
<u>idx</u>(<i>t</i>, cont);
setGlobal(<i>t</i>, <font color=red>"x"</font>);
pop(<i>t</i>);
<font color=green>// The stack is how it was when we started.
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The stack index of the container object.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index that contains the result (the top of the stack).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">idxa</span>
<script>explorer.outline.addDecl('idxa');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Index-assign the container at the given index with the key at the second-from-top of the stack and the
value at the top of the stack.  Pops both the key and the value from the stack.  Calls opIndexAssign
metamethods.
<br><br>
<pre class="d_code"><font color=green>// a[6] = 10
</font><font color=blue>auto</font> cont = pushGlobal(<i>t</i>, <font color=red>"a"</font>);
pushInt(<i>t</i>, 6);
pushInt(<i>t</i>, 10);
<u>idxa</u>(<i>t</i>, cont);
pop(<i>t</i>);
<font color=green>// The stack is how it was when we started.
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The stack index of the container object.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">field</span>
<script>explorer.outline.addDecl('field');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>, dchar[] <span class="funcparam">name</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Get a field with the given name from the container at the given index.  Pushes the result onto the stack.
<br><br>
<pre class="d_code"><font color=green>// x = a.y
</font>pushGlobal(<i>t</i>, <font color=red>"a"</font>);
<u>field</u>(<i>t</i>, -1, <font color=red>"y"</font>);
setGlobal(<i>t</i>, <font color=red>"x"</font>);
pop(<i>t</i>);
<font color=green>// The stack is how it was when we started.
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The stack index of the container object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the field to get.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">raw</span></td>

               
<td>If <b>true</b>, does not call opField metamethods.  Defaults to <b>false</b>, which means it will.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed result.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">field</span>
<script>explorer.outline.addDecl('field');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but expects the field name to be at the top of the stack.  If the value at the top of the
stack is not a string, an error is thrown.  The field value replaces the field name, much like with idx.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The stack index of the container object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">raw</span></td>

               
<td>If <b>true</b>, does not call opField metamethods.  Defaults to <b>false</b>, which means it will.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the retrieved field value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">fielda</span>
<script>explorer.outline.addDecl('fielda');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>, dchar[] <span class="funcparam">name</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sets a field with the given name in the container at the given index to the value at the top of the stack.
Pops that value off the stack.  Calls opFieldAssign metamethods.
<br><br>
<pre class="d_code"><font color=green>// a.y = x
</font><font color=blue>auto</font> cont = pushGlobal(<i>t</i>, <font color=red>"a"</font>);
pushGlobal(<i>t</i>, <font color=red>"x"</font>);
<u>fielda</u>(<i>t</i>, cont, <font color=red>"y"</font>);
pop(<i>t</i>);
<font color=green>// The stack is how it was when we started.
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The stack index of the container object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">name</span></td>

               
<td>The name of the field to set.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">raw</span></td>

               
<td>If <b>true</b>, does not call opFieldAssign metamethods.  Defaults to <b>false</b>, which means it will.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">fielda</span>
<script>explorer.outline.addDecl('fielda');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>, bool <span class="funcparam">raw</span> = false);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Same as above, but expects the field name to be in the second-from-top slot and the value to set at the top of
the stack, similar to idxa.  Throws an error if the field name is not a string.  Pops both the set value and the
field name off the stack, just like idxa.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The stack index of the container object.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">bool <span class="funcparam">raw</span></td>

               
<td>If <b>true</b>, does not call opFieldAssign metamethods.  Defaults to <b>false</b>, which means it will.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushLen</span>
<script>explorer.outline.addDecl('pushLen');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Pushes the length of the object at the given slot.  Calls opLength metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot of the object whose length is to be retrieved.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed length.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">len</span>
<script>explorer.outline.addDecl('len');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the integral length of the object at the given slot.  Calls opLength metamethods.  If the length
of the object is not an integer, throws an error.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot of the object whose length is to be retrieved.</td></tr>
</table><br>
<b>Returns:</b><br>
The length of the object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">lena</span>
<script>explorer.outline.addDecl('lena');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sets the length of the object at the given slot to the value at the top of the stack and pops that
value.  Calls opLengthAssign metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The slot of the object whose length is to be set.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">slice</span>
<script>explorer.outline.addDecl('slice');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Slice the object at the given slot.  The low index is the second-from-top value on the stack, and
the high index is the top value.  Either index can be <b>null</b>.  The indices are popped and the result
of the slice operation is pushed.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The slot of the object to be sliced.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">slicea</span>
<script>explorer.outline.addDecl('slicea');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">container</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Slice-assign the object at the given slot.  The low index is the third-from-top value; the high is
the second-from-top; and the value to assign into the object is on the top.  Either index can be <b>null</b>.
Both indices and the value are popped.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">container</span></td>

               
<td>The slot of the object to be slice-assigned.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">add</span>
<script>explorer.outline.addDecl('add');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">sub</span>
<script>explorer.outline.addDecl('sub');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">mul</span>
<script>explorer.outline.addDecl('mul');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">div</span>
<script>explorer.outline.addDecl('div');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">mod</span>
<script>explorer.outline.addDecl('mod');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These all perform the given mathematical operation on the two values at the given indices, and push
the result of that operation onto the stack.  Metamethods (including reverse versions) will be called.
<br><br>
Don't use these functions if you're looking to do some serious number crunching on ints and floats.  Just
get the values and do the computation in D.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">a</span></td>

               
<td>The slot of the first value.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">b</span></td>

               
<td>The slot of the second value.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed result.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">neg</span>
<script>explorer.outline.addDecl('neg');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Negates the value at the given index and pushes the result.  Calls opNeg metamethods.
<br><br>
Like the binary operations, don't use this unless you need the actual MiniD semantics, as it's
less efficient than just getting a number and negating it.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">o</span></td>

               
<td>The slot of the value to negate.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed result.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">addeq</span>
<script>explorer.outline.addDecl('addeq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">subeq</span>
<script>explorer.outline.addDecl('subeq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">muleq</span>
<script>explorer.outline.addDecl('muleq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">diveq</span>
<script>explorer.outline.addDecl('diveq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">modeq</span>
<script>explorer.outline.addDecl('modeq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These all perform the given reflexive mathematical operation on the value at the given slot, using
the value at the top of the stack for the rhs.  The rhs is popped.  These call metamethods.
<br><br>
Like the other mathematical methods, it's more efficient to perform the operation directly on numbers
rather than to use these methods.  Use these only if you need the MiniD semantics.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">o</span></td>

               
<td>The slot of the object to perform the reflexive operation on.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">and</span>
<script>explorer.outline.addDecl('and');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">or</span>
<script>explorer.outline.addDecl('or');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">xor</span>
<script>explorer.outline.addDecl('xor');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">shl</span>
<script>explorer.outline.addDecl('shl');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">shr</span>
<script>explorer.outline.addDecl('shr');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
<br>int 
<span class="currsymbol">ushr</span>
<script>explorer.outline.addDecl('ushr');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">a</span>, int <span class="funcparam">b</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These all perform the given bitwise operation on the two values at the given indices, and push
the result of that operation onto the stack.  Metamethods (including reverse versions) will be called.
<br><br>
Don't use these functions if you're looking to do some serious number crunching on ints.  Just
get the values and do the computation in D.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">a</span></td>

               
<td>The slot of the first value.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">b</span></td>

               
<td>The slot of the second value.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed result.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">com</span>
<script>explorer.outline.addDecl('com');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Bitwise complements the value at the given index and pushes the result.  Calls opCom metamethods.
<br><br>
Like the binary operations, don't use this unless you need the actual MiniD semantics, as it's
less efficient than just getting a number and complementing it.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">o</span></td>

               
<td>The slot of the value to complement.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed result.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">andeq</span>
<script>explorer.outline.addDecl('andeq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">oreq</span>
<script>explorer.outline.addDecl('oreq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">xoreq</span>
<script>explorer.outline.addDecl('xoreq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">shleq</span>
<script>explorer.outline.addDecl('shleq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">shreq</span>
<script>explorer.outline.addDecl('shreq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
<br>void 
<span class="currsymbol">ushreq</span>
<script>explorer.outline.addDecl('ushreq');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">o</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>These all perform the given reflexive bitwise operation on the value at the given slot, using
the value at the top of the stack for the rhs.  The rhs is popped.  These call metamethods.
<br><br>
Like the other bitwise methods, it's more efficient to perform the operation directly on numbers
rather than to use these methods.  Use these only if you need the MiniD semantics.

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">o</span></td>

               
<td>The slot of the object to perform the reflexive operation on.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">cat</span>
<script>explorer.outline.addDecl('cat');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">num</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Concatenates the top <span class="funcparam">num</span> parameters on the stack, popping them all and pushing the result on the stack.
<br><br>
If <span class="funcparam">num</span> is 1, this function does nothing.  If <span class="funcparam">num</span> is 0, it is an error.  Otherwise, the concatenation
works just like it does in MiniD.
<br><br>

<pre class="d_code"><font color=green>// x = "Hi, " ~ name ~ "!"
</font>pushString(<i>t</i>, <font color=red>"Hi "</font>);
pushGlobal(<i>t</i>, <font color=red>"name"</font>);
pushString(<i>t</i>, <font color=red>"!"</font>);
<u>cat</u>(<i>t</i>, 3);
setGlobal(<i>t</i>, <font color=red>"x"</font>);
</pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">num</span></td>

               
<td>How many values to concatenate.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the resulting object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">cateq</span>
<script>explorer.outline.addDecl('cateq');</script>

(MDThread* <span class="funcparam">t</span>, uint <span class="funcparam">num</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Performs concatenation-assignment.  <span class="funcparam">num</span> is how many values there are on the right-hand side and is expected to
be at least 1.  The RHS values are on the top of the stack.  The destination is the slot immediately before the
RHS values.  Pops the RHS values off the stack, leaving the destination.
<br><br>
<pre class="d_code"><font color=green>// x ~= "Hi, " ~ name ~ "!"
</font>pushGlobal(<i>t</i>, <font color=red>"x"</font>); <font color=green>// destination comes first
</font>pushString(<i>t</i>, <font color=red>"Hi "</font>);
pushGlobal(<i>t</i>, <font color=red>"name"</font>);
pushString(<i>t</i>, <font color=red>"!"</font>);
<u>cateq</u>(<i>t</i>, 3); <font color=green>// 3 rhs values
</font>setGlobal(<i>t</i>, <font color=red>"x"</font>); <font color=green>// value on the stack may be different, so set it
</font></pre>

<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">uint <span class="funcparam">num</span></td>

               
<td>How many values are on the RHS to be appended.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">as</span>
<script>explorer.outline.addDecl('as');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">obj</span>, int <span class="funcparam">proto</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Returns whether or not <span class="funcparam">obj</span> is an 'object' and derives from <span class="funcparam">proto</span>.  Throws an error if <span class="funcparam">proto</span> is not an object.
Works just like the 
<span class="currsymbol">as</span>
<script>explorer.outline.addDecl('as');</script>

 operator in MiniD.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">obj</span></td>

               
<td>The stack index of the value to test.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">proto</span></td>

               
<td>The stack index of the proto object.  Must be an 'object'.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if <span class="funcparam">obj</span> is an 'object' and it derives from <span class="funcparam">proto</span>.  False otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">inc</span>
<script>explorer.outline.addDecl('inc');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Increments the value at the given slot.  Calls opInc metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The stack index of the value to increment.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">dec</span>
<script>explorer.outline.addDecl('dec');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Decrements the value at the given slot.  Calls opDec metamethods.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The stack index of the value to decrement.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">superof</span>
<script>explorer.outline.addDecl('superof');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">slot</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the proto object of objects or the parent namespace of namespaces and pushes it onto the stack.
Throws an error if the value at the given slot is neither an object nor a namespace.  Pushes <b>null</b> if
the object or namespace has no proto or parent.  Works just like "x.super" in MiniD.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">slot</span></td>

               
<td>The stack index of the object or namespace whose proto or parent to get.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">throwException</span>
<script>explorer.outline.addDecl('throwException');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Throw a MiniD exception using the value at the top of the stack as the exception object.  Any type can
be thrown.  This will throw an actual D exception of type MDException as well, which can be caught in D
as normal (<b>Important:</b> see catchException for information on catching them).
<br><br>
You cannot use this function if another exception is still in flight, that is, it has not yet been caught with
catchException.  If you try, an Exception will be thrown -- that is, an instance of the D Exception class.
<br><br>

This function obviously does not return.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">throwException</span>
<script>explorer.outline.addDecl('throwException');</script>

(MDThread* <span class="funcparam">t</span>, dchar[] <span class="funcparam">fmt</span>,...);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A shortcut for the very common case where you want to throw a formatted string.  This is equivalent to calling
pushVFormat on the arguments and then 
<span class="currsymbol">throwException</span>
<script>explorer.outline.addDecl('throwException');</script>

.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">catchException</span>
<script>explorer.outline.addDecl('catchException');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>When catching MiniD exceptions (those derived from MDException) in D, MiniD doesn't know that you've actually caught
one unless you tell it.  If you want to rethrow an exception without seeing what's in it, you can just throw the
D exception object.  But if you want to actually handle the exception, or rethrow it after seeing what's in it,
you <b>must call this function</b>.  This informs MiniD that you have caught the exception that was in flight, and
pushes the exception object onto the stack, where you can inspect it and possibly rethrow it using throwException.
<br><br>
Note that if an exception occurred and you caught it, you might not know anything about what's on the stack.  It
might be garbage from a half-completed operation.  So you might want to store the size of the stack before a 'try'
block, then restore it in the 'catch' block so that the stack will be in a consistent state.
<br><br>

An exception must be in flight for this function to work.  If none is in flight, a MiniD exception is thrown. (For
some reason, that sounds funny.  "Error: there is no error!")

<br><br>
<b>Returns:</b><br>
The stack index of the newly-pushed exception object.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">pushTypeMT</span>
<script>explorer.outline.addDecl('pushTypeMT');</script>

(MDThread* <span class="funcparam">t</span>, Type <span class="funcparam">type</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Push the metatable for the given <span class="funcparam">type</span>.  If the <span class="funcparam">type</span> has no metatable, pushes <b>null</b>.  The <span class="funcparam">type</span> given must be
one of the "normal" types -- the "internal" types are illegal and an error will be thrown.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">Type <span class="funcparam">type</span></td>

               
<td>The <span class="funcparam">type</span> whose metatable is to be pushed.</td></tr>
</table><br>
<b>Returns:</b><br>
The stack index of the newly-pushed value (<b>null</b> if the <span class="funcparam">type</span> has no metatable, or a namespace if it does).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">setTypeMT</span>
<script>explorer.outline.addDecl('setTypeMT');</script>

(MDThread* <span class="funcparam">t</span>, Type <span class="funcparam">type</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sets the metatable for the given <span class="funcparam">type</span> to the namespace or <b>null</b> at the top of the stack.  Throws an
error if the <span class="funcparam">type</span> given is one of the "internal" types, or if the value at the top of the stack is
neither <b>null</b> nor a namespace.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">Type <span class="funcparam">type</span></td>

               
<td>The <span class="funcparam">type</span> whose metatable is to be set.</td></tr>
</table><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">hasField</span>
<script>explorer.outline.addDecl('hasField');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">obj</span>, dchar[] <span class="funcparam">fieldName</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if the object at the stack index `<span class="funcparam">obj</span>` has a field with the given name.  Does not take opField
metamethods into account.  Because of that, only works for tables, objects, and namespaces.  If
the object at the stack index `<span class="funcparam">obj</span>` is not one of those types, always returns <b>false</b>.  If this function
returns <b>true</b>, you are guaranteed that accessing a field of the given name on the given object will
succeed.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">obj</span></td>

               
<td>The stack index of the object to test.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">fieldName</span></td>

               
<td>The name of the field to look up.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the field exists in `<span class="funcparam">obj</span>`; <b>false</b> otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">hasMethod</span>
<script>explorer.outline.addDecl('hasMethod');</script>

(MDThread* <span class="funcparam">t</span>, int <span class="funcparam">obj</span>, dchar[] <span class="funcparam">methodName</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a method can be called on the object at stack index `<span class="funcparam">obj</span>`.  Does not take opMethod metamethods
into account, but does take type metatables into account.  In other words, if you look up a method in
an object and this function returns <b>true</b>, you are guaranteed that calling a method of that name on
that object will succeed.
<br><br>
<b>Params:</b><br>
<table><tr>
<td nowrap valign="top" style="padding-right: 8px">int <span class="funcparam">obj</span></td>

               
<td>The stack index of the obejct to test.</td></tr>
<tr>
<td nowrap valign="top" style="padding-right: 8px">dchar[] <span class="funcparam">methodName</span></td>

               
<td>The name of the method to look up.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the method can be called on `<span class="funcparam">obj</span>`; <b>false</b> otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">printStack</span>
<script>explorer.outline.addDecl('printStack');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Debug mode only.</b>  Print out the contents of the stack to Stdout in the following format:
<br><br>
<pre class="d_code">[xxx:yyyy]: val: type
</pre>

	Where <i>xxx</i> is the absolute stack index; <i>yyyy</i> is the stack index relative to the currently-executing function's
	stack frame (negative numbers for lower slots, 0 is the first slot of the stack frame); <i>val</i> is a raw string
	representation of the value in that slot; and <i>type</i> is the type of that value.
	
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">printCallStack</span>
<script>explorer.outline.addDecl('printCallStack');</script>

(MDThread* <span class="funcparam">t</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd><b>Debug mode only.</b>  Print out the call stack in reverse, starting from the currently-executing function and
	going back, in the following format (without quotes; I have to put them to keep DDoc happy):
<br><br>
<pre class="d_code"><font color=red>"Record: name"</font>
	<font color=red>"Base: base"</font>
	<font color=red>"Saved Top: top"</font>
	<font color=red>"Vararg Base: vargBase"</font>
	<font color=red>"Returns Slot: retSlot"</font>
	<font color=red>"Num Returns: numRets"</font>
</pre>

	Where <i>name</i> is the name of the function at that level; <i>base</i> is the absolute stack index of where this activation
	record's stack frame begins; <i>top</i> is the absolute stack index of the end of its stack frame; <i>vargBase</i> is the
	absolute stack index of where its variadic args (if any) begin; <i>retSlot</i> is the absolute stack index where return
	values (if any) will started to be copied upon that function returning; and <i>numRets</i> being the number of returns that
	the calling function expects it to return (-1 meaning "as many as possible").
	
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Fri Jun 27 20:33:22 2008

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModuleFull("minid.utils");
	explorer.packageExplorer.addModuleFull("minid.vm");
	explorer.packageExplorer.addModuleFull("minid.gc");
	explorer.packageExplorer.addModuleFull("minid.types");
	explorer.packageExplorer.addModuleFull("minid.alloc");
	explorer.packageExplorer.addModuleFull("minid.api");
	explorer.packageExplorer.addModuleFull("minid.interpreter");
	explorer.packageExplorer.addModuleFull("minid.ex");</script>
</body></html>


