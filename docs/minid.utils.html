
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>minid.utils</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("minid.utils");</script>
	<table class="content">
		<tr><td id="docbody"><h1>minid.utils</h1><!-- Generated by Ddoc from minid\utils.d -->
A module holding a variety of utility functions used throughout MiniD.  This
module doesn't (and shouldn't) depend on the rest of the library in any way,
and as such can't hold implementation-specific functionality.  For that, look
in the minid.misc module.
<br><br>
<b>License:</b><br>
Copyright (c) 2007 Jarrett Billingsley
<br><br>

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
<br><br>

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:
<br><br>

    1. The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software in a
	product, an acknowledgment in the product documentation would be
	appreciated but is not required.
<br><br>

    2. Altered source versions must be plainly marked as such, and must not
	be misrepresented as being the original software.
<br><br>

    3. This notice may not be removed or altered from any source distribution.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">alias 
<span class="currsymbol">mdfloat</span>
<script>explorer.outline.addDecl('mdfloat');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>This alias defines what the MiniD 'float' type uses.  By default and according to the MiniD spec, it's double, but if you don't need
the extra precision and want to save some space/speed in the MiniD struct, you can alias it to float instead.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isStringType</span>
<script>explorer.outline.addDecl('isStringType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Metafunction to see if a given type is one of char[], wchar[] or dchar[].
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isCharType</span>
<script>explorer.outline.addDecl('isCharType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a type is char, wchar, or dchar.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isIntType</span>
<script>explorer.outline.addDecl('isIntType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a type is a signed or unsigned byte, short, int, or long.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isFloatType</span>
<script>explorer.outline.addDecl('isFloatType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a type is float, double, or real.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isArrayType</span>
<script>explorer.outline.addDecl('isArrayType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a type is an array.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isAAType</span>
<script>explorer.outline.addDecl('isAAType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a type is an associative array.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isPointerType</span>
<script>explorer.outline.addDecl('isPointerType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Sees if a type is a pointer.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">realType</span>
<script>explorer.outline.addDecl('realType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Get to the bottom of any chain of typedefs!  Returns the first non-typedef'ed type.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">hasUnions</span>
<script>explorer.outline.addDecl('hasUnions');</script>

(T,uint Idx = 0)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Determine if a given aggregate type contains any unions, explicit or anonymous.
Thanks to Frits van Bommel for the original code.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">Compare3</span>
<script>explorer.outline.addDecl('Compare3');</script>

(T)(T <span class="funcparam">a</span>, T <span class="funcparam">b</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compare two values, a and b, using &lt; and &gt;.  Returns -1 if a &lt; b, 1 if a &gt; b, and 0 otherwise.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">dcmp</span>
<script>explorer.outline.addDecl('dcmp');</script>

(dchar[] <span class="funcparam">s1</span>, dchar[] <span class="funcparam">s2</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compares dchar[] strings stupidly (just by character value, not lexicographically).
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">int 
<span class="currsymbol">idcmp</span>
<script>explorer.outline.addDecl('idcmp');</script>

(dchar[] <span class="funcparam">s1</span>, dchar[] <span class="funcparam">s2</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Compares dchar[] strings stupidly, but case-insensitively.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">isValidUniChar</span>
<script>explorer.outline.addDecl('isValidUniChar');</script>

(dchar <span class="funcparam">c</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>See if a given Unicode character is valid.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">FOURCC</span>
<script>explorer.outline.addDecl('FOURCC');</script>

(char[] name)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Make a 
<span class="currsymbol">FOURCC</span>
<script>explorer.outline.addDecl('FOURCC');</script>

 code out of a four-character string.  This is I guess for little-endian platforms..
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">MakeVersion</span>
<script>explorer.outline.addDecl('MakeVersion');</script>

(uint major,uint minor)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Make a version with the major number in the upper 16 bits and the minor in the lower 16 bits.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">const uint 
<span class="currsymbol">MiniDVersion</span>
<script>explorer.outline.addDecl('MiniDVersion');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The current version of MiniD.  (this is kind of buried here)
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">isInvalidSerializeType</span>
<script>explorer.outline.addDecl('isInvalidSerializeType');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>See if T is a type that can't be automatically serialized.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">enum 
<span class="currsymbol">SerializeMethod</span>
<script>explorer.outline.addDecl('SerializeMethod');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The different ways data can be serialized and deserialized.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">TypeSerializeMethod</span>
<script>explorer.outline.addDecl('TypeSerializeMethod');</script>

(T)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a type, determine how to serialize or deserialize a value of that type.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">Serialize</span>
<script>explorer.outline.addDecl('Serialize');</script>

(T)(IWriter <span class="funcparam">s</span>, T <span class="funcparam">value</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Write out a value to a stream.  This will automatically write out nested arrays and entire structures.
Pointers, functions, delegates, interfaces, unions, and AAs can't be serialized.
<br><br>
For arrays, it will try to write the biggest chunks at a time possible.  So if you write out an int[],
or an S[] where S is a struct type marked as SerializeAsChunk, it will write out all the data in the
array at once.  Otherwise, it'll write out the array element-by-element.
<br><br>

For structs, the following methods are tried:
<ol><li>If the struct has both "void serialize(IWriter)" and "static T deserialize(IReader)" methods,
	   
<span class="currsymbol">Serialize</span>
<script>explorer.outline.addDecl('Serialize');</script>

/Deserialize will call those.</li>
	<li>If the struct has a "const bool SerializeAsChunk = <b>true</b>" declaration in the struct, then it will
	   serialize instances of the struct as chunks of memory.</li>
	<li>As a last resort, it will try to write out the struct member-by-member.  If the struct has any
	   unions (explicit or anonymous), the struct will not be able to be automatically serialized, and
	   you will either have to make it chunk-serializable or provide custom serialization methods.</li>
</ol>
<br><br>

For classes, it will expect for there to be custom serialize/deserialize methods.
<br><br>

For all other types, it will just write them out.  All other types are also considered chunk-serializable,
so arrays of them will be serialized in one call.
<br><br>

If your struct or class declares custom serialize/deserialize methods, it must declare both or neither.
These methods must always follow the form:
<br><br>

<pre class="d_code"><font color=blue>void</font> serialize(IWriter);
<font color=blue>static</font> T deserialize(IReader);
</pre>

where T is your custom type.
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">void 
<span class="currsymbol">Deserialize</span>
<script>explorer.outline.addDecl('Deserialize');</script>

(T)(IReader <span class="funcparam">s</span>, out T <span class="funcparam">dest</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The opposite of Serialize().  The same rules apply here as with Serialize().
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">class 
<span class="currsymbol">Profiler</span>
<script>explorer.outline.addDecl('Profiler');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>A class used for profiling pieces of code.  You initialize it with an output filename,
and during execution of your program, you just create instances of this class with a
certain name.  Timings for each profile name are accumulated over the course of the program and
the final output will show the name of the profile, how many times it was instanced, the
total time in milliseconds, and the average time per instance in milliseconds.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">struct 
<span class="currsymbol">List</span>
<script>explorer.outline.addDecl('List');</script>

(T);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Just a simple list type for building up arrays a little more efficiently.  I know, the runtime automatically
over-allocates for arrays, but I don't like relying on implementation-specific features.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">NameOfFunc</span>
<script>explorer.outline.addDecl('NameOfFunc');</script>

(alias f)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Gets the name of a function alias.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">QSort</span>
<script>explorer.outline.addDecl('QSort');</script>

(alias Pred,List...)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Given a predicate template and a tuple, sorts the tuple.  I'm not sure how quick it is, but it's probably fast enough
for sorting most tuples, which hopefully won't be that long.  The predicate template should take two parameters of the
same type as the tuple's elements, and return &lt;0 for A &lt; B, 0 for A == B, and &gt;0 for A &gt; B (just like opCmp).
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">ToUTF8</span>
<script>explorer.outline.addDecl('ToUTF8');</script>

(char[] s)<br>template 
<span class="currsymbol">ToUTF8</span>
<script>explorer.outline.addDecl('ToUTF8');</script>

(wchar[] s)<br>template 
<span class="currsymbol">ToUTF8</span>
<script>explorer.outline.addDecl('ToUTF8');</script>

(dchar[] s)<br>template 
<span class="currsymbol">ToUTF16</span>
<script>explorer.outline.addDecl('ToUTF16');</script>

(char[] s)<br>template 
<span class="currsymbol">ToUTF16</span>
<script>explorer.outline.addDecl('ToUTF16');</script>

(wchar[] s)<br>template 
<span class="currsymbol">ToUTF16</span>
<script>explorer.outline.addDecl('ToUTF16');</script>

(dchar[] s)<br>template 
<span class="currsymbol">ToUTF32</span>
<script>explorer.outline.addDecl('ToUTF32');</script>

(char[] s)<br>template 
<span class="currsymbol">ToUTF32</span>
<script>explorer.outline.addDecl('ToUTF32');</script>

(wchar[] s)<br>template 
<span class="currsymbol">ToUTF32</span>
<script>explorer.outline.addDecl('ToUTF32');</script>

(dchar[] s)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Convert string literals between unicode encodings at compile time.  I swear, this should be
built into the compiler or something.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">template 
<span class="currsymbol">Itoa</span>
<script>explorer.outline.addDecl('Itoa');</script>

(int i)</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>Convert an integer to a string at compile time.
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl></dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">bool 
<span class="currsymbol">startsWith</span>
<script>explorer.outline.addDecl('startsWith');</script>

(T)(T[] <span class="funcparam">string</span>, T[] <span class="funcparam">pattern</span>);
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>See if a string starts with another string.  Useful.
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Thu Feb 14 15:53:05 2008

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModuleFull("minid.minid");
	explorer.packageExplorer.addModuleFull("minid.types");
	explorer.packageExplorer.addModuleFull("minid.compiler");
	explorer.packageExplorer.addModuleFull("minid.utils");
	explorer.packageExplorer.addModuleFull("minid.bind");</script>
</body></html>


