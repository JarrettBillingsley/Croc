<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module serialization</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("serialization");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module serialization</h1><p>This module contains a powerful means of serializing arbitrary Croc object graphs to and from streams.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="serializeGraph"></a>global function serializeGraph(val, transients: table|instance, output: @OutStream)<script>explorer.outline.addDecl('serializeGraph');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Serializes an arbitrary graph of Croc objects rooted by <tt>val</tt> to the stream <tt>output</tt>.</p><p>This serialization method is flexible and thorough; almost every type can be serialized, and there is no limit to the complexity of the object graph. Cycles are handled, and each object will be serialized exactly once. When deserialized, the object graph will be exactly as it was when it was serialized.</p><p>The following types (or specific kinds of values) can't be serialized: <ul><li><p>The <tt>nativeobj</tt> type. It wouldn't even make sense to.</p></li><li><p><tt>memblock</tt>s which don't own their data.</p></li><li><p>Native <tt>function</tt> objects.</p></li><li><p><tt>class</tt> and <tt>instance</tt> objects which have finalizers.</p></li><li><p>The <tt>thread</tt> type. This was serializable in an earlier version, but changes to the VM have made it much more difficult to do so. It may not be made serializable again, since there are considerable safety risks in doing so.</p></li></ul></p><p><strong>The Format</strong></p><p>When you use <tt>serializeGraph</tt>, it first writes a small, 5-byte signature to <tt>stream</tt> as follows:</p><p><ol type="1"><li><p>The endianness of the machine that serialized this data (1 for big-endian, 0 for little-endian).</p></li><li><p>The bit size of a native word on the machine that serialized this data (like 32 or 64).</p></li><li><p>The byte size of a Croc int. This is to detect nonstandard implementations which redefine it.</p></li><li><p>The byte size of a Croc float, for the same reason.</p></li><li><p>The current serial format version. This changes each time the serial object format is changed.</p></li></ol></p><p>For example, on a 32-bit Intel machine with a stock Croc implementation, this signature would be <tt>[0, 32, 8, 8, n]</tt>, where <em>n</em> is the serial version.</p><p>When this stream is deserialized, it compares the values in the signature to what it expects. Currently if the signature differs at all from what was expected, the deserialization fails, but this could change in the future (by, for example, byte-swapping if the endianness is different, or loading older versions of the serial format).</p><p>After the signature comes the actual data. Maybe I'll document this more fully sometime! But the general idea is that reference types are only serialized once each, and when they are encountered for the second and subsequent times, the serializer encodes a "backreference" to the object, which is an index into a list of reference objects which is built up as they are encountered. Also, integers are encoded with a variable-length representation since most ints are small and using a full 8 bytes for each is wasteful.</p><p><strong>Serializing Multiple Objects</strong></p><p>In general, this is bad:</p><p><div class="code"><pre><span class="n">serialization</span><span class="p">.</span><span class="n">serializeGraph</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">serialization</span><span class="p">.</span><span class="n">serializeGraph</span><span class="p">(</span><span class="n">obj2</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
It's bad because if there is some object <tt>dup</tt> that is pointed to by both <tt>obj1</tt> and <tt>obj2</tt>, when these two object graphs are deserialized, there will be duplicates of <tt>dup</tt> instead of both graphs pointing to the same object.</p><p>Instead, just lump all the objects you want to serialize into a single object, like an array:</p><p><div class="code"><pre><span class="n">serialization</span><span class="p">.</span><span class="n">serializeGraph</span><span class="p">([</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">],</span> <span class="n">trans</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<strong>The Transients Table</strong></p><p>For these unserializable types (and for any value that appears in the object graph that you don't want to be serialized) there is the <em>transients table</em>. The transients table can be an actual table, or an instance which implements <tt>opIndex</tt>. This table is consulted each time any value is serialized as follows: the table is indexed with the value to be serialized. If the table returns null for that value, the value is serialized as normal. But if the table returns any non-null value, that value is serialized in the original value's place. This way, you can serialize references to things which can't otherwise be serialized, and upon deserialization, you use an inverse transients table to map back from the "reference values" to the actual values.</p><p>Because of the way the transients table works, it should be a one-to-one mapping; that is, no two input values should give the same output value, or else terrible things will happen upon deserialization. (Objects won't point to the right things.)</p><p>Furthermore, it's your responsibility to make sure that the values returned by the transients table are actually serializable, and won't cause an infinite loop. That is, a transients table of <tt>{{[1] = 2, [2] = 1</tt>} is invalid, as trying to serialize either 1 or 2 will cause the serializer to go into an infinite loop by getting the replacement value for 1, then the replacement value for 2, then 1 again, and so on.</p><p><strong>Custom Instance Serialization</strong></p><p>By default, when a class instance is serialized, its fields (and hidden fields) are all written out as key-value pairs. This isn't always what you want, as there are often fields which shouldn't be serialized, unserializable native fields, and so on. Trying to deal with this all through the transients table isn't the easiest thing, so instances provide another kind of serialization.</p><p>When an instance is serialized, it's first checked for any field or method named <tt>"opSerialize"</tt>. If one exists, it must be a bool or function, or else an exception will be thrown.</p><p>If it's a bool, <tt>true</tt> means serialize it like normal, and <tt>false</tt> means that this instance is unserializable, and an exception will be thrown.</p><p>If it's a function, it will be called as a method of the instance with two parameters: the first is a reference to the output stream that was passed to <tt>serializeGraph</tt>, and the second is a serialize callback function. The callback function takes one parameter, a value to be serialized, and serializes it normally. The output stream is passed to <tt>opSerialize</tt> in case you want to embed raw data in the output stream.</p><p>As an example, the <a href="misc.html#Vector">Vector</a> class provides an <tt>opSerialize</tt> method which would look something like this if it were written in Croc:</p><p><div class="code"><pre><span class="k">function</span> <span class="n">opSerialize</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ser</span><span class="p">:</span> <span class="k">function</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ser</span><span class="p">(:</span><span class="n">itemType</span><span class="p">())</span>
	<span class="n">ser</span><span class="p">(:</span><span class="n">getMemblock</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
<tt>opSerialize</tt> is meant to work with a matching <tt>opDeserialize</tt>, which is explained in <a href="serialization.html#deserializeGraph">deserializeGraph</a>.</p><p><strong>Examples:</strong> <p>Here is a very simple example which writes a simple array to a memblock stream, and then deserializes it from the same stream.</p><p><div class="code"><pre><span class="c1">// Uses null, bool, int, float, string, and array types.</span>
<span class="k">local</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">null</span><span class="p">]]</span>

<span class="k">local</span> <span class="n">mbs</span> <span class="p">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">MemblockStream</span><span class="p">()</span>

<span class="c1">// nothing non-serializable in arr, so the transients table is empty</span>
<span class="n">serialization</span><span class="p">.</span><span class="n">serializeGraph</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">{},</span> <span class="n">mbs</span><span class="p">)</span>

<span class="c1">// At this point, mbs has some data in it. Let&#39;s rewind to the beginning of the stream and deserialize</span>
<span class="n">mbs</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>

<span class="k">local</span> <span class="n">newArr</span> <span class="p">=</span> <span class="n">serialization</span><span class="p">.</span><span class="n">deserializeGraph</span><span class="p">({},</span> <span class="n">mbs</span><span class="p">)</span>

<span class="c1">// This prints [1, 2.3, &quot;hi&quot;, [true, null]]</span>
<span class="c1">// But note that newArr is a totally different object from arr!</span>
<span class="n">dumpVal</span><span class="p">(</span><span class="n">newArr</span><span class="p">)</span>
</pre></div>
Here's a small example that shows how to use the transients table to avoid serializing some object.</p><p><div class="code"><pre><span class="c1">// The Vector class has an opSerialize method, but if you try to serialize instances of it without putting Vector</span>
<span class="c1">// in the transients table, you&#39;ll get an error (since it tries to serialize the native methods of class Vector).</span>
<span class="c1">// So let&#39;s put Vector into the transients table.</span>

<span class="k">local</span> <span class="n">transients</span> <span class="p">=</span> <span class="p">{[</span><span class="n">Vector</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Vector&quot;</span><span class="p">}</span>
<span class="k">local</span> <span class="n">mbs</span> <span class="p">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">MemblockStream</span><span class="p">(</span><span class="n">mb</span><span class="p">)</span>
<span class="n">serialization</span><span class="p">.</span><span class="n">serializeGraph</span><span class="p">(</span><span class="n">Vector</span><span class="p">.</span><span class="n">fromArray</span><span class="p">(</span><span class="s">&quot;i8&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">transients</span><span class="p">,</span> <span class="n">mbs</span><span class="p">)</span>
<span class="n">mbs</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>

<span class="c1">// Here we&#39;re just inverting the transients table from before, so it maps from the reference values to the real ones.</span>
<span class="k">local</span> <span class="n">revTransients</span> <span class="p">=</span> <span class="p">{[</span><span class="n">v</span><span class="p">]</span> <span class="p">=</span> <span class="n">k</span> <span class="k">foreach</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="n">transients</span><span class="p">}</span>
<span class="k">local</span> <span class="n">a</span> <span class="p">=</span> <span class="n">serialization</span><span class="p">.</span><span class="n">deserializeGraph</span><span class="p">(</span><span class="n">revTransients</span><span class="p">,</span> <span class="n">mbs</span><span class="p">)</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// prints Vector(i8)[1, 2, 3]</span>
</pre></div>
Building the transients table yourself can be a bit tedious, so there are some helper functions in this module for common cases.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>is the object graph to be serialized.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">transients</td><td><p>is the transients table.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">output</td><td><p>is the stream to which the data will be written. This will be passed to any instances' <tt>opSerialize</tt> methods as explained above.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if an unserializable value is encountered in the object graph.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#TypeError">TypeError</a></td><td><p>if an unserializable type is encountered in the object graph.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="deserializeGraph"></a>global function deserializeGraph(transients: table|instance, input: @InStream)<script>explorer.outline.addDecl('deserializeGraph');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The inverse of <a href="serialization.html#serializeGraph">serializeGraph</a>. This reads an object graph from a stream and returns the reconstructed graph.</p><p>Most of the details have been covered already in the docs for <a href="serialization.html#serializeGraph">serializeGraph</a>.</p><p><strong>Custom Instance Deserialization</strong></p><p>If a class instance used an <tt>opSerialize</tt> method to serialize itself, it must have a matching <tt>opDeserialize</tt> method when being deserialized. When deserializing such an instance, it is created and its fields are all set to <tt>null</tt>; then the <tt>opDeserialize</tt> method is called on it. This method takes two parameters: the first is a reference to the input stream that was passed to <tt>deserializeGraph</tt>, and the second is a deserialization function. This function takes an optional string parameter which indicates the type of value to be expected. If no type is passed, a single value of any type will be deserialized.</p><p>As an example, the <a href="misc.html#Vector">Vector</a> class provides an <tt>opDeserialize</tt> method which would look something like this if it were written in Croc:</p><p><div class="code"><pre><span class="k">function</span> <span class="n">opDeserialize</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">deser</span><span class="p">:</span> <span class="k">function</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">local</span> <span class="n">type</span> <span class="p">=</span> <span class="n">deser</span><span class="p">(</span><span class="s">&quot;string&quot;</span><span class="p">)</span>

	<span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="n">not</span> <span class="k">in</span> <span class="n">validTypes</span><span class="p">)</span>
		<span class="k">throw</span> <span class="n">ValueError</span><span class="p">(</span><span class="s">&quot;Malformed data: invalid Vector type code &#39;{}&#39;&quot;</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>

	<span class="k">local</span> <span class="n">data</span> <span class="p">=</span> <span class="n">deser</span><span class="p">(</span><span class="s">&quot;memblock&quot;</span><span class="p">)</span>

	<span class="c1">// here it sets the members appropriately</span>
<span class="p">}</span>
</pre></div>
Note how it passes the names of types to the <tt>deser</tt> function to ensure that the proper types of values are deserialized from the stream. If it just called <tt>deser()</tt>, it would deserialize any type.</p><p>When implementing custom deserialization like this, be sure to check the validity of the data that you deserialize! Data can be tampered with or corrupted and you don't want to end up with objects in invalid states.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">transients</td><td><p>is the transients table, except it should be inverted from the one you pass to <a href="serialization.html#serializeGraph">serializeGraph</a>. That is, the reference values should be the keys, and the values they stand for should be the values.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">input</td><td><p>is the stream from which the data will be read.</p></td></tr></table><p><strong>Returns:</strong> <p>the reconstructed object graph.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="serializeModule"></a>global function serializeModule(mod: funcdef, name: string, output: @OutStream)<script>explorer.outline.addDecl('serializeModule');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Serializes a just-compiled funcdef as a module. All this does is package up the funcdef along with its name, to be read back out with <a href="serialization.html#deserializeModule">deserializeModule</a>.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mod</td><td><p>should be a funcdef with no upvalues that has not yet been closed. In other words, this is what you get from compiling a source code module.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">name</td><td><p>should be the name of the module, as was extracted from the module source by the compiler.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">output</td><td><p>is the stream to which the module will be serialized.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="deserializeModule"></a>global function deserializeModule(input: @InStream)<script>explorer.outline.addDecl('deserializeModule');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The inverse of <a href="serialization.html#serializeModule">serializeModule</a>, this deserializes a module and checks that the types are proper.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">input</td><td><p>is the stream from which the module will be serialized.</p></td></tr></table><p><strong>Returns:</strong> <p>two values: the module's top-level funcdef, and the module's name.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="makeTransientsFromModules"></a>global function makeTransientsFromModules(whichModules: string, recursion: string, mode: string)<script>explorer.outline.addDecl('makeTransientsFromModules');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructs a transients table which prevents module namespaces (and optionally the globals within them) from being serialized.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">whichModules</td><td><p>should be either <tt>"all"</tt> or <tt>"std"</tt>. If it's <tt>"all"</tt>, it will go through all the modules in <a href="modules.html#loaded">modules.loaded</a> and add them to the returned table. If it's <tt>"std"</tt>, only the standard library (and addon modules) will be added. Also, the global namespace (<tt>_G</tt>) is always added.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">recursion</td><td><p>should be one of <tt>"none"</tt>, <tt>"globals"</tt>, and <tt>"all"</tt>. If it's <tt>"none"</tt>, only the module namespaces themselves are added to the table. If it's <tt>"globals"</tt>, the module namespaces and their global variables which hold nameable values (that is, classes, namespaces, and functions) are added. If it's <tt>"all"</tt>, the previous will be added, as well as methods inside global classes and namespaces.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mode</td><td><p>should be either <tt>"s"</tt> to construct a serialization transients table, or <tt>"d"</tt> to construct a deserialization table. The difference between these two modes is that the keys and values are swapped.</p></td></tr></table><p><strong>Returns:</strong> <p>a table. The "reference values" will be strings of the form <tt>"!!global &lt;fully qualified name&gt;"</tt>, where &lt;fully qualified name&gt; is the full name of the object it replaces. For example, the <a href="string.html#StringBuffer">string.StringBuffer</a> class would have a reference value of <tt>"!!global string.StringBuffer"</tt>, and its constructor would have a reference value of <tt>"!!global string.StringBuffer.constructor"</tt>. The exception to this rule is the <tt>_G</tt> namespace, which has a reference value of <tt>"!!global _G"</tt>.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 12 Oct 2014 15:09:57	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("misc");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>