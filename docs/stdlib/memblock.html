<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module memblock</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("memblock");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module memblock</h1><p>The memblock library provides built-in methods for the <tt>memblock</tt> type, as well as the only means to actually create memblocks.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="new"></a>global function new(size: int, fill: int = 0)<script>explorer.outline.addDecl('new');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Creates a new memblock.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">size</td><td><p>is the size of the memblock to create, in bytes. Can be 0.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">fill</td><td><p>is the value to fill each byte of the memblock with. Defaults to 0. The value will be wrapped to the range of an unsigned byte.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>size</tt> is invalid (negative or too large to be represented).</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="fromArray"></a>global function fromArray(arr: array)<script>explorer.outline.addDecl('fromArray');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Creates a new memblock using the contents of the array as the data.</p><p>The new memblock will be the same length as the array. The array must hold nothing but integers. They are not required to be in the range <tt>[0 .. 255]</tt>; just the lower 8 bits will be used from each integer.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">arr</td><td><p>is the array holding the data from which the memblock will be constructed.</p></td></tr></table><p><strong>Returns:</strong> <p>the new memblock.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#TypeError">TypeError</a></td><td><p>if <tt>arr</tt> has any non-integer elements.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock"></a>namespace memblock<script>explorer.outline.addDecl('memblock');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is the method namespace for memblock objects.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.toString"></a>function memblock.toString()<script>explorer.outline.addDecl('memblock.toString');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a string representation of this memblock in the form <tt>"memblock[contents]"</tt>.</p><p>For example, <tt>memblock.new(3, 10).toString()</tt> would give the string <tt>"memblock[10, 10, 10]"</tt>.</p><p>If the memblock is more than 128 bytes, the contents will be truncated with an ellipsis.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.dup"></a>function memblock.dup()<script>explorer.outline.addDecl('memblock.dup');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a duplicate of this memblock.</p><p>The new memblock will have the same length and this memblock's data will be copied into it. The new memblock will own its data, regardless of whether or not this memblock does.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.ownData"></a>function memblock.ownData()<script>explorer.outline.addDecl('memblock.ownData');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a bool indicating whether or not this memblock owns its data. If true, it can be resized freely.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.fill"></a>function memblock.fill(val: int)<script>explorer.outline.addDecl('memblock.fill');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Fills every byte of this memblock with the given value (wrapped to the range of an unsigned byte).</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>is the value to fill the memblock with.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.fillSlice"></a>function memblock.fillSlice(lo: int = 0, hi: int = #this, val: int)<script>explorer.outline.addDecl('memblock.fillSlice');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Fills a slice of this memblock with the given value (wrapped to the range of an unsigned byte). The slice indices work exactly like anywhere else.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">lo</td><td><p></p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">hi</td><td><p></p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>is the value to fill the slice with.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.readInt8"></a>function memblock.readInt8(offs: int)<script>explorer.outline.addDecl('memblock.readInt8');</script></span><br/><span class="decl"><a id="memblock.readInt16"></a>function memblock.readInt16(offs: int)<script>explorer.outline.addDecl('memblock.readInt16');</script></span><br/><span class="decl"><a id="memblock.readInt32"></a>function memblock.readInt32(offs: int)<script>explorer.outline.addDecl('memblock.readInt32');</script></span><br/><span class="decl"><a id="memblock.readInt64"></a>function memblock.readInt64(offs: int)<script>explorer.outline.addDecl('memblock.readInt64');</script></span><br/><span class="decl"><a id="memblock.readUInt8"></a>function memblock.readUInt8(offs: int)<script>explorer.outline.addDecl('memblock.readUInt8');</script></span><br/><span class="decl"><a id="memblock.readUInt16"></a>function memblock.readUInt16(offs: int)<script>explorer.outline.addDecl('memblock.readUInt16');</script></span><br/><span class="decl"><a id="memblock.readUInt32"></a>function memblock.readUInt32(offs: int)<script>explorer.outline.addDecl('memblock.readUInt32');</script></span><br/><span class="decl"><a id="memblock.readUInt64"></a>function memblock.readUInt64(offs: int)<script>explorer.outline.addDecl('memblock.readUInt64');</script></span><br/><span class="decl"><a id="memblock.readFloat32"></a>function memblock.readFloat32(offs: int)<script>explorer.outline.addDecl('memblock.readFloat32');</script></span><br/><span class="decl"><a id="memblock.readFloat64"></a>function memblock.readFloat64(offs: int)<script>explorer.outline.addDecl('memblock.readFloat64');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These functions all read a numerical value of the given type from the byte offset <tt>offs</tt>.</p><p>The "Int" versions read a signed integer of the given number of bits. The "Uint" versions read an unsigned integer of the given number of bits. Note that <tt>readUInt64</tt> will return the same values as <tt>readInt64</tt> as Croc's <tt>int</tt> type is a signed 64-bit integer, and thus cannot represent the range of unsigned 64-bit integers. It is included for completeness.</p><p>The "Float" versions read an IEEE 754 floating point number. <tt>readFloat32</tt> reads a single-precision float while <tt>readFloat64</tt> reads a double-precision float.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">offs</td><td><p>is the byte offset from where the value should be read. Can be negative to mean from the end of the memblock. Does not have to be aligned.</p></td></tr></table><p><strong>Returns:</strong> <p>the value read, as either an <tt>int</tt> or a <tt>float</tt>, depending on the function.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>offs &lt; 0 || offs &gt;= #this - (size of value)</tt>.</p></td></tr></table><p><strong>See:</strong> <p><a href="misc.html#Vector">Vector</a> for a typed numerical array type which may suit your needs better than raw memblock access.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.writeInt8"></a>function memblock.writeInt8(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeInt8');</script></span><br/><span class="decl"><a id="memblock.writeInt16"></a>function memblock.writeInt16(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeInt16');</script></span><br/><span class="decl"><a id="memblock.writeInt32"></a>function memblock.writeInt32(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeInt32');</script></span><br/><span class="decl"><a id="memblock.writeInt64"></a>function memblock.writeInt64(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeInt64');</script></span><br/><span class="decl"><a id="memblock.writeUInt8"></a>function memblock.writeUInt8(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeUInt8');</script></span><br/><span class="decl"><a id="memblock.writeUInt16"></a>function memblock.writeUInt16(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeUInt16');</script></span><br/><span class="decl"><a id="memblock.writeUInt32"></a>function memblock.writeUInt32(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeUInt32');</script></span><br/><span class="decl"><a id="memblock.writeUInt64"></a>function memblock.writeUInt64(offs: int, val: int)<script>explorer.outline.addDecl('memblock.writeUInt64');</script></span><br/><span class="decl"><a id="memblock.writeFloat32"></a>function memblock.writeFloat32(offs: int, val: int|float)<script>explorer.outline.addDecl('memblock.writeFloat32');</script></span><br/><span class="decl"><a id="memblock.writeFloat64"></a>function memblock.writeFloat64(offs: int, val: int|float)<script>explorer.outline.addDecl('memblock.writeFloat64');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These functions all write the numerical value <tt>val</tt> of the given type to the byte offset <tt>offs</tt>.</p><p>The "Int" versions write a signed integer of the given number of bits. The "Uint" versions write an unsigned integer of the given number of bits. Note that <tt>writeUInt64</tt> will in fact write an unsigned 64-bit integer, even though Croc's <tt>int</tt> type is a signed 64-bit integer.</p><p>The "Float" versions write an IEEE 754 floating point number. <tt>writeFloat32</tt> writes a single-precision float while <tt>writeFloat64</tt> writes a double-precision float.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">offs</td><td><p>the byte offset to which the value should be written. Can be negative to mean from the end of the memblock.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>the value to write.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>offs &lt; 0 || offs &gt;= #this - (size of value)</tt>.</p></td></tr></table><p><strong>See:</strong> <p><a href="misc.html#Vector">Vector</a> for a typed numerical array type which may suit your needs better than raw memblock access.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.findByte"></a>function memblock.findByte(val: int, start: int = 0)<script>explorer.outline.addDecl('memblock.findByte');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Find a byte equal to <tt>val</tt> in this memblock starting at byte offset <tt>start</tt> and going right.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>is the byte to search for.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">start</td><td><p>is the byte offset to start at, which defaults to 0.</p></td></tr></table><p><strong>Returns:</strong> <p>the byte offset of the first byte equal to <tt>val</tt> found, or <tt>#this</tt> if not found.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>val &lt; 0 || val &gt; 255</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>start</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.rfindByte"></a>function memblock.rfindByte(val: int, start: int = #this - 1)<script>explorer.outline.addDecl('memblock.rfindByte');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Find a byte equal to <tt>val</tt> in this memblock starting at byte offset <tt>start</tt> and going left.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>is the byte to search for.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">start</td><td><p>is the byte offset to start at, which defaults to the last byte.</p></td></tr></table><p><strong>Returns:</strong> <p>the byte offset of the first byte equal to <tt>val</tt> found, or <tt>#this</tt> if not found.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>val &lt; 0 || val &gt; 255</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>start</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.findBytes"></a>function memblock.findBytes(sub: memblock, start: int = 0)<script>explorer.outline.addDecl('memblock.findBytes');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as <a href="memblock.html#memblock.findByte">findByte</a>, except searches for a sequence of bytes identical to the memblock <tt>sub</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.rfindBytes"></a>function memblock.rfindBytes()<script>explorer.outline.addDecl('memblock.rfindBytes');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as <a href="memblock.html#memblock.rfindByte">rfindByte</a>, except searches for a sequence of bytes identical to the memblock <tt>sub</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.copy"></a>function memblock.copy(dstOffs: int, src: memblock, srcOffs: int, size: int)<script>explorer.outline.addDecl('memblock.copy');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Copies a block of memory from one memblock to another, or within the same memblock. Also handles overlapping copies. Croc's version of memcpy/memmove!</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">dstOffs</td><td><p>is the byte offset in this memblock to where the data should be copied. May <strong>not</strong> be negative.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">src</td><td><p>is the memblock from which the data should be copied. Can be the same memblock as <tt>this</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">srcOffs</td><td><p>is the byte offset in the source memblock from which the data should be copied. May <strong>not</strong> be negative.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">size</td><td><p>is the number of bytes to copy. 0 is an acceptable value.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if the <tt>size</tt> parameter is invalid.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>dstOffs</tt> or <tt>srcOffs</tt> are invalid indices into their respective memblocks, or if either the source or destination ranges extend past the ends of their respective memblocks.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.compare"></a>function memblock.compare(lhsOffs: int, rhs: memblock, rhsOffs: int, size: int)<script>explorer.outline.addDecl('memblock.compare');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Compares slices of two memblocks (or two slices into the same memblock) lexicographically and returns a comparison result. Croc's version of memcmp!</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">lhsOffs</td><td><p>is the byte offset of the beginning of the slice in this memblock. May <strong>not</strong> be negative.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">rhs</td><td><p>is the memblock to which this one will be compared. Can be the same memblock as <tt>this</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">rhsOffs</td><td><p>is the byte offset of the beginning of the slice in <tt>rhs</tt>. May <strong>not</strong> be negative.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">size</td><td><p>is the number of bytes to compare. 0 is an acceptable value.</p></td></tr></table><p><strong>Returns:</strong> <p>a negative integer if the slice from this memblock is less than the slice from <tt>rhs</tt>, a positive integer if greater, and 0 if they are byte-for-byte equal.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if the <tt>size</tt> parameter is invalid.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>lhsOffs</tt> or <tt>rhsOffs</tt> are invalid indices into their respective memblocks, or if either the lhs or rhs ranges extend past the ends of their respective memblocks.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.opEquals"></a>function memblock.opEquals(other: memblock)<script>explorer.outline.addDecl('memblock.opEquals');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Compares two memblocks for exact data equality.</p><p><strong>Returns:</strong> <p><tt>true</tt> if both memblocks are the same length and contain the exact same data. Returns <tt>false</tt> otherwise.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.opCmp"></a>function memblock.opCmp(other: memblock)<script>explorer.outline.addDecl('memblock.opCmp');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Compares the contents of two memblocks lexicographically.</p><p><strong>Returns:</strong> <p>a negative integer if <tt>this</tt> compares before <tt>other</tt>, a positive integer if <tt>this</tt> compares after <tt>other</tt>, and 0 if <tt>this</tt> and <tt>other</tt> have identical contents.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.opCat"></a>function memblock.opCat(other: memblock)<script>explorer.outline.addDecl('memblock.opCat');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Concatenates two memblocks, returning a new memblock whose contents are a concatenation of the two sources.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">other</td><td><p>the second memblock in the concatenation.</p></td></tr></table><p><strong>Returns:</strong> <p>a new memblock whose contents are a concatenation of <tt>this</tt> followed by <tt>other</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.opCatAssign"></a>function memblock.opCatAssign(vararg)<script>explorer.outline.addDecl('memblock.opCatAssign');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Appends memblocks to the end of this memblock, resizing this memblock to hold all the contents and copying the contents from the source memblocks.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">vararg</td><td><p>the memblocks to be appended.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if <tt>this</tt> does not own its data (and therefore cannot be resized).</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if the total length of <tt>this</tt> after appending would be too large to be represented.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="memblock.opApply"></a>function memblock.opApply(mode: string = null)<script>explorer.outline.addDecl('memblock.opApply');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Allows you to iterate over the contents of a memblock with <tt>foreach</tt> loops.</p><p>You can iterate forwards (the default) or backwards:</p><p><div class="code"><pre><span class="k">local</span> <span class="n">m</span> <span class="p">=</span> <span class="n">memblock</span><span class="p">.</span><span class="n">fromArray</span><span class="p">([</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>

<span class="k">foreach</span><span class="p">(</span><span class="n">val</span><span class="p">;</span> <span class="n">m</span><span class="p">)</span>
	<span class="n">writeln</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1">// prints 1 through 3</span>

<span class="k">foreach</span><span class="p">(</span><span class="n">val</span><span class="p">;</span> <span class="n">m</span><span class="p">,</span> <span class="s">&quot;reverse&quot;</span><span class="p">)</span>
	<span class="n">writeln</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1">// prints 3 through 1</span>
</pre></div>
</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mode</td><td><p>is the iteration mode. Defaults to null, which means forwards; if passed "reverse", iterates backwards.</p></td></tr></table></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 12 Oct 2014 15:09:57	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("misc");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>