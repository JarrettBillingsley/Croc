<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module stream</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("stream");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module stream</h1><p>This module contains Croc's streamed input/output framework. The class which defines the <a href="stream.html#Stream">Stream</a> interface, as well as several useful subclasses and helpers are defined in this module.</p><p>This module is safe. The <a href="stream.html#NativeStream">NativeStream</a> class does let scripts read and write data outside memory, but only the host can create instances of it.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="EOFException"></a>global function EOFException()<script>explorer.outline.addDecl("EOFException");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A function which constructs a <a href="exceptions.html#IOException">IOException</a> to be thrown in the case of unexpected end-of-file situations.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StreamProtocolException"></a>global function StreamProtocolException(msg: string)<script>explorer.outline.addDecl("StreamProtocolException");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A function which constructs a <a href="exceptions.html#IOException">IOException</a> to be thrown in some APIs when stream protocols (behavior, return values etc.) are not respected.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="checkRWParams"></a>global function checkRWParams(m, offset, size)<script>explorer.outline.addDecl("checkRWParams");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A helper function for checking the params to stream <tt>read</tt> and <tt>write</tt> functions.</p><p>This ensures that the <tt>offset</tt> and <tt>size</tt> parameters are valid, and throws exceptions if not.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if either <tt>offset</tt> or <tt>size</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="InStream"></a>global function InStream(s)<script>explorer.outline.addDecl("InStream");</script></span><br/><span class="decl"><a id="OutStream"></a>function OutStream(s)<script>explorer.outline.addDecl("OutStream");</script></span><br/><span class="decl"><a id="InoutStream"></a>function InoutStream(s)<script>explorer.outline.addDecl("InoutStream");</script></span><br/><span class="decl"><a id="SeekStream"></a>function SeekStream(s)<script>explorer.outline.addDecl("SeekStream");</script></span><br/><span class="decl"><a id="InSeekStream"></a>function InSeekStream(s)<script>explorer.outline.addDecl("InSeekStream");</script></span><br/><span class="decl"><a id="OutSeekStream"></a>function OutSeekStream(s)<script>explorer.outline.addDecl("OutSeekStream");</script></span><br/><span class="decl"><a id="InoutSeekStream"></a>function InoutSeekStream(s)<script>explorer.outline.addDecl("InoutSeekStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These are meant to be used as custom parameter type constraints, to ensure that a stream parameter supports certain operations.</p><p>The <tt>in</tt> functions ensure that <tt>s.readable()</tt> returns true; the <tt>out</tt> functions ensure that <tt>s.writable()</tt> returns true; and the <tt>seek</tt> functions ensure that <tt>s.seekable()</tt> returns true. An example of use:</p><p><div class="code"><pre><span class="c1">// Expects the dest stream to be writable and the src stream to be readable</span>
<span class="k">function</span> <span class="n">copyBlock</span><span class="p">(</span><span class="n">dest</span><span class="p">:</span> <span class="p">@</span><span class="n">OutStream</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="p">@</span><span class="n">InStream</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// Finds the directory section in a ZIP file and reads it; expects the stream to be readable and seekable.</span>
<span class="k">function</span> <span class="n">readZIPDirectory</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="p">@</span><span class="n">InSeekStream</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
It's a good idea to use only what you need and not over-request features; for instance, if you're never going to write to the stream, don't use an <tt>out</tt> function.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>the stream object to test.</p></td></tr></table><p><strong>Returns:</strong> <p>a bool telling whether or not it satisfies the constraints.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="OpenStream"></a>global function OpenStream(s)<script>explorer.outline.addDecl("OpenStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is meant to be used as a custom parameter type constraint. It ensures that its parameter's <a href="stream.html#Stream.isOpen"><tt>isOpen</tt> method</a> returns <tt>true</tt>.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>the stream object to test.</p></td></tr></table><p><strong>Returns:</strong> <p>a bool telling whether or not it satisfies the constraints.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream"></a>class Stream<script>explorer.outline.addDecl("Stream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This class defines the interface that all streams must implement, as well as some helper functions which are implemented in terms of the user-defined methods. This interface is fairly low-level and is meant to be wrapped by higher-level stream wrappers and filters.</p><p>There are a relatively small number of functions which must be implemented to satisfy the stream interface. Detailed descriptions of these methods and their behavior is given inside this class, but a quick overview is as follows:</p><p><ul><li><p><strong><tt>readable, writable, seekable</tt></strong> - These simply return bools which indicate whether this stream can be read from, written to, and seeked.</p></li><li><p><strong><tt>read, write, seek</tt></strong> - The real workhorse functions which actually perform the reading, writing, and seeking of the stream. Each of these only needs to be implemented if the corresponding <tt>-able</tt> method returns <tt>true</tt>.</p></li><li><p><strong><tt>flush, close, isOpen</tt></strong> - Miscellaneous optional methods.</p></li></ul></p><p>For any given stream, likely only the first six (or some subset thereof) will have to be implemented.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.this"></a>Stream.this()<script>explorer.outline.addDecl("Stream.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor. Be sure to call this in classes derived from <a href="stream.html#Stream">Stream</a>. While it only checks that one of <a href="stream.html#Stream.readable">readable</a> and <a href="stream.html#Stream.writable">writable</a> returns true right now, this may change in the future.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>if both <a href="stream.html#Stream.readable">readable</a> and <a href="stream.html#Stream.writable">writable</a> return <tt>false</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.read"></a>function Stream.read(this: @InStream, m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("Stream.read");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reads data from the stream into the given memblock.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be readable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">m</td><td><p>is the memblock into which data will be read.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">offset</td><td><p>is the offset into <tt>m</tt> where the first byte of data will be placed. Defaults to 0.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">size</td><td><p>is the number of bytes to read. Defaults to the size of <tt>m</tt> minus the <tt>offset</tt>.</p></td></tr></table><p><strong>Returns:</strong> <p>an integer as follows:</p><p><ul><li><p>If <tt>size</tt> is 0, this function is a no-op, and the return value is 0.</p></li><li><p>If <tt>size</tt> is nonzero, <ul><li><p>If the read is successful, the return value is an integer in the range <tt>[1, size]</tt> and indicates the number of bytes actually read. Fewer than <tt>size</tt> bytes can be read in a number of non-error situations. If you need to fill up a buffer, make repeated calls to <tt>read</tt> until the desired number of bytes has been read. The <a href="stream.html#Stream.readExact">readExact</a> method does this for you.</p></li><li><p><strong>If the stream has reached the end of the file, the return value is 0.</strong> Note that end-of-file is not treated as an error condition; that determination is left to higher-level code to make.</p></li></ul></p></li></ul></p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if the <tt>offset</tt> is outside the range <tt>[0, #m]</tt>, or if <tt>size</tt> is outside the range <tt>[0, #m - offset]</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>or a derived class if some error occurred.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.write"></a>function Stream.write(this: @OutStream, m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("Stream.write");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Writes data into the stream from the given memblock.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be writable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">m</td><td><p>is the memblock from which data will be written.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">offset</td><td><p>is the offset into <tt>m</tt> where the first byte of data will be retrieved. Defaults to 0.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">size</td><td><p>is the number of bytes to write. Defaults to the size of <tt>m</tt> minus the <tt>offset</tt>.</p></td></tr></table><p><strong>Returns:</strong> <p>an integer.</p><p><ul><li><p>If <tt>size</tt> is 0, this function is a no-op, and the return value is 0.</p></li><li><p>If <tt>size</tt> is nonzero and the write is successful, the return value is an integer in the range <tt>[1, size]</tt> and indicates the number of bytes actually written. Fewer than <tt>size</tt> bytes can be written in a number of non-error situations. If you need to write a whole buffer, make repeated calls to <tt>write</tt> until the desired number of bytes has been written. The <a href="stream.html#Stream.writeExact">writeExact</a> method does this for you.</p></li></ul></p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if the <tt>offset</tt> is outside the range <tt>[0, #m]</tt>, or if <tt>size</tt> is outside the range <tt>[0, #m - offset]</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>or a derived class if some error occurred.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached. Note that this is unlike <a href="stream.html#Stream.read">read</a>, as an end-of-file condition on write is a much rarer and usually more serious/unrecoverable issue.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.seek"></a>function Stream.seek(this: @SeekStream, offset: int, where: string)<script>explorer.outline.addDecl("Stream.seek");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Changes the position of the stream's read/write position, and reports the new position once changed.</p><p>Seeking past the end of a stream may or may not be an error, depending on the kind of stream.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be seekable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">offset</td><td><p>is the position offset, whose meaning depends upon the <tt>where</tt> parameter.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">where</td><td><p>is a string indicating the position in the stream from which the new stream position will be calculated. It can be one of the three following values:</p><p><dl><dt><strong><tt>"b"</tt></strong></dt><dd><p>The <tt>offset</tt> is treated as an absolute offset from the beginning of the stream.</p></dd><dt><strong><tt>"c"</tt></strong></dt><dd><p>The <tt>offset</tt> is treated as a relative offset from the current read/write position. This means that negative <tt>offset</tt> values move the read/write position backwards.</p></dd><dt><strong><tt>"e"</tt></strong></dt><dd><p>The <tt>offset</tt> is treated as a relative offset from the end of the stream.</p></dd></dl></p></td></tr></table><p><strong>Returns:</strong> <p>the new stream position as an absolute position from the beginning of the stream.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>if the resulting stream position would be negative, or if some error occurred.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.readable"></a>function Stream.readable()<script>explorer.outline.addDecl("Stream.readable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Tells whether or not <a href="stream.html#Stream.read">read</a> can be called on this stream.</p><p><strong>Returns:</strong> <p>a bool indicating such. The default implementation returns <tt>false</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.writable"></a>function Stream.writable()<script>explorer.outline.addDecl("Stream.writable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Tells whether or not <a href="stream.html#Stream.write">write</a> can be called on this stream.</p><p><strong>Returns:</strong> <p>a bool indicating such. The default implementation returns <tt>false</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.seekable"></a>function Stream.seekable()<script>explorer.outline.addDecl("Stream.seekable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Tells whether or not <a href="stream.html#Stream.seek">seek</a> can be called on this stream.</p><p><strong>Returns:</strong> <p>a bool indicating such. The default implementation returns <tt>false</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.flush"></a>function Stream.flush()<script>explorer.outline.addDecl("Stream.flush");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An optional method used to flush cached data to the stream.</p><p>Often buffering schemes are used to improve IO performance, but such schemes mean that the stream and its backing store are often incoherent. This method is called to force coherency by flushing any buffered data and writing it into the backing store.</p><p>The default implementation is simply to do nothing.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.close"></a>function Stream.close()<script>explorer.outline.addDecl("Stream.close");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An optional method used to close a stream by releasing any system resources associated with it and preventing any further use.</p><p>This method should be allowed to be called more than once, but calls beyond the first should be no-ops.</p><p>The default implementation is simply to do nothing.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.isOpen"></a>function Stream.isOpen()<script>explorer.outline.addDecl("Stream.isOpen");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An optional method used to check whether or not this stream has been closed.</p><p>This goes along with the <a href="stream.html#Stream.close">close</a> method; once <a href="stream.html#Stream.close">close</a> has been called, this method should return <tt>false</tt>.</p><p><strong>Returns:</strong> <p>a bool indicating whether or not this stream is still open. The default implementation simply returns <tt>true</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.readExact"></a>function Stream.readExact(m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("Stream.readExact");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A helper method which attempts to read a block of data fully, making multiple calls to <a href="stream.html#Stream.read">read</a> as needed.</p><p>Since <a href="stream.html#Stream.read">read</a> may not read all the data for a block in one call, this method exists to automatically make as many calls to <a href="stream.html#Stream.read">read</a> as needed to fill the requested block of data. The parameters are identical to those of <a href="stream.html#Stream.read">read</a>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>or a derived class if some error occurred.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached before reading all the data requested.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.writeExact"></a>function Stream.writeExact(m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("Stream.writeExact");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A helper method which attempts to write a block of data fully, making multiple calls to <a href="stream.html#Stream.write">write</a> as needed.</p><p>Since <a href="stream.html#Stream.write">write</a> may not write all the data for a block in one call, this method exists to automatically make as many calls to <a href="stream.html#Stream.write">write</a> as needed to write the requested block of data. The parameters are identical to those of <a href="stream.html#Stream.write">write</a>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>or a derived class if some error occurred.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.skip"></a>function Stream.skip(this: @InStream, dist: int)<script>explorer.outline.addDecl("Stream.skip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Skips forward a given number of bytes.</p><p>The stream need not be seekable in order to skip forward. If it is not seekable, data will simply be read into a scratch buffer and discarded until the desired number of bytes have been skipped. If it is seekable, this will simply call <a href="stream.html#Stream.seek">seek</a> to seek forward <tt>dist</tt> bytes.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be readable, and may optionally be seekable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">dist</td><td><p>is the number of bytes to skip. Can be 0, which makes this method a no-op.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>dist</tt> is negative.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>or a derived class if some error occurred.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.readAll"></a>function Stream.readAll(this: @InStream, m: memblock = null)<script>explorer.outline.addDecl("Stream.readAll");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reads all remaining data from the stream up to end-of-file into a memblock.</p><p>This will call <a href="stream.html#Stream.read">read</a> as many times as needed until it indicates that the end of file has been reached.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be readable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">m</td><td><p>is an optional memblock to use as the buffer to hold the read data. If one is given, it will be resized to hold the read data. If it is not given, a new memblock will be used instead.</p></td></tr></table><p><strong>Returns:</strong> <p>the memblock holding the read data.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.copy"></a>function Stream.copy(this: @OutStream, s: @InStream, size: int = -1)<script>explorer.outline.addDecl("Stream.copy");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Copies data from another stream into this one.</p><p>The data is copied in blocks of 4096 bytes at a time.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be writable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the source stream from which the data will be read, and must be readable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">size</td><td><p>is the number of bytes to copy, or -1 to mean all data until <tt>s</tt> reaches end-of-file.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>size &lt; -1</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if <tt>size &gt; 0</tt> and end-of-file was reached before copying could finish.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.position"></a>function Stream.position(this: @SeekStream, pos: int|null)<script>explorer.outline.addDecl("Stream.position");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Sets or gets the absolute position in the stream, as a convenience.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be seekable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">pos</td><td><p>is either the new read/write position, measured in bytes from the beginning of the stream, or <tt>null</tt>.</p></td></tr></table><p><strong>Returns:</strong> <p>the new position if <tt>pos</tt> was non-null, or the current position if <tt>pos</tt> was <tt>null</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Stream.size"></a>function Stream.size(this: @SeekStream)<script>explorer.outline.addDecl("Stream.size");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Returns the size of the stream in bytes.</p><p>It does this by seeking to the end of the stream and getting the position, then seeking back to where it was before calling this method. As a result this method can cause buffered data to be flushed.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">this</td><td><p>must be seekable.</p></td></tr></table><p><strong>Returns:</strong> <p>an integer indicating how many bytes long this stream is.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream"></a>class MemblockStream : Stream<script>explorer.outline.addDecl("MemblockStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implements a readable, writable, seekable stream that uses a memblock as its data backing store.</p><p>This is a very useful kind of stream. With it you can redirect stream operations that would normally go to a file to memory instead. It can often be much faster to read in a large chunk of a file, or a file in its entirety, and then do processing in memory. This is also useful for building up data to be sent over networks or such.</p><p>The backing memblock can be one you provide, or it can use its own. The memblock will be grown automatically when data is written past its end.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream.this"></a>MemblockStream.this(mb: memblock = memblock.new(0))<script>explorer.outline.addDecl("MemblockStream.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mb</td><td><p>is the memblock to use as the backing store. If none is given, a new zero-size memblock will be used instead.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream.read"></a>function MemblockStream.read(m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("MemblockStream.read");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implmentation of <a href="stream.html#Stream.read">Stream.read</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream.write"></a>function MemblockStream.write(m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("MemblockStream.write");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implmentation of <a href="stream.html#Stream.write">Stream.write</a>.</p><p>If there is not enough space in the memblock to hold the new data, the memblock's size will be expanded to accommodate.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream.seek"></a>function MemblockStream.seek(offset: int, where: string)<script>explorer.outline.addDecl("MemblockStream.seek");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implmentation of <a href="stream.html#Stream.seek">Stream.seek</a>.</p><p>If you seek past the end of the memblock, the memblock will be resized to the new offset. This is to match the behavior of seeking on files.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if <tt>where</tt> is invalid.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#IOException">IOException</a></td><td><p>if the resulting offset is negative.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream.readable"></a>function MemblockStream.readable()<script>explorer.outline.addDecl("MemblockStream.readable");</script></span><br/><span class="decl"><a id="MemblockStream.writable"></a>function MemblockStream.writable()<script>explorer.outline.addDecl("MemblockStream.writable");</script></span><br/><span class="decl"><a id="MemblockStream.seekable"></a>function MemblockStream.seekable()<script>explorer.outline.addDecl("MemblockStream.seekable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementations of <a href="stream.html#Stream.readable">Stream.readable</a>, <a href="stream.html#Stream.writable">Stream.writable</a>, and <a href="stream.html#Stream.seekable">Stream.seekable</a>. All return true.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="MemblockStream.getBacking"></a>function MemblockStream.getBacking()<script>explorer.outline.addDecl("MemblockStream.getBacking");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the backing memblock.</p><p>It's probably best not to change the size of the memblock while it's still being used by the stream.</p><p><strong>Returns:</strong> <p>the backing memblock.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StreamWrapper"></a>class StreamWrapper : Stream<script>explorer.outline.addDecl("StreamWrapper");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A base class for types of streams which expand the capabilities of another stream without obscuring the underlying stream interface.</p><p>It takes a stream object and implements all of the <a href="stream.html#Stream">Stream</a> interface methods as simply passthroughs to the underlying stream object. Subclasses can then add methods and possibly override just those which they need to.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StreamWrapper.this"></a>StreamWrapper.this(s)<script>explorer.outline.addDecl("StreamWrapper.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the stream object to be wrapped.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StreamWrapper.read"></a>function StreamWrapper.read(m, off, size)<script>explorer.outline.addDecl("StreamWrapper.read");</script></span><br/><span class="decl"><a id="StreamWrapper.write"></a>function StreamWrapper.write(m, off, size)<script>explorer.outline.addDecl("StreamWrapper.write");</script></span><br/><span class="decl"><a id="StreamWrapper.seek"></a>function StreamWrapper.seek(off, where)<script>explorer.outline.addDecl("StreamWrapper.seek");</script></span><br/><span class="decl"><a id="StreamWrapper.flush"></a>function StreamWrapper.flush()<script>explorer.outline.addDecl("StreamWrapper.flush");</script></span><br/><span class="decl"><a id="StreamWrapper.close"></a>function StreamWrapper.close()<script>explorer.outline.addDecl("StreamWrapper.close");</script></span><br/><span class="decl"><a id="StreamWrapper.isOpen"></a>function StreamWrapper.isOpen()<script>explorer.outline.addDecl("StreamWrapper.isOpen");</script></span><br/><span class="decl"><a id="StreamWrapper.readable"></a>function StreamWrapper.readable()<script>explorer.outline.addDecl("StreamWrapper.readable");</script></span><br/><span class="decl"><a id="StreamWrapper.writable"></a>function StreamWrapper.writable()<script>explorer.outline.addDecl("StreamWrapper.writable");</script></span><br/><span class="decl"><a id="StreamWrapper.seekable"></a>function StreamWrapper.seekable()<script>explorer.outline.addDecl("StreamWrapper.seekable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These all simply pass through functionality to the wrapped stream object.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StreamWrapper.getWrappedStream"></a>function StreamWrapper.getWrappedStream()<script>explorer.outline.addDecl("StreamWrapper.getWrappedStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the stream that this instance wraps.</p><p><strong>Returns:</strong> <p>the same stream object that was passed to the constructor.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream"></a>class BinaryStream : StreamWrapper<script>explorer.outline.addDecl("BinaryStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A kind of stream wrapper class that adds a simple interface for reading and writing binary data.</p><p>Because it's a stream wrapper, the basic stream interface can still be used on it and the functionality will be passed through to the wrapped stream.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.this"></a>BinaryStream.this(s)<script>explorer.outline.addDecl("BinaryStream.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the stream to be wrapped.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.readInt8"></a>function BinaryStream.readInt8()<script>explorer.outline.addDecl("BinaryStream.readInt8");</script></span><br/><span class="decl"><a id="BinaryStream.readInt16"></a>function BinaryStream.readInt16()<script>explorer.outline.addDecl("BinaryStream.readInt16");</script></span><br/><span class="decl"><a id="BinaryStream.readInt32"></a>function BinaryStream.readInt32()<script>explorer.outline.addDecl("BinaryStream.readInt32");</script></span><br/><span class="decl"><a id="BinaryStream.readInt64"></a>function BinaryStream.readInt64()<script>explorer.outline.addDecl("BinaryStream.readInt64");</script></span><br/><span class="decl"><a id="BinaryStream.readUInt8"></a>function BinaryStream.readUInt8()<script>explorer.outline.addDecl("BinaryStream.readUInt8");</script></span><br/><span class="decl"><a id="BinaryStream.readUInt16"></a>function BinaryStream.readUInt16()<script>explorer.outline.addDecl("BinaryStream.readUInt16");</script></span><br/><span class="decl"><a id="BinaryStream.readUInt32"></a>function BinaryStream.readUInt32()<script>explorer.outline.addDecl("BinaryStream.readUInt32");</script></span><br/><span class="decl"><a id="BinaryStream.readUInt64"></a>function BinaryStream.readUInt64()<script>explorer.outline.addDecl("BinaryStream.readUInt64");</script></span><br/><span class="decl"><a id="BinaryStream.readFloat32"></a>function BinaryStream.readFloat32()<script>explorer.outline.addDecl("BinaryStream.readFloat32");</script></span><br/><span class="decl"><a id="BinaryStream.readFloat64"></a>function BinaryStream.readFloat64()<script>explorer.outline.addDecl("BinaryStream.readFloat64");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These all read a single integer or floating-point value of the given type and size.</p><p>Note that because Croc's <tt>int</tt> type is a signed 64-bit integer, <tt>readUInt64</tt> will return negative numbers for those that exceed 2<sup>63</sup> - 1. It exists for completeness.</p><p><strong>Returns:</strong> <p>an <tt>int</tt> or <tt>float</tt> representing the value read.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.readString"></a>function BinaryStream.readString()<script>explorer.outline.addDecl("BinaryStream.readString");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reads a binary representation of a <tt>string</tt> object. Should only be used as the inverse to <a href="stream.html#BinaryStream.writeString">writeString</a>.</p><p><strong>Returns:</strong> <p>a <tt>string</tt> representing the value read.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.readChars"></a>function BinaryStream.readChars(n: int)<script>explorer.outline.addDecl("BinaryStream.readChars");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reads a given number of <strong>ASCII</strong> characters and returns them as a string.</p><p>This is particularly useful for chunk identifiers in RIFF-type files and "magic numbers", though it can have other uses as well.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">n</td><td><p>is the number of bytes to read.</p></td></tr></table><p><strong>Returns:</strong> <p>a <tt>string</tt> representing the characters read.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>n &lt; 1</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.writeInt8"></a>function BinaryStream.writeInt8(x: int)<script>explorer.outline.addDecl("BinaryStream.writeInt8");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These all write a single integer or floating-point value of the given type and size.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">x</td><td><p>is the value to write.</p></td></tr></table><p><strong>Returns:</strong> <p><tt>this</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.writeString"></a>function BinaryStream.writeString(x: string)<script>explorer.outline.addDecl("BinaryStream.writeString");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Writes a binary representation of the given string. To read this binary representation back again, use <a href="stream.html#BinaryStream.readString">readString</a>. The representation is a 64-bit unsigned integer indicating the length, in bytes, of the string data encoded in UTF-8, followed by the string data encoded in UTF-8.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">x</td><td><p>is the string to write.</p></td></tr></table><p><strong>Returns:</strong> <p><tt>this</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BinaryStream.writeChars"></a>function BinaryStream.writeChars(x: string)<script>explorer.outline.addDecl("BinaryStream.writeChars");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Writes the given string, which must be ASCII only, as a raw sequence of byte-sized characters.</p><p>This is particularly useful for chunk identifiers in RIFF-type files and "magic numbers", though it can have other uses as well.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">x</td><td><p>is the string containing the characters to be written. It must be ASCII.</p></td></tr></table><p><strong>Returns:</strong> <p><tt>this</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if <tt>x</tt> is not ASCII.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file was reached.</p></td></tr></table></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedInStream"></a>class BufferedInStream : StreamWrapper<script>explorer.outline.addDecl("BufferedInStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A stream wrapper that adds input buffering. Note that this class only allows reading and seeking; writing is unsupported.</p><p>This stream adds a transparent buffering scheme when reading data. Seeking is also allowed and will work correctly even if data is buffered.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedInStream.this"></a>BufferedInStream.this(s: @InStream, bufSize: int = 4096)<script>explorer.outline.addDecl("BufferedInStream.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the stream to be wrapped.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">bufSize</td><td><p>is the size of the memory buffer. Defaults to 4KB. Its size is clamped to a minimum of 128 bytes, and there is no upper limit.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedInStream.writable"></a>function BufferedInStream.writable()<script>explorer.outline.addDecl("BufferedInStream.writable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Regardless of whether or not the underlying stream is writable, this class is not. Erratic behavior can result if you try to write to a stream that is wrapped by this class.</p><p><strong>Returns:</strong> <p>false.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedInStream.read"></a>function BufferedInStream.read(m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("BufferedInStream.read");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <tt>read</tt> method. It works exactly like the normal <tt>read</tt> method, performing buffering transparently.</p><p>The call signature and return values are the same as <a href="stream.html#Stream.read">Stream.read</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedInStream.seek"></a>function BufferedInStream.seek(this: @SeekStream, offset: int, where: string)<script>explorer.outline.addDecl("BufferedInStream.seek");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <tt>seek</tt> method. It works exactly like the normal <tt>seek</tt> method, and will seek properly even if data has been buffered.</p><p>Seeking will clear the data buffer. The call signature and return values are the same as <a href="stream.html#Stream.seek">Stream.seek</a>.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream"></a>class BufferedOutStream : StreamWrapper<script>explorer.outline.addDecl("BufferedOutStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A stream wrapper that adds output buffering. Note that this class only allows writing and seeking; reading is unsupported.</p><p>This stream adds a transparent buffering scheme when writing data. Seeking is also allowed and will work correctly even if data is buffered.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream.this"></a>BufferedOutStream.this(s: @OutStream, bufSize: int = 4096)<script>explorer.outline.addDecl("BufferedOutStream.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the stream to be wrapped.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">bufSize</td><td><p>is the size of the memory buffer. Defaults to 4KB. Its size is clamped to a minimum of 128 bytes, and there is no upper limit.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream.readable"></a>function BufferedOutStream.readable()<script>explorer.outline.addDecl("BufferedOutStream.readable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Regardless of whether or not the underlying stream is readable, this class is not. Erratic behavior can result if you try to read from a stream that is wrapped by this class.</p><p><strong>Returns:</strong> <p>false.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream.write"></a>function BufferedOutStream.write(m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("BufferedOutStream.write");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <tt>write</tt> method. It works exactly like the normal <tt>write</tt> method, performing buffering transparently.</p><p>The call signature and return values are the same as <a href="stream.html#Stream.write">Stream.write</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream.seek"></a>function BufferedOutStream.seek(offset: int, where: string)<script>explorer.outline.addDecl("BufferedOutStream.seek");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <tt>seek</tt> method. It works exactly like the normal <tt>seek</tt> method, and will seek properly even if data has been buffered.</p><p>Seeking will flush the data buffer. The call signature and return values are the same as <a href="stream.html#Stream.seek">Stream.seek</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream.flush"></a>function BufferedOutStream.flush()<script>explorer.outline.addDecl("BufferedOutStream.flush");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <tt>flush</tt> method. This writes any buffered data to the stream. If no data is buffered, does nothing.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="stream.html#EOFException">EOFException</a></td><td><p>if end-of-file is reached.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedOutStream.close"></a>function BufferedOutStream.close()<script>explorer.outline.addDecl("BufferedOutStream.close");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <tt>close</tt> method. Simply flushes the buffer and then calls <tt>close</tt> on the underlying stream.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextReader"></a>class TextReader<script>explorer.outline.addDecl("TextReader");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implements a simple line-oriented text reader. You provide it with a stream and a character encoding to use, and it will decode text data from the stream and return it one line at a time.</p><p>This class uses its own buffering mechanism, meaning that you do not have to place a buffer between it and the source stream object.</p><p>This class does not implement the stream interface, nor is it a stream wrapper. Because it has its own buffering mechanism, erratic behavior can result if you operate directly on the underlying stream.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextReader.this"></a>TextReader.this(s: @InStream, codec: string, errors: string = "strict", bufSize: int = 4096)<script>explorer.outline.addDecl("TextReader.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the stream which will provide the data. It must be readable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">codec</td><td><p>is the name of the codec (see <a href="text.html">text</a>) in which the stream data is encoded.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">errors</td><td><p>is the error handling mode that will be passed to the text codec. Defaults to <tt>"strict"</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">bufSize</td><td><p>is the size of the internal buffer. Defaults to 4096 (4 KB). Its value is clamped to a minimum of 128.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextReader.readln"></a>function TextReader.readln(stripEnding: bool = true)<script>explorer.outline.addDecl("TextReader.readln");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reads one line of text from the stream.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">stripEnding</td><td><p>controls whether or not the line ending character(s) will be preserved in the output. This defaults to "true", in which case the line ending will be stripped and only the line's text will be returned.</p></td></tr></table><p><strong>Returns:</strong> <p>a string containing one line of text, or if the end of the stream has been reached, returns <tt>null</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextReader.opApply"></a>function TextReader.opApply(mode: string = "strip")<script>explorer.outline.addDecl("TextReader.opApply");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Allows instances of this object to be used in <tt>foreach</tt> loops. The first index is the 1-based index of the line, and the second index is the line's contents.</p><p><strong>Examples:</strong> <p>Suppose you had a file with three lines, and you had a stream that read from that file. You could iterate over its lines like so:</p><p><div class="code"><pre><span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">;</span> <span class="n">TextReader</span><span class="p">(</span><span class="n">fileStream</span><span class="p">))</span>
	<span class="n">writefln</span><span class="p">(</span><span class="s">&quot;{}: {}&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
</pre></div>
This might print:</p><p><pre>1: First line!
2: Second line.
3: Last liiiiine</pre></p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mode</td><td><p>is a string controlling whether or not line ending character(s) are stripped. The default is "strip" which removes them. The only other valid value is "nostrip" which preserves them.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextReader.readAllLines"></a>function TextReader.readAllLines(stripEnding: bool = true)<script>explorer.outline.addDecl("TextReader.readAllLines");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reads all the remaining lines from the stream and returns them as an array of strings.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">stripEnding</td><td><p>works just like in <a href="stream.html#TextReader.readln">readln</a>.</p></td></tr></table><p><strong>Returns:</strong> <p>an array of strings, one for each line.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextReader.getStream"></a>function TextReader.getStream()<script>explorer.outline.addDecl("TextReader.getStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the stream object that was passed to the constructor. Remember, operating on this stream directly can cause this class to act erratically.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter"></a>class TextWriter<script>explorer.outline.addDecl("TextWriter");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implements a simple line-oriented text writer with formatting support. You provide it with a stream and a character encoding to use, and it will transparently encode text that you write. It can optionally flush the underlying stream at each newline.</p><p>Unlike <a href="stream.html#TextReader">TextReader</a>, this class does <em>not</em> use any buffering mechanism, so if you're using this to write a large file for instance, it's best to put a buffer between this and the output stream.</p><p>This class does not implement the stream interface, nor is it a stream wrapper. Because it has its own buffering mechanism, erratic behavior can result if you operate directly on the underlying stream.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.this"></a>TextWriter.this(s: @OutStream, codec: string, errors: string = "strict", newline: string = "\n")<script>explorer.outline.addDecl("TextWriter.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">s</td><td><p>is the stream to which data will be written. It must be writable.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">codec</td><td><p>is the name of the codec (see <a href="text.html">text</a>) in which the text will be encoded.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">errors</td><td><p>is the error handling mode that will be passed to the text codec. Defaults to <tt>"strict"</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">newline</td><td><p>is the string which will be output to write a newline. Defaults to <tt>"\n"</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.flushOnNL"></a>function TextWriter.flushOnNL(f: bool)<script>explorer.outline.addDecl("TextWriter.flushOnNL");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Controls whether the underlying stream will be automatically flushed on newlines. This flushing behavior only happens after calls to <a href="stream.html#TextWriter.writeln">writeln</a> and <a href="stream.html#TextWriter.writefln">writefln</a>; it does not happen if there are newlines embedded in the output text.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">f</td><td><p>is <tt>true</tt> to enable this behavior, <tt>false</tt> otherwise. By default, flushing is off.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.flush"></a>function TextWriter.flush()<script>explorer.outline.addDecl("TextWriter.flush");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Just flushes the underlying stream.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.write"></a>function TextWriter.write(vararg)<script>explorer.outline.addDecl("TextWriter.write");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Converts each argument to its string representation (with <a href="misc.html#toString">toString</a>), encodes the string with the writer's encoding, and outputs it to the underlying stream.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.writeln"></a>function TextWriter.writeln(vararg)<script>explorer.outline.addDecl("TextWriter.writeln");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as above, but after outputting the arguments, outputs the newline string as specified in the constructor. After that, it will call the underlying stream's <tt>flush</tt> method if newline flushing is enabled.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.writef"></a>function TextWriter.writef(fmt: string, vararg)<script>explorer.outline.addDecl("TextWriter.writef");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Equivalent to calling <tt>write(fmt.format(vararg))</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.writefln"></a>function TextWriter.writefln(fmt: string, vararg)<script>explorer.outline.addDecl("TextWriter.writefln");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as above, but outputs a newline and optionally flushes like <a href="stream.html#TextWriter.writeln">writeln</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextWriter.getStream"></a>function TextWriter.getStream()<script>explorer.outline.addDecl("TextWriter.getStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the stream object that was passed to the constructor.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream"></a>class NativeStream : Stream<script>explorer.outline.addDecl("NativeStream");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This class wraps a host language stream object. Because of this, its interface may vary between implementations of Croc. This is the documentation for the C++ implementation.</p><p>This class wraps a platform dependent "stream" or "file." On Windows systems, this is a HANDLE, and on POSIXen, this is a file descriptor. The stream can be marked as readable, writable, or seekable, and it also provides a "closable" option to prevent script code from closing streams it shouldn't have permission to (like the standard streams).</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.this"></a>NativeStream.this(stream: nativeobj, caps: string)<script>explorer.outline.addDecl("NativeStream.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Constructor.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">stream</td><td><p>is a nativeobj that represents a platform-dependent "stream" or "file" as explained above.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">caps</td><td><p>is a string representing the capabilities of the stream. <tt>caps</tt> is searched for specific characters which indicate a capability:</p><p><dl><dt><tt>"r"</tt></dt><dd><p>indicates that the stream is readable.</p></dd><dt><tt>"w"</tt></dt><dd><p>indicates that the stream is writable.</p></dd><dt><tt>"s"</tt></dt><dd><p>indicates that the stream is seekable.</p></dd><dt><tt>"c"</tt></dt><dd><p>indicates that the stream is closable.</p></dd></dl></p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.finalizer"></a>function NativeStream.finalizer()<script>explorer.outline.addDecl("NativeStream.finalizer");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Finalizer. If the stream is writable, it will be flushed, and if it is closable, it will be closed.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.read"></a>function NativeStream.read(this: @OpenStream, m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("NativeStream.read");</script></span><br/><span class="decl"><a id="NativeStream.write"></a>function NativeStream.write(this: @OpenStream, m: memblock, offset: int = 0, size: int = #m - offset)<script>explorer.outline.addDecl("NativeStream.write");</script></span><br/><span class="decl"><a id="NativeStream.seek"></a>function NativeStream.seek(this: @OpenStream, offset: int, where: string)<script>explorer.outline.addDecl("NativeStream.seek");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementations of the main stream interface functions. These all expect the stream to be open.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.readable"></a>function NativeStream.readable()<script>explorer.outline.addDecl("NativeStream.readable");</script></span><br/><span class="decl"><a id="NativeStream.writable"></a>function NativeStream.writable()<script>explorer.outline.addDecl("NativeStream.writable");</script></span><br/><span class="decl"><a id="NativeStream.seekable"></a>function NativeStream.seekable()<script>explorer.outline.addDecl("NativeStream.seekable");</script></span><br/><span class="decl"><a id="NativeStream.closable"></a>function NativeStream.closable()<script>explorer.outline.addDecl("NativeStream.closable");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Tells whether or not the stream is readable, writable, seekable, and closable.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.flush"></a>function NativeStream.flush(this: @OpenStream)<script>explorer.outline.addDecl("NativeStream.flush");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Calls the underlying flush method of the stream.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.close"></a>function NativeStream.close()<script>explorer.outline.addDecl("NativeStream.close");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Closes the stream. You can safely call this on streams that have already been closed; nothing will happen.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#StateError">StateError</a></td><td><p>if you try to close a stream that was not set to be closable in the constructor.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="NativeStream.isOpen"></a>function NativeStream.isOpen()<script>explorer.outline.addDecl("NativeStream.isOpen");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Tells whether or not the stream is open.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 15 Nov 2014 10:28:14	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("imgui");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>