<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module gc</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("gc");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module gc</h1><p>This library is the interface to the Croc garbage collector. This interface might differ from implementation to implementation since different implementations can use different garbage collection algorithms. Not sure how to deal with that yet, but there it is.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="collect"></a>global function collect()<script>explorer.outline.addDecl('collect');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Performs a normal garbage collection cycle. Usually you won't have to call this because the GC will be run periodically on its own, but sometimes it's useful to force a cycle.</p><p><strong>Returns:</strong> <p>the number of bytes reclaimed by the GC.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="collectFull"></a>global function collectFull()<script>explorer.outline.addDecl('collectFull');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Performs a full garbage collection cycle. Most GC cycles are relatively quick, but there are some kinds of objects which are put off for once-in-a-while processing because they would be too expensive to process every cycle. A full GC cycle will process these objects. Again, normally you don't have to call this because the GC will perform a full cycle on its own every once in a while, but running a full cycle will guarantee that ANY garbage objects will be collected, so it can be useful.</p><p><strong>Returns:</strong> <p>the number of bytes reclaimed by the GC.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="allocated"></a>global function allocated()<script>explorer.outline.addDecl('allocated');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the total bytes currently allocated by this VM instance.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="limit"></a>global function limit(type: string, size: int = null)<script>explorer.outline.addDecl('limit');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets or sets various limits used by the garbage collector. Most have an effect on how often GC collections are run. You can set these limits to better suit your program, or to enforce certain behaviors, but setting them incorrectly can cause the GC to thrash, collecting way too often and hogging the CPU. Be careful.</p><p>If only called with a <tt>type</tt> parameter and no <tt>size</tt> parameter, gets the given limit. If a <tt>size</tt> parameter is passed, sets the given limit to that size and returns the previously-set limit.</p><p>The <tt>type</tt> parameter is a string that must be one of the following values:</p><p><dl><dt><tt>"nurseryLimit"</tt></dt><dd><p>The size, in bytes, of the nursery generation. Defaults to 512KB. Most objects are initially allocated in the nursery. When the nursery fills up (the number of bytes allocated exceeds this limit), a collection will be triggered. Setting the nursery limit higher will cause collections to run less often, but they will take longer to complete. Setting the nursery limit lower will put more pressure on the older generation as it will not give young objects a chance to die off, as they usually do. Setting the nursery limit to 0 will cause a collection to be triggered on every allocation. That's probably bad.</p></dd><dt><tt>"metadataLimit"</tt></dt><dd><p>The size, in bytes, of the GC metadata. Defaults to 128KB. The metadata includes two buffers: one keeps track of which old-generation objects have been modified; the other keeps track of which old-generation objects need to have their reference counts decreased. This is pretty low-level stuff, but generally speaking, the more object mutation your program has, the faster these buffers will fill up. When they do, a collection is triggered. Much like the nursery limit, setting this value higher will cause collections to occur less often but they will take longer. Setting it lower will put more pressure on the older generation, as it will tend to pull objects out of the nursery before they can have a chance to die off. Setting the metadata limit to 0 will cause a collection to be triggered on every mutation. That's also probably bad!</p></dd><dt><tt>"nurserySizeCutoff"</tt></dt><dd><p>The maximum size, in bytes, of an object that can be allocated in the nursery. Defaults to 256. If an object is bigger than this, it will be allocated directly in the old generation instead. This avoids having large objects fill up the nursery and causing more collections than necessary. Chances are this won't happen too often, unless you're allocating really huge class instances. Setting this value to 0 will effectively turn the GC algorithm into a regular deferred reference counting GC, with only one generation. Maybe that'd be useful for you?</p></dd><dt><tt>"cycleCollectInterval"</tt></dt><dd><p>Since the Croc reference implementation uses a form of reference counting to do garbage collection, it must detect cyclic garbage (which would otherwise never be freed). Cyclic garbage usually forms only a small part of all garbage, but ignoring it would cause memory leaks. In order to avoid that, the GC must occasionally run a separate cycle collection algorithm during the GC cycle. This is triggered when enough potential cyclic garbage is buffered (see the next limit type for that), or every <em>n</em> collections, whichever comes first. This limit is that <em>n</em>. It defaults to 50; that is, every 50 garbage collection cycles, a cycle collection will be forced, regardless of how much potential cyclic garbage has been buffered. Setting this limit to 0 will force a cycle collection at every GC cycle, which isn't that great for performance. Setting this limit very high will cause cycle collections only to be triggered if enough potential cyclic garbage is buffered, but it's then possible that that garbage can hang around until program end, wasting memory.</p></dd><dt><tt>"cycleMetadataLimit"</tt></dt><dd><p>As explained above, the GC will buffer potential cyclic garbage during normal GC cycles, and then when a cycle collection is initiated, it will look at that buffered garbage and determine whether it really is garbage. This limit is similar to metadataLimit in that it measures the size of a buffer, and when that buffer size crosses this limit, a cycle collection is triggered. This defaults to 128KB. The more cyclic garbage your program produces, the faster this buffer will fill up. Note that Croc is somewhat smart about what it considers potential cyclic garbage; only objects whose reference counts decrease to a non-zero value are candidates for cycle collection. Of course, this is only a heuristic, and can have false positives, meaning non-cyclic objects (living or dead) can be scanned by the cycle collector as well. Thus the cycle collector must be run to reclaim ALL dead objects.</p></dd></dl></p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="postCallback"></a>global function postCallback(cb: function)<script>explorer.outline.addDecl('postCallback');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The Croc GC can maintain a list of callback functions which are called whenever the GC completes a cycle. Sometimes this can be a useful feature, but it's probably best not to overuse it; after all, the GC can run arbitrarily, and each time it's run, these callbacks are run as well. The standard library uses a post-GC callback to clean out empty entries from weak tables (defined in the hash library). Post-GC callbacks are a nice time to clean out caches and such, but it's also probably a good idea to count the number of times your callback is called and only perform its action once in a while instead of every GC cycle, so you don't make the GC take a long time.</p><p>When the callbacks are called, everything is safe; these are not like finalizer functions in which the GC is disabled and errors are fatal. By the time the callbacks are called, the GC has completed its cycle.</p><p>If you try to register one function more than once, nothing will happen; each function will only be called once per GC cycle.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="removePostCallback"></a>global function removePostCallback(cb: function)<script>explorer.outline.addDecl('removePostCallback');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Removes a post-GC callback function that was previously added with <a href="gc.html#postCallback">gc.postCallback</a>. If the given function is not in the list of callbacks, nothing happens.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 12 Oct 2014 15:09:57	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("misc");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>