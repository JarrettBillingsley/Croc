<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module modules</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("modules");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module modules</h1><p>This library forms the core of the Croc module system. When you use an import statement in Croc, it's simply syntactic sugar for a call to <tt>modules.load</tt>. All of the semantics of imports and such are handled by the functions and data structures in here. At a high level, the module system is just a mechanism that maps from strings (module names) to namespaces. The default behavior of this library is just that -- a default. You can customize the behavior of module importing to your specific needs.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="SafeStdlibNames"></a>global SafeStdlibNames = [...<script>explorer.outline.addDecl('SafeStdlibNames');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An alphabetized array of names of all the safe Croc standard libraries. The misc library is not covered since it has no namespace of its own.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="UnsafeStdlibNames"></a>global UnsafeStdlibNames = [...<script>explorer.outline.addDecl('UnsafeStdlibNames');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An alphabetized array of names of all the unsafe Croc standard libraries.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="AllStdlibNames"></a>global AllStdlibNames = (SafeStdlibNames ~ UnsafeStdlibNames).sort()<script>explorer.outline.addDecl('AllStdlibNames');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An alphabetized array of names of all the Croc standard libraries, safe and unsafe.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="AddonNames"></a>global AddonNames = [...<script>explorer.outline.addDecl('AddonNames');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An alphabetized array of names of all the Croc addon libraries. This is all the addons available, not those compiled in. The <tt>gl</tt> library is also included, even though it's loaded by another addon.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncludedAddons"></a>global IncludedAddons = _modulestmp.IncludedAddons.sort()<script>explorer.outline.addDecl('IncludedAddons');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An alphabetized array of names of Croc addon libraries that were included in the host. This doesn't include the <tt>gl</tt> library.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="path"></a>global path = "."<script>explorer.outline.addDecl('path');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is just a variable that holds a string. This string contains the paths that are used when searching for modules. The paths are specified using forward slashes to separate path components regardless of the underlying OS, and semicolons to separate paths.</p><p>By default, this variable holds the string ".", which just means "the current directory". If you changed it to something like ".;imports/current", when you tried to load a module "foo.bar", it would look for "./foo/bar.croc" and "imports/current/foo/bar.croc" in that order.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="customLoaders"></a>global customLoaders = {}<script>explorer.outline.addDecl('customLoaders');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is a table which you are free to use. It maps from module names (strings) to functions, funcdefs, or namespaces. This table is used by the <tt>customLoad</tt> step in <a href="modules.html#loaders">modules.loaders</a>; see it for more information.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="loaders"></a>global loaders = [customLoad, loadFiles]<script>explorer.outline.addDecl('loaders');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is an important variable. This holds the array of <em>module loaders</em>, which are functions which take the name of a module that's being loaded, and return one of four things: nothing or null, to indicate that the next loader should be tried; a namespace, which is assumed to be the module's namespace; a native function, which is assumed to be a native module's <em>loader</em>; or a funcdef, which is assumed to be the function definition of the top-level function of a Croc module.</p><p>By default, two loaders are in this array, in the following order: <ul><li><p><strong><tt>customLoad</tt></strong>: This looks in the <a href="modules.html#customLoaders">modules.customLoaders</a> table for a loader function, funcdef, or namespace. If one exists, it just returns that; otherwise, returns null. You can use this behavior to set up custom loaders for your own modules: just put the loader in the <a href="modules.html#customLoaders">modules.customLoaders</a> table, and when it's imported, it'll have the loader function, funcdef, or namespace used for it. This is exactly how the standard library loaders work.</p></li><li><p><strong><tt>loadFiles</tt></strong>: This looks for files to load and loads them. As explained in <a href="modules.html#path">modules.path</a>, the paths in that variable will be tried one by one until a file is found or they are all exhausted. This looks for both script files (<tt>.croc</tt>) and compiled modules (<tt>.croco</tt>). If it finds just a script file, it will compile it and return the resulting top-level funcdef. If it finds just a compiled module, it will load it and return the top-level funcdef. If it finds both in the same path, it will load whichever is newer. If it gets through all the paths and finds no files, it returns nothing.</p></li></ul></p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="loaded"></a>global loaded = {}<script>explorer.outline.addDecl('loaded');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is another important variable. This table holds all currently-loaded modules, where the keys are the module names and the values are the modules' namespaces.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="load"></a>global function load(name: string)<script>explorer.outline.addDecl('load');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Loads a module of the given name and, if successful, returns that module's namespace. If the module is already loaded (i.e. it has an entry in the <a href="modules.html#loaded">modules.loaded</a> table), just returns the preexisting namespace.</p><p>This is the function that the built-in import statement calls. So in fact, "<tt>import foo.bar</tt>" and "<tt>modules.load("foo.bar")</tt>" do exactly the same thing, at least from the module-loading point of view. Import statements also give you some syntactic advantages with selective and renamed imports.</p><p>The process of loading a module goes something like this:</p><p><ol type="1"><li><p>It looks in <a href="modules.html#loaded">modules.loaded</a> to see if the module of the given name has already been imported. If it has (i.e. there is a namespace in that table), it returns whatever namespace is stored there.</p></li><li><p>It makes sure we are not circularly importing this module. If we are, it throws an error.</p></li><li><p>It makes sure there are no module name conflicts. No module name may be the prefix of any other module's name; for example, if you have a module "foo.bar", you may not have a module "foo" as it's a prefix of "foo.bar". If there are any conflicts, it throws an error.</p></li><li><p>It iterates through the <a href="modules.html#loaders">modules.loaders</a> array, calling each successive loader with the module's name. If a loader returns null, it continues on to the next loader. If a loader returns a namespace, it puts it in the <a href="modules.html#loaded">modules.loaded</a> table and returns that namespace. If a loader returns a function (native only) or funcdef, it is assumed to be the modules's top-level function, and the following occurs: <ol type="a"><li><p>The dotted module name is used to create the namespace for the module in the global namespace hierarchy if it doesn't already exist. If the namespace already exists (such as when a module is being reloaded), it is cleared at this point.</p></li><li><p>If the loader returned a funcdef, a closure is created here using that funcdef and the new namespace as its environment. If the loader returned a (native) function, its environment is changed to the new namespace.</p></li><li><p>The top-level function is called, with the module's namespace as the 'this' parameter.</p></li><li><p>If the top-level function succeeds, the module's namespace will be inserted into the global namespace hierarchy and into the <a href="modules.html#loaded">modules.loaded</a> table, at which point <tt>modules.load</tt> returns that namespace.</p></li><li><p>Otherwise, if the top-level function fails, no change will be made to the global namespace hierarchy (unless the namespace was cleared during a module reload), and an exception will be thrown.</p></li></ol></p></li><li><p>If it gets through the entire array without getting a function or namespace from any loaders, an error is thrown saying that the module could not be loaded.</p></li></ol></p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">name</td><td><p>The name of the module to load, in dotted form (such as "foo.bar").</p></td></tr></table><p><strong>Returns:</strong> <p>The namespace of the module after it has been imported.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ImportException">ImportException</a></td><td><p>if no means of loading the module could be found, or if a module loader was found but failed when run. In the latter case, the exception that was thrown during module loading will be set as the cause of the exception.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="reload"></a>global function reload(name: string)<script>explorer.outline.addDecl('reload');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Very similar to <a href="modules.html#load">modules.load</a>, but reloads an already-loaded module. This function replaces step 1 of <a href="modules.html#load">modules.load</a>'s process with a check to see if the module has already been loaded; if it has, it continues on with the process. If it hasn't been loaded, throws an error.</p><p>It is also an error to reload any of the standard libraries or any included addons.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="runMain"></a>global function runMain(mod: namespace, vararg)<script>explorer.outline.addDecl('runMain');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Runs a function named "main" (if any) in the given namespace with the given arguments.</p><p>This will look in the given namespace for a field named <tt>main</tt>. If one exists, and that field is a function, that function will be called with the namespace as 'this' and any variadic arguments to <tt>runMain</tt> as the arguments. Otherwise, this function does nothing.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mod</td><td><p>The namespace in which to look.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">vararg</td><td><p>The arguments that will be passed to the <tt>main</tt> function.</p></td></tr></table><p><strong>Returns:</strong> <p>whatever <tt>main</tt> returns, or nothing if there is no <tt>main</tt> function.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 19 Oct 2014 12:09:25	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>