<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module gl</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("gl");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module gl</h1><p>OpenGL is a popular cross-platform API for rendering real-time 3D graphics. This module provides a relatively thin, unsafe wrapper over an OpenGL Core context, as well as a number of extensions.</p><p>Core contexts require OpenGL 3.0+ hardware (roughly equivalent to DirectX 10+). The choice to support only core contexts was made partly because the entire OpenGL Compatibility API is enormous and partly because let's be honest, it's been the better part of a decade since pre-OpenGL 3.0 hardware was manufactured. It's time to let go.</p><p>If it didn't sink in before: <strong>this library is very unsafe!</strong> In order to preserve as much performance as possible, no parameter validation (beyond typechecking) is performed. Furthermore, pointer parameters are very free in what they will accept and you can pass arbitrary integers to them. For some functions, this is necessary, but for others, this will just crash the host. Lastly, if you destroy the context from which the functions were loaded, chances are that calling them will <em>also</em> cause crashes.</p><p><strong>Prerequisites</strong></p><p>This module is currently loaded by the <a href="glfw.html">glfw</a> addon by initializing it, creating a window, making that window's context current, and then calling <a href="glfw.html#loadOpenGL">glfw.loadOpenGL</a>. There is currently no other way to load this library.</p><p>Once the above has been done, it can be accessed like any other module.</p><p><strong>OpenGL Versions</strong></p><p>This library supports up to and including OpenGL 4.5. It also supports many forward-compatibility ("Core Extensions"). A list of supported extensions is given <a href="gl.html#ext">here</a>.</p><p><strong>Type Constants</strong></p><p>Many OpenGL APIs take blobs of typed memory. The most obvious Croc type to use for this is the <a href="misc.html#Vector">Vector</a> class. To make it easier to create <tt>Vectors</tt> with the right types of values, there are string constants which hold <tt>Vector</tt> type codes for each of the OpenGL basic types. These include <tt>GLenum</tt>, <tt>GLboolean</tt>, <tt>GLbitfield</tt>, <tt>GLbyte</tt>, <tt>GLshort</tt>, <tt>GLint</tt>, <tt>GLubyte</tt>, <tt>GLushort</tt>, <tt>GLuint</tt>, <tt>GLsizei</tt>, <tt>GLfloat</tt>, <tt>GLclampf</tt>, <tt>GLdouble</tt>, and <tt>GLclampd</tt>. To use, just pass them as the type code when creating a <tt>Vector</tt>:</p><p><div class="code"><pre><span class="c1">// creates a Vector to be used as a 4x4 matrix</span>
<span class="k">local</span> <span class="n">matrix</span> <span class="p">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">gl</span><span class="p">.</span><span class="n">GLfloat</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="c1">// here we&#39;d fill the matrix with values...</span>
<span class="c1">// now we can pass the matrix to OpenGL by using its getMemblock method</span>
<span class="n">gl</span><span class="p">.</span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">myUniform</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="n">matrix</span><span class="p">.</span><span class="n">getMemblock</span><span class="p">())</span>
</pre></div>
In addition, there are integer constants for the byte size of each OpenGL basic type. These are named <tt>sizeof&lt;type&gt;</tt>, like <tt>sizeofGLenum</tt>, <tt>sizeofGLboolean</tt>, and so on.</p><p><strong><tt>glGen*</tt> and <tt>glDelete*</tt> functions</strong></p><p>The native versions of these functions (such as <tt>glGenBuffers</tt>, <tt>glDeleteBuffers</tt> etc.) take arrays of GLuints which will be filled with names or which contain names to be deleted. This way of doing things would be awkward in Croc, so instead these families of functions have been wrapped to be more Croc-friendly.</p><p>All the <tt>glGen*</tt> functions effectively have the signature <tt>glGenWhatever(num: int, arr: array = null)</tt>. <tt>num</tt> indicates how many names to generate. <tt>arr</tt> is an optional array to put the names into. If you pass nothing for <tt>arr</tt>, <tt>num</tt> cannot exceed 20, and the generated names will be returned as multiple values. If you pass an array for <tt>arr</tt>, <tt>num</tt> cannot exceed 1024, <tt>arr</tt> will be resized to <tt>num</tt> elements, the names will be placed in <tt>arr</tt>, and <tt>arr</tt> will be returned. For example:</p><p><div class="code"><pre><span class="c1">// generate 1 buffer</span>
<span class="k">local</span> <span class="n">buf</span> <span class="p">=</span> <span class="n">gl</span><span class="p">.</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">// generate 3 buffers</span>
<span class="k">local</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span> <span class="p">=</span> <span class="n">gl</span><span class="p">.</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">// generate 10 buffers, put them in the given array, and put that array in &#39;names&#39;</span>
<span class="k">local</span> <span class="n">names</span> <span class="p">=</span> <span class="n">gl</span><span class="p">.</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[])</span>
</pre></div>
All the <tt>glDelete*</tt> functions can be called one of two ways. One, you can pass a single array containing the names to delete; this array cannot exceed 1024 elements and all the elements must be integers. Two, you can pass between 1 and 1024 names as separate parameters to the function. To continue the above example:</p><p><div class="code"><pre><span class="c1">// delete the array of names</span>
<span class="n">gl</span><span class="p">.</span><span class="n">glDeleteBuffers</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

<span class="c1">// delete 4 buffers at once</span>
<span class="n">gl</span><span class="p">.</span><span class="n">glDeleteBuffers</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
</pre></div>
The following pairs of <tt>glGen*</tt>/<tt>glDelete*</tt> functions work like this:</p><p><ul><li><p><tt>glGenTextures</tt>/<tt>glDeleteTextures</tt></p></li><li><p><tt>glGenQueries</tt>/<tt>glDeleteQueries</tt></p></li><li><p><tt>glGenBuffers</tt>/<tt>glDeleteBuffers</tt></p></li><li><p><tt>glGenRenderbuffers</tt>/<tt>glDeleteRenderbuffers</tt></p></li><li><p><tt>glGenFramebuffers</tt>/<tt>glDeleteFramebuffers</tt></p></li><li><p><tt>glGenVertexArrays</tt>/<tt>glDeleteVertexArrays</tt></p></li><li><p><tt>glGenSamplers</tt>/<tt>glDeleteSamplers</tt></p></li><li><p><tt>glGenTransformFeedbacks</tt>/<tt>glDeleteTransformFeedbacks</tt></p></li><li><p><tt>glGenProgramPipelines</tt>/<tt>glDeleteProgramPipelines</tt></p></li><li><p><tt>glGenPerfMonitorsAMD</tt>/<tt>glDeletePerfMonitorsAMD</tt></p></li><li><p><tt>glGenSamplers</tt>/<tt>glDeleteSamplers</tt></p></li><li><p><tt>glGenProgramPipelines</tt>/<tt>glDeleteProgramPipelines</tt></p></li><li><p><tt>glGenTransformFeedbacks</tt>/<tt>glDeleteTransformFeedbacks</tt></p></li></ul></p><p><strong>Ugly APIs</strong></p><p>At present there are only a handful of APIs which are ugly to use from Croc, and they're all ugly since they take an output string buffer. You can use these by passing an appropriately-sized memblock and then decoding the text with the <tt>text</tt> library, but it's not the prettiest interface. It's recommended that you wrap these functions in your own.</p><p><ul><li><p><tt>glGetDebugMessageLog</tt></p></li><li><p><tt>glGetDebugMessageLogARB</tt></p></li><li><p><tt>glGetPerfMonitorCounterStringAMD</tt></p></li><li><p><tt>glGetPerfMonitorGroupStringAMD</tt></p></li></ul></p><p><strong>Unsupported APIs</strong></p><p>At present there are a number of APIs which are not available for one reason or another.</p><p><tt>glMultiDrawElements</tt> and <tt>glMultiDrawElementsBaseVertex</tt> are not wrapped because they take arrays of pointers (tricky to deal with), and all they're likely to do is just iterate over those arrays and call <tt>glDrawElements</tt> and <tt>glDrawElementsBaseVertex</tt> anyway. And you can do that yourself.</p><p><tt>glCreateSyncFromCLeventARB</tt> is not wrapped because it's a function for OpenCL interop and currently there is no OpenCL binding.</p><p><tt>glDebugMessageCallback</tt> is not wrapped because the debug message callback can occur on a different thread, and having two threads access the same Croc interpreter is crash city.</p><p>Lastly we have functions which return pointers whose size cannot be determined. Several functions return pointers, but the size of the memory block they point to can be determined, and so those functions return memblocks. No such luck with these functions. I'm not sure how to handle these (and for that matter, some of these seem to have zero documentation anywhere, so I don't even know how to begin).</p><p><ul><li><p><tt>glGetPointerv</tt></p></li><li><p><tt>glGetPointeri_vEXT</tt></p></li><li><p><tt>glGetPointerIndexedvEXT</tt></p></li><li><p><tt>glGetVertexArrayPointeri_vEXT</tt></p></li><li><p><tt>glGetVertexArrayPointervEXT</tt></p></li><li><p><tt>glGetBufferPointerv</tt></p></li><li><p><tt>glGetNamedBufferPointerv</tt></p></li><li><p><tt>glGetNamedBufferPointervEXT</tt></p></li><li><p><tt>glMapTexture2DINTEL</tt></p></li></ul></p><p><strong>Most APIs</strong></p><p>Most APIs look and act exactly like their native counterparts. I'm not going to list every wrapped function and its signature; you can look at <a href="https://www.opengl.org/sdk/docs/man/">the OpenGL reference</a> for that. What you need to know is how the parameter and return types of these functions map to Croc.</p><p>For parameters:</p><p><table><tr><td><p><strong>Original OpenGL Type</strong></p></td><td><p><strong>Croc Type</strong></p></td></tr><tr><td><p><tt>GLboolean</tt></p></td><td><p><tt>bool</tt></p></td></tr><tr><td><p><tt>GLenum</tt>, <tt>GLbitfield</tt>, <tt>GLbyte</tt>, <tt>GLshort</tt>, <tt>GLushort</tt>, <tt>GLint</tt>, <tt>GLuint</tt>, <tt>GLsizei</tt></p></td><td><p><tt>int</tt></p></td></tr><tr><td><p><tt>GLfloat</tt>, <tt>GLclampf</tt>, <tt>GLdouble</tt>, <tt>GLclampd</tt></p></td><td><p><tt>int|float</tt></p></td></tr><tr><td><p><tt>const GLchar*</tt></p></td><td><p><tt>string</tt></p></td></tr><tr><td><p>Any other pointer</p></td><td><p><tt>null|int|memblock</tt></p></td></tr></table></p><p>The last row bears explanation. For non-string pointer parameters, you can pass <tt>null</tt> (which means... null), a memblock, or an integer. Some APIs, like <tt>glVertexAttribPointer</tt>, double up the meaning of their pointer parameters and allow integers instead of "actual" pointers.</p><p>If you pass a memblock, keep in mind that OpenGL <em>will not keep a reference to your memblock</em>, so you are responsible for making sure it doesn't get collected while OpenGL is still using it. Most of the time this isn't a problem, since a lot of APIs which take pointers copy the data out of them, but it's something to keep in mind.</p><p>For return types: mostly the same. Some OpenGL APIs take output string buffers; these functions have instead been wrapped so they return a string (all other parameters are unaffected), or <tt>null</tt> if an error occurs. These functions include:</p><p><ul><li><p><tt>glGetProgramInfoLog</tt></p></li><li><p><tt>glGetShaderInfoLog</tt></p></li><li><p><tt>glGetShaderSource</tt></p></li><li><p><tt>glGetActiveUniformName</tt></p></li><li><p><tt>glGetActiveUniformBlockName</tt></p></li><li><p><tt>glGetActiveSubroutineUniformName</tt></p></li><li><p><tt>glGetActiveSubroutineName</tt></p></li><li><p><tt>glGetProgramPipelineInfoLog</tt></p></li><li><p><tt>glGetProgramResourceName</tt></p></li><li><p><tt>glGetObjectLabel</tt></p></li><li><p><tt>glGetObjectPtrLabel</tt></p></li><li><p><tt>glGetNamedStringARB</tt></p></li></ul></p><p>Any other functions whose signatures are different will be explained on a function-by-function basis.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="version"></a>global function version()<script>explorer.outline.addDecl("version");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the loaded OpenGL version as two integers, major and minor.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glMapBuffer"></a>global function glMapBuffer(target: int, access: int, mb: memblock = null)<script>explorer.outline.addDecl("glMapBuffer");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This function returns a pointer. Since we can determine the buffer's size, we can return the mapped buffer data as a memblock. You can pass a memblock to be used for this purpose as <tt>mb</tt>, but if not, one will be created for you. If you pass one, its data (if any) will be freed and it will become a view of the buffer data. In either case the resulting memblock will not own its data.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glShaderSource"></a>global function glShaderSource(shader: int, source: string)<script>explorer.outline.addDecl("glShaderSource");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This only differs from the native function in that the native function takes an array of strings whereas this takes a single string. You can join strings easily in Croc, so why bother!</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glGetVertexAttribPointerv"></a>global function glGetVertexAttribPointerv(index: int, name: int)<script>explorer.outline.addDecl("glGetVertexAttribPointerv");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the pointer as an integer rather than taking a pointer-to-pointer parameter.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glGetActiveAttrib"></a>global function glGetActiveAttrib(program: int, index: int)<script>explorer.outline.addDecl("glGetActiveAttrib");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>three values: an int of the type of the active attribute, an int of the size of the active attribute, and a string of the attribute's name.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glGetActiveUniform"></a>global function glGetActiveUniform(program: int, index: int)<script>explorer.outline.addDecl("glGetActiveUniform");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>three values: an int of the type of the active uniform, an int of the size of the active uniform, and a string of the uniform's name.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glMapBufferRange"></a>global function glMapBufferRange(target: int, offset: int, length: int, access: int, mb: memblock = null)<script>explorer.outline.addDecl("glMapBufferRange");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Works very similarly to <a href="gl.html#glMapBuffer">glMapBuffer</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glTransformFeedbackVaryings"></a>global function glTransformFeedbackVaryings(program: int, varyings: array, mode: int)<script>explorer.outline.addDecl("glTransformFeedbackVaryings");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The <tt>varyings</tt> parameter must be an array of strings. That's it.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glGetTransformFeedbackVarying"></a>global function glGetTransformFeedbackVarying(program: int, index: int)<script>explorer.outline.addDecl("glGetTransformFeedbackVarying");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>nothing if an error occurred. Otherwise, returns three values: an int of the type of the varying, an int of the size of the varying, and a string of the varying's name.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glGetUniformIndices"></a>global function glGetUniformIndices(program: int, names: array, indices: array)<script>explorer.outline.addDecl("glGetUniformIndices");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The <tt>names</tt> parameter must be an array of strings of names of uniforms. The <tt>indices</tt> array will be used as the output; it will be set to the same length as <tt>names</tt>, and will be filled with the uniform indices.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glFenceSync"></a>global function glFenceSync(condition: int, flags: int)<script>explorer.outline.addDecl("glFenceSync");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>an int which represents the <tt>GLsync</tt> object. This can be passed to functions which expect GLsync objects.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glCreateShaderProgramv"></a>global function glCreateShaderProgramv(type: int, source: string)<script>explorer.outline.addDecl("glCreateShaderProgramv");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Like <a href="gl.html#glShaderSource">glShaderSource</a>, takes a single string instead of an array of strings.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glMapNamedBuffer"></a>global function glMapNamedBuffer(name: int, access: int, mb: memblock = null)<script>explorer.outline.addDecl("glMapNamedBuffer");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Works just like <a href="gl.html#glMapBuffer">glMapBuffer</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glMapNamedBufferRange"></a>global function glMapNamedBufferRange(name: int, offset: int, length: int, access: int, mb: memblock = null)<script>explorer.outline.addDecl("glMapNamedBufferRange");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Works just like <a href="gl.html#glMapBufferRange">glMapBufferRange</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glCompileShaderIncludeARB"></a>global function glCompileShaderIncludeARB(shader: int, paths: array)<script>explorer.outline.addDecl("glCompileShaderIncludeARB");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Takes an array of include paths in <tt>paths</tt>, which must be an array of strings.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glMapNamedBufferEXT"></a>global function glMapNamedBufferEXT(name: int, access: int, mb: memblock = null)<script>explorer.outline.addDecl("glMapNamedBufferEXT");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Works just like <a href="gl.html#glMapNamedBuffer">glMapNamedBuffer</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="glMapNamedBufferRangeEXT"></a>global function glMapNamedBufferRangeEXT(name: int, offset: int, length: int, access: int, mb: memblock = null)<script>explorer.outline.addDecl("glMapNamedBufferRangeEXT");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Works just like <a href="gl.html#glMapNamedBufferRange">glMapNamedBufferRange</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="ext"></a>namespace ext<script>explorer.outline.addDecl("ext");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This namespace contains a boolean constant for each extension that this library supports. A <tt>true</tt> means this computer supports that extension, and a <tt>false</tt> means it doesn't. So if you want to know if the <tt>ARB_debug_output</tt> extension is supported, you just have to test for <tt>gl.ext.ARB_debug_output</tt>.</p><p>The following non-core extensions are supported:</p><p><ul><li><p><tt>AMD_gpu_shader_int64</tt></p></li><li><p><tt>AMD_interleaved_elements</tt></p></li><li><p><tt>AMD_occlusion_query_event</tt></p></li><li><p><tt>AMD_performance_monitor</tt></p></li><li><p><tt>AMD_sample_positions</tt></p></li><li><p><tt>AMD_sparse_texture</tt></p></li><li><p><tt>AMD_stencil_operation_extended</tt></p></li><li><p><tt>ARB_bindless_texture</tt></p></li><li><p><tt>ARB_cl_event</tt></p></li><li><p><tt>ARB_compute_variable_group_size</tt></p></li><li><p><tt>ARB_debug_output</tt></p></li><li><p><tt>ARB_draw_buffers_blend</tt></p></li><li><p><tt>ARB_geometry_shader4</tt></p></li><li><p><tt>ARB_indirect_parameters</tt></p></li><li><p><tt>ARB_instanced_arrays</tt></p></li><li><p><tt>ARB_robustness</tt></p></li><li><p><tt>ARB_sample_shading</tt></p></li><li><p><tt>ARB_shading_language_include</tt></p></li><li><p><tt>ARB_sparse_texture</tt></p></li><li><p><tt>EXT_depth_bounds_test</tt></p></li><li><p><tt>EXT_direct_state_access</tt></p></li><li><p><tt>INTEL_map_texture</tt></p></li><li><p><tt>KHR_blend_equation_advanced</tt></p></li><li><p><tt>NV_bindless_multi_draw_indirect</tt></p></li><li><p><tt>NV_bindless_multi_draw_indirect_count</tt></p></li><li><p><tt>NV_bindless_texture</tt></p></li><li><p><tt>NV_blend_equation_advanced</tt></p></li><li><p><tt>NV_copy_image</tt></p></li><li><p><tt>NV_depth_buffer_float</tt></p></li><li><p><tt>NV_explicit_multisample</tt></p></li><li><p><tt>NV_shader_buffer_load</tt></p></li><li><p><tt>NV_texture_barrier</tt></p></li><li><p><tt>NV_texture_multisample</tt></p></li><li><p><tt>NV_vertex_buffer_unified_memory</tt></p></li></ul></p><p>In addition, a number of "core" or "forward compatibility" extensions are supported. These are extensions which backport functionality from newer OpenGL versions to older hardware which can support them. For example, some OpenGL 4.0-class hardware might not support all the features necessary for OpenGL 4.5, but it might support a small subset. These extensions will let those older cards access the newer functionality.</p><p>Note that these extensions are only loaded if the OpenGL context is older than the version in which they were folded into core. The following lists the extensions and the version they became core functions (so any version lower than that, they may be supported):</p><p><table><tr><td><p><tt>GL_ARB_base_instance</tt></p></td><td><p>4.2</p></td></tr><tr><td><p><tt>GL_ARB_blend_func_extended</tt></p></td><td><p>3.3</p></td></tr><tr><td><p><tt>GL_ARB_buffer_storage</tt></p></td><td><p>4.4</p></td></tr><tr><td><p><tt>GL_ARB_clear_buffer_object</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_clear_texture</tt></p></td><td><p>4.4</p></td></tr><tr><td><p><tt>GL_ARB_compute_shader</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_copy_image</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_draw_elements_base_vertex</tt></p></td><td><p>3.2</p></td></tr><tr><td><p><tt>GL_ARB_draw_indirect</tt></p></td><td><p>4.0</p></td></tr><tr><td><p><tt>GL_ARB_ES2_compatibility</tt></p></td><td><p>4.1</p></td></tr><tr><td><p><tt>GL_ARB_framebuffer_no_attachments</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_get_program_binary</tt></p></td><td><p>4.1</p></td></tr><tr><td><p><tt>GL_ARB_gpu_shader_fp64</tt></p></td><td><p>4.0</p></td></tr><tr><td><p><tt>GL_ARB_internalformat_query</tt></p></td><td><p>4.2</p></td></tr><tr><td><p><tt>GL_ARB_internalformat_query2</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_invalidate_subdata</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_multi_bind</tt></p></td><td><p>4.4</p></td></tr><tr><td><p><tt>GL_ARB_multi_draw_indirect</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_program_interface_query</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_provoking_vertex</tt></p></td><td><p>3.2</p></td></tr><tr><td><p><tt>GL_ARB_sampler_objects</tt></p></td><td><p>3.3</p></td></tr><tr><td><p><tt>GL_ARB_separate_shader_objects</tt></p></td><td><p>4.1</p></td></tr><tr><td><p><tt>GL_ARB_shader_atomic_counters</tt></p></td><td><p>4.2</p></td></tr><tr><td><p><tt>GL_ARB_shader_image_load_store</tt></p></td><td><p>4.2</p></td></tr><tr><td><p><tt>GL_ARB_shader_storage_buffer_object</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_shader_subroutine</tt></p></td><td><p>4.0</p></td></tr><tr><td><p><tt>GL_ARB_sync</tt></p></td><td><p>3.2</p></td></tr><tr><td><p><tt>GL_ARB_tessellation_shader</tt></p></td><td><p>4.0</p></td></tr><tr><td><p><tt>GL_ARB_texture_buffer_range</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_texture_multisample</tt></p></td><td><p>3.2</p></td></tr><tr><td><p><tt>GL_ARB_texture_storage</tt></p></td><td><p>4.2</p></td></tr><tr><td><p><tt>GL_ARB_texture_storage_multisample</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_texture_view</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_timer_query</tt></p></td><td><p>3.3</p></td></tr><tr><td><p><tt>GL_ARB_transform_feedback2</tt></p></td><td><p>4.0</p></td></tr><tr><td><p><tt>GL_ARB_transform_feedback3</tt></p></td><td><p>4.0</p></td></tr><tr><td><p><tt>GL_ARB_transform_feedback_instanced</tt></p></td><td><p>4.2</p></td></tr><tr><td><p><tt>GL_ARB_vertex_attrib_64bit</tt></p></td><td><p>4.1</p></td></tr><tr><td><p><tt>GL_ARB_vertex_attrib_binding</tt></p></td><td><p>4.3</p></td></tr><tr><td><p><tt>GL_ARB_vertex_type_2_10_10_10_rev</tt></p></td><td><p>3.3</p></td></tr><tr><td><p><tt>GL_ARB_viewport_array</tt></p></td><td><p>4.1</p></td></tr><tr><td><p><tt>GL_KHR_debug</tt></p></td><td><p>4.3</p></td></tr></table></p><script>explorer.outline.incSymbolLevel();</script><dl></dl><script>explorer.outline.decSymbolLevel();</script></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 15 Nov 2014 10:28:14	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("imgui");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>