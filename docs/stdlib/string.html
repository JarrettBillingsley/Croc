<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module string</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("string");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module string</h1><p>The string library provides functionality for manipulating strings, as well as a mutable string type.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string"></a>namespace string<script>explorer.outline.addDecl("string");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This is the method namespace for string objects. All the string manipulation functions are accessed as methods of strings, e.g. <tt>s.reverse()</tt>.</p><p>Remember that strings in Croc are immutable. These method never operate on the object on which they were called. They will always return new strings distinct from the original string.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.format"></a>function string.format(vararg)<script>explorer.outline.addDecl("string.format");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Creates a formatted output string by converting the parameters to strings and inserting them as specified by <tt>this</tt>, the format string.</p><p>The formatting syntax resembles .Net or ICU's, using { curly braces } to indicate where formatted components should be inserted, rather than the printf-like percent signs.</p><p>The syntax is as follows:</p><p><pre>FormatString:
	Text (FormatSpecifier Text)*

Text:
	AnythingButLeftBrace*
	'{{'

FormatSpecifier:
	'{' Index? (',' Width)? (':' Fmt)? '}'
	'{r' Index? (',' Width)? '}'

Index:
	Digit+

Width:
	Digit+

Fmt:
	AnythingButRightBrace*</pre>Format specifiers begin with '{' and end with '}'. If you want to have an open-brace character in the output string, just double up the opening brace like '{{'. There is no need to double up a close-brace like this.</p><p>Let's look at what happens when a format specifier is encountered:</p><p><ol type="1"><li><p>The appropriate argument is selected from the list of variadic arguments as explained above. Call it <em>arg</em>.</p></li><li><p><em>arg</em> is converted to a string, in some way. Call the resulting string <em>str</em>.</p></li><li><p><em>str</em> is optionally padded with spaces on one side or the other, and added to the output string.</p></li></ol></p><p>First is step 1: selecting the appropriate argument. This is the <tt>Index</tt> in the above grammar. The index is a 0-based index into the variadic arguments passed to this method. You can use the same parameter multiple times by using the same index multiple times, like in <tt>"{0} {0}".format(5)</tt>, which will give the string <tt>"5 5"</tt>. If no index is given, an internal counter is used instead. This counter starts at 0 and increases by 1 each time a format specifier without an index is read. So in <tt>"{} {}".format(3, 4)</tt>, the result will be the string <tt>"3 4"</tt>. You can interleave these kinds of indices. Explicit indices do not reset the counter, so <tt>"{} {0} {}".format(1, 2)</tt> gives the string <tt>"1 1 2"</tt>. Specifying an index out of the bounds of the variadic arguments is an error.</p><p>Next is step 2: converting the argument <em>arg</em> to a string. There are two kinds of format specifiers, regular and raw, and they differ on this step.</p><p>Raw format specifiers have a lowercase <tt>'r'</tt> immediately after the opening brace. They can only specify a parameter index and a width, and no format string. A raw format specifier converts <em>arg</em> to a string by calling <a href="misc.html#rawToString">rawToString</a> on it. That's it.</p><p>A regular format specifier (one without a lowercase <tt>'r'</tt> after the opening brace) can have an optional <em>format string</em>, which is everything between the colon and closing brace. If no format string is given, <a href="misc.html#toString">toString</a> is called on <em>arg</em> and the resulting string is used in step 3. If a format string is given, how it's interpreted depends on the type of <em>arg</em>:</p><p><ul><li><p>If <em>arg</em> is an <tt>int</tt>, the format string must be of the format <tt>('+'|' ')? '#'? Width? Type?</tt>. This is a subset of the format specifiers for C's printf family, and they work the same.</p><p>The optional <tt>'+'</tt> or <tt>' '</tt> flags at the beginning will prepend positive numbers with a plus sign or a space, respectively (to make them line up nicely with negative numbers in tables).</p><p>Next comes the optional <tt>'#'</tt>, which changes the way binary and hexadecimal numbers are displayed.</p><p>Then comes the number width, which is separate from the format specifier width. The number width controls the minimum number of digits that will be displayed; if the number is fewer than this many digits, it is padded with 0s to the left.</p><p>Last comes the type, which controls the radix and signedness of the output. The type can be:</p><p><ul><li><p><tt>'d'</tt> or <tt>'i'</tt>, which outputs the number as signed base-10. This is the default.</p></li><li><p><tt>'u'</tt>, which outputs the number as unsigned base-10. This will make negative numbers output as large positive numbers instead.</p></li><li><p><tt>'b'</tt> or <tt>'B'</tt>, which outputs the number in base 2 (binary). If the <tt>'#'</tt> flag was given, the number will be prepended with <tt>'0b'</tt> or <tt>'0B'</tt>, respectively. These prefixes do <em>not</em> count towards the number width.</p></li><li><p><tt>'x'</tt> or <tt>'X'</tt>, which outputs the number in base 16 (hexadecimal). If the <tt>'#'</tt> flag was given, the number will be prepended with <tt>'0x'</tt> or <tt>'0X'</tt>, respectively. These prefixes do <em>not</em> count towards the number width.</p></li><li><p><tt>'r'</tt> or <tt>'R'</tt>, followed by one or more digits. This lets you specify an arbitrary base in the range 2 to 36 inclusive. Using <tt>'r'</tt> will use lowercase letters for digits above 9, and <tt>'R'</tt> will use uppercase letters. <tt>'r2'</tt> will behave exactly as <tt>'b'</tt>, and <tt>'r16'</tt> will behave exactly as <tt>'x'</tt>, including respecting the <tt>'#'</tt> flag. <tt>'r10'</tt> will behave exactly as <tt>'d'</tt> or <tt>'i'</tt>.</p></li></ul></p></li><li><p>If <em>arg</em> is a <tt>float</tt>, the format string must be of the format <tt>('+'|' ')? '#'? ('.' Precision?)? Type?</tt>. Again, this is (mostly) a subset of the format specifiers for C's printf family, and they work the same.</p><p>The optional <tt>'+'</tt> or <tt>' '</tt> flags at the beginning will prepend positive numbers with a plus sign or a space, respectively (to make them line up nicely with negative numbers in tables).</p><p>The optional <tt>'#'</tt> flag only does anything for the <tt>'f'</tt> format (explained below). If given, it will strip extra 0s after the first place after the decimal point, similar to how <tt>'g'</tt> works by default. This flag isn't part of the normal C printf behavior, and if given for <tt>'e'</tt> or <tt>'g'</tt> formats, it has no effect.</p><p>Next comes the optional precision, which is just an integer and whose meaning depends on the type.</p><p>Last is the type, which can be:</p><p><ul><li><p><tt>'e'</tt> or <tt>'E'</tt>, which outputs the number in "scientific" notation, or at least an ASCII version of scientific notation. For this format, the precision controls how many places appear after the decimal point; the default is 6. The only difference between lower- and upper-case is how the exponent appears (it will match the case of the type specifier).</p></li><li><p><tt>'f'</tt> which outputs the number in "human" notation, which never uses scientific notation. The precision controls how many places appear after the decimal point; the default is 6.</p></li><li><p><tt>'g'</tt> or <tt>'G'</tt>, which outputs the number in human or scientific notation, whichever is shorter. The precision for this format behaves differently, as it controls the <em>maximum</em> number of digits that appear, before and after the decimal point. Trailing zeroes are also trimmed, and if the decimal part is zero, no decimal point is printed.</p></li></ul></p></li><li><p>For all other types, the format string is uninterpreted. Instead, if <em>arg</em> has a method named <tt>toStringFmt</tt>, it will call the method called with the format string as the argument, and it should return a string. If there is no method of that name, or the method doesn't return a string, it is an error.</p></li></ul></p><p>Finally, we come to step 3, where the width specifier comes in. The width specifies a <em>minimum</em> width, in characters, which the outputted string for that argument (<em>str</em> from above) should be. If the length of <em>str</em> is less than this width, it is padded with spaces up to the width. If the length of <em>str</em> is the same or greater than the width, <em>str</em> is output as-is (it is <em>not</em> truncated down to the width).</p><p>If the width is positive, <em>str</em> will be right-aligned, meaning it will be padded with spaces on the left. If the width is negative, <em>str</em> will be left-aligned, padded with spaces on the left. The default width is 0, so no padding will be added. Here is an example:</p><p><div class="code"><pre><span class="n">writeln</span><span class="p">(</span><span class="s">&quot;&#39;{}&#39;&quot;</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1234</span><span class="p">))</span> <span class="c1">// prints &#39;1234&#39;, no padding added</span>
<span class="n">writeln</span><span class="p">(</span><span class="s">&quot;&#39;{,0}&#39;&quot;</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1234</span><span class="p">))</span> <span class="c1">// prints &#39;1234&#39;, identical meaning to above</span>
<span class="n">writeln</span><span class="p">(</span><span class="s">&quot;&#39;{,6}&#39;&quot;</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1234</span><span class="p">))</span> <span class="c1">// prints &#39;  1234&#39;; padded out on left to 6 characters</span>
<span class="n">writeln</span><span class="p">(</span><span class="s">&quot;&#39;{,-6}&#39;&quot;</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1234</span><span class="p">))</span> <span class="c1">// prints &#39;1234  &#39;; padded out on right to 6 characters</span>
</pre></div>
</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">vararg</td><td><p>are the arguments to be formatted according to the format string.</p></td></tr></table><p><strong>Returns:</strong> <p>the resulting string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.join"></a>function string.join(arr: array)<script>explorer.outline.addDecl("string.join");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The inverse of the <a href="string.html#string.split">split</a> method. This joins together the elements of <tt>arr</tt> using <tt>this</tt> as the separator.</p><p>The elements of <tt>arr</tt> must all be strings. If <tt>this</tt> is the empty string, this just concatenates all the elements of <tt>arr</tt> together. If <tt>#arr</tt> is 0, returns the empty string. If <tt>#arr</tt> is 1, returns <tt>arr[0]</tt>. Otherwise, returns the elements joined sequentially with the separator <tt>this</tt> between each pair of arguments. So "<tt>".".join(["apple", "banana", "orange"])</tt>" will yield the string <tt>"apple.banana.orange"</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#TypeError">TypeError</a></td><td><p>if any element of <tt>arr</tt> is not a string.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.vjoin"></a>function string.vjoin(vararg)<script>explorer.outline.addDecl("string.vjoin");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Like <a href="string.html#string.join">join</a>, but joins its list of variadic parameters instead of an array. The functionality is otherwise identical. So "<tt>".".join("apple", "banana", "orange")</tt>" will give the string <tt>"apple.banana.orange"</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#TypeError">TypeError</a></td><td><p>if any of the varargs is not a string.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.toInt"></a>function string.toInt(base: int = 10)<script>explorer.outline.addDecl("string.toInt");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Converts <tt>this</tt> into an integer. The optional <tt>base</tt> parameter defaults to 10, but you can use any base between 2 and 36 inclusive.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if the string does not follow the format of an integer.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.toFloat"></a>function string.toFloat()<script>explorer.outline.addDecl("string.toFloat");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Converts <tt>this</tt> into a float.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if the string does not follow the format of a float.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.ord"></a>function string.ord(idx: int = 0)<script>explorer.outline.addDecl("string.ord");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the integer codepoint value of the character at the given index, which defaults to 0.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>is the index into <tt>this</tt>, which can be negative.</p></td></tr></table><p><strong>Returns:</strong> <p>the integer codepoint value of the character at <tt>this[idx]</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>idx</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.find"></a>function string.find(sub: string, start: int = 0)<script>explorer.outline.addDecl("string.find");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Searches for an occurence of <tt>sub</tt> in <tt>this</tt>.</p><p>The search starts from <tt>start</tt> (which defaults to the first character) and goes right. If <tt>sub</tt> is found, this function returns the integer index of the occurrence in the string, with 0 meaning the first character. Otherwise, if <tt>sub</tt> cannot be found, <tt>#this</tt> is returned.</p><p><tt>start</tt> can be negative, in which case it's treated as an index from the end of the string.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>start</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.rfind"></a>function string.rfind(sub: string, start: int = #s - 1)<script>explorer.outline.addDecl("string.rfind");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reverse find. Works similarly to <tt>find</tt>, but the search starts with the character at <tt>start</tt> (which defaults to the last character) and goes <em>left</em>.</p><p>If <tt>sub</tt> is found, this function returns the integer index of the occurrence in the string, with 0 meaning the first character. Otherwise, if <tt>sub</tt> cannot be found, <tt>#this</tt> is returned.</p><p><tt>start</tt> can be negative, in which case it's treated as an index from the end of the string.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>start</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.repeat"></a>function string.repeat(n: int)<script>explorer.outline.addDecl("string.repeat");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a string which is the concatenation of <tt>n</tt> instances of <tt>this</tt>. So <tt>"hello".repeat(3)</tt> will return <tt>"hellohellohello"</tt>. If <tt>n == 0</tt>, returns the empty string.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>n &lt; 0</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.reverse"></a>function string.reverse()<script>explorer.outline.addDecl("string.reverse");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a string which is the reversal of <tt>this</tt>. Only the codepoints are reversed; no higher-level structure (such as combining marks) is preserved.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.split"></a>function string.split(delim: string)<script>explorer.outline.addDecl("string.split");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The inverse of the <a href="string.html#string.join">join</a> method. Splits <tt>this</tt> into pieces and returns an array of the split pieces.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">delim</td><td><p>specifies a delimiting string where <tt>this</tt> will be split. So <tt>"one--two--three".split("--")</tt> will return <tt>["one", "two", "three"]</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.vsplit"></a>function string.vsplit(delim: string)<script>explorer.outline.addDecl("string.vsplit");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="string.html#string.split">split</a>, but instead of returning an array, returns the split pieces as multiple return values. It's the inverse of <a href="string.html#string.vjoin">vjoin</a>.</p><p><tt>"one--two".split("--")</tt> will return <tt>"one", "two"</tt>. If the string splits into more than 20 pieces, an error will be thrown (as returning many values can be a memory problem). Otherwise the behavior is identical to <a href="string.html#string.split">split</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.splitWS"></a>function string.splitWS()<script>explorer.outline.addDecl("string.splitWS");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="string.html#string.split">split</a>, but splits at whitespace (spaces, tabs, newlines etc.).</p><p>All the whitespace is stripped from the split pieces, and there will be no empty pieces between consecutive whitespace characters. Thus <tt>"one\t\ttwo".split()</tt> will return <tt>["one", "two"]</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.vsplitWS"></a>function string.vsplitWS()<script>explorer.outline.addDecl("string.vsplitWS");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Like <a href="string.html#string.splitWS">splitWS</a>, but returns multiple values like <a href="string.html#string.vsplit">vsplit</a>. Again, if the string splits into more than 20 pieces, an error will be thrown.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.splitLines"></a>function string.splitLines()<script>explorer.outline.addDecl("string.splitLines");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This will split the string at any newline characters (<tt>'\n'</tt>, <tt>'\r'</tt>, or <tt>'\r\n'</tt>), removing the line ending characters. Other whitespace is preserved, and empty lines are preserved. This returns an array of strings, each of which holds one line of text.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.vsplitLines"></a>function string.vsplitLines()<script>explorer.outline.addDecl("string.vsplitLines");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Like <a href="string.html#string.splitLines">splitLines</a>, but returns multiple values like <a href="string.html#string.vsplit">vsplit</a>. Same deal!</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.partition"></a>function string.partition(splitter: string)<script>explorer.outline.addDecl("string.partition");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Given a splitter, splits this string into three pieces: the part before the splitter, the splitter, and the part after the splitter. Returns those pieces as multiple values.</p><p>If this string has a length of 0, returns three empty strings instead.</p><p>If the splitter isn't found in the string, the first piece returned will be this string, and the second and third pieces will be empty strings.</p><p>The second piece is returned so you can tell whether or not the splitter was found.</p><p>You can use this method to split a string into pieces in a loop more efficiently than using <a href="string.html#string.find">find</a>, since multiple uses of that with increasing start indices will give you a quadratic-time loop. Of course if you need all the pieces at once, using <a href="string.html#string.split">split</a> or one of its siblings is better.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">splitter</td><td><p>is the string that will be used to partition this string. Cannot be empty.</p></td></tr></table><p><strong>Returns:</strong> <p>three values as described above.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.rpartition"></a>function string.rpartition(splitter: string)<script>explorer.outline.addDecl("string.rpartition");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Works almost exactly like <a href="string.html#string.partition">partition</a>, except it splits on the <em>last</em> occurrence of <tt>splitter</tt>, rather than the first.</p><p>In the case that <tt>splitter</tt> is not found, the <em>first</em> two pieces returned will be empty, and the third will be this string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.strip"></a>function string.strip()<script>explorer.outline.addDecl("string.strip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Strips any whitespace from the beginning and end of the string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.lstrip"></a>function string.lstrip()<script>explorer.outline.addDecl("string.lstrip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Strips any whitespace from just the beginning of the string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.rstrip"></a>function string.rstrip()<script>explorer.outline.addDecl("string.rstrip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Strips any whitespace from just the end of the string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.replace"></a>function string.replace(from: string, to: string)<script>explorer.outline.addDecl("string.replace");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Replaces any occurrences in <tt>this</tt> of the string <tt>from</tt> with the string <tt>to</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.startsWith"></a>function string.startsWith(other: string)<script>explorer.outline.addDecl("string.startsWith");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a bool indicating whether or not <tt>this</tt> starts with the substring <tt>other</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.endsWith"></a>function string.endsWith(other: string)<script>explorer.outline.addDecl("string.endsWith");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a bool indicating whether or not <tt>this</tt> ends with the substring <tt>other</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="string.opApply"></a>function string.opApply(mode: string = null)<script>explorer.outline.addDecl("string.opApply");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This allows you to iterate over the individual characters of the string with a <tt>foreach</tt> loop. It gives two indices, the first being the character offset and the second being the character as a string.</p><p><div class="code"><pre><span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
	<span class="n">writefln</span><span class="p">(</span><span class="s">&quot;string[{}] = {}&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;reverse&quot;</span><span class="p">)</span>
	<span class="n">writefln</span><span class="p">(</span><span class="s">&quot;string[{}] = {}&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
As this example shows, if you pass "reverse" as the second part of the <tt>foreach</tt> container, the iteration will go in reverse, starting at the end of the string.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer"></a>class StringBuffer<script>explorer.outline.addDecl("StringBuffer");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Croc's strings are immutable. While this makes dealing with strings much easier in most cases, it also introduces inefficiency for some operations, such as performing text modification on large pieces of textual data. <tt>StringBuffer</tt> is a mutable string class that makes these sorts of things possible. It's mutable, and stores the data in a way that makes indexing and slicing constant time instead of linear time.</p><p>While this class is good for complex text manipulation, if you just need to build up a string piecewise, using this class will be less efficient than just appending pieces to an array and then using the string <tt>join</tt> method on it.</p><p>A note on some of the methods: as per the standard library convention, there are some methods which have two versions, one of which operates in-place, and the other which returns a new object and leaves the original unchanged. In this case, the in-place version's name has an exclamation point appended, while the non- modifying version has none. For example, <a href="string.html#StringBuffer.reverse">reverse</a> will create a new <tt>StringBuffer</tt>, whereas <a href="string.html#StringBuffer.reverse!">reverse!</a> will modify the given one in place.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.this"></a>StringBuffer.this(init: string|int = null)<script>explorer.outline.addDecl("StringBuffer.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>If you pass nothing to the constructor, the <tt>StringBuffer</tt> will be empty. If you pass a string, the <tt>StringBuffer</tt> will be filled with that string's data. If you pass an integer, it means how much space, in characters, should be preallocated in the buffer. However, the length of the <tt>StringBuffer</tt> will still be 0; it's just that no memory will have to be allocated until you put at least <tt>init</tt> characters into it.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>init</tt> is a negative integer or is an integer so large that the memory cannot be allocated.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.dup"></a>function StringBuffer.dup()<script>explorer.outline.addDecl("StringBuffer.dup");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Creates a new <tt>StringBuffer</tt> that is a duplicate of this one. Its length and contents will be identical.</p><p><strong>Returns:</strong> <p>the new <tt>StringBuffer</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.toString"></a>function StringBuffer.toString(lo: int = 0, hi: int = #this)<script>explorer.outline.addDecl("StringBuffer.toString");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Converts this <tt>StringBuffer</tt> to a string.</p><p>You can optionally slice out only a part of the buffer to turn into a string with the <tt>lo</tt> and <tt>hi</tt> parameters, which work like regular slice indices.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if the slice boundaries are invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opEquals"></a>function StringBuffer.opEquals(other: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.opEquals");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Compares this <tt>StringBuffer</tt> to a <tt>string</tt> or another <tt>StringBuffer</tt> for equality. Works the same as string equality.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opCmp"></a>function StringBuffer.opCmp(other: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.opCmp");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Compares this <tt>StringBuffer</tt> to a <tt>string</tt> or other <tt>StringBuffer</tt>. Works the same as string comparison.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opLength"></a>function StringBuffer.opLength()<script>explorer.outline.addDecl("StringBuffer.opLength");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the length of this <tt>StringBuffer</tt> in characters. Note that this is just the number of characters currently in use; if you preallocate space either with the constructor or by setting the length longer and shorter, the true size of the underlying buffer will not be reported.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opLengthAssign"></a>function StringBuffer.opLengthAssign(len: int)<script>explorer.outline.addDecl("StringBuffer.opLengthAssign");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Sets the length of this <tt>StringBuffer</tt>. If you increase the length, the new characters will be filled with U+00FFFF. If you decrease the length, characters will be truncated. Note that when you increase the length of the buffer, memory may be overallocated to avoid allocations on every size increase. When you decrease the length of the buffer, that memory is not deallocated, so you can reserve memory for a <tt>StringBuffer</tt> by setting its length to the size you need and then setting it back to 0, like so:</p><p><div class="code"><pre><span class="k">local</span> <span class="n">s</span> <span class="p">=</span> <span class="n">StringBuffer</span><span class="p">()</span>
<span class="p">#</span><span class="n">s</span> <span class="p">=</span> <span class="mi">1000</span>
<span class="p">#</span><span class="n">s</span> <span class="p">=</span> <span class="mi">0</span>
<span class="c1">// now s can hold up to 1000 characters before it will have to reallocate its memory.</span>
</pre></div>
Note that in the above example, simply doing <tt>local s = StringBuffer(1000)</tt> will have the same effect.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>len</tt> is negative or is so large that the memory cannot be allocated.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opIndex"></a>function StringBuffer.opIndex(idx: int)<script>explorer.outline.addDecl("StringBuffer.opIndex");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the character at the given index as a string.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if the index is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opIndexAssign"></a>function StringBuffer.opIndexAssign(idx: int, c: string)<script>explorer.outline.addDecl("StringBuffer.opIndexAssign");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Sets the character at the given index to the given character.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if the index is invalid.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if <tt>#c != 1</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opCat"></a>function StringBuffer.opCat(o)<script>explorer.outline.addDecl("StringBuffer.opCat");</script></span><br/><span class="decl"><a id="StringBuffer.opCat_r"></a>function StringBuffer.opCat_r(o)<script>explorer.outline.addDecl("StringBuffer.opCat_r");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Concatenates this <tt>StringBuffer</tt> with another value and returns a <strong>new</strong> <tt>StringBuffer</tt> containing the concatenation. If you want to instead add data to the beginning or end of a <tt>StringBuffer</tt>, use the <a href="string.html#StringBuffer.opCatAssign">opCatAssign</a> or <a href="string.html#StringBuffer.insert">insert</a> methods.</p><p>Any type can be concatenated with a <tt>StringBuffer</tt>; if it isn't a string or another <tt>StringBuffer</tt>, it will have its <tt>toString</tt> method called on it and the result will be concatenated.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opCatAssign"></a>function StringBuffer.opCatAssign(vararg)<script>explorer.outline.addDecl("StringBuffer.opCatAssign");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Also aliased to <tt>append</tt>.</strong> Appends its parameters to the end of this <tt>StringBuffer</tt>.</p><p>Each parameter will have <tt>toString</tt> called on it (unless it's a <tt>StringBuffer</tt> itself, so no <tt>toString</tt> is necessary), and the resulting string will be appended to the end of this <tt>StringBuffer</tt>'s data.</p><p>You can either use the <tt>~=</tt> operators to use this method, or you can call the <tt>append</tt> method; both are aliased to the same method and do the same thing. Thus, <tt>"s ~= a ~ b ~ c"</tt> is functionally identical to <tt>"s.append(a, b, c)"</tt> and vice versa.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if the size of the buffer grows so large that the memory cannot be allocated.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opSlice"></a>function StringBuffer.opSlice(lo: int = 0, hi: int = #this)<script>explorer.outline.addDecl("StringBuffer.opSlice");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Slices data out of this <tt>StringBuffer</tt> and creates a new <tt>StringBuffer</tt> with that slice of data. Works just like string slicing.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.fill"></a>function StringBuffer.fill(v: string|array|function|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.fill");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A flexible way to fill a <tt>StringBuffer</tt> with some data. This only modifies existing data; the buffer's length is never changed.</p><p>If you pass a string, it must be the same length as the buffer, and the string's data is copied into the buffer.</p><p>If you pass an array, it must be the same length of the buffer and all its elements must be one-character strings. The character values of those strings will be copied into the buffer.</p><p>If you pass a <tt>StringBuffer</tt>, it must be the same length as the buffer and its data will be copied into this buffer.</p><p>If you pass a function, it must take an integer and return a one-character string. It will be called on each location in the buffer, and the resulting characters will be put into the buffer.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.fillRange"></a>function StringBuffer.fillRange(lo: int = 0, hi: int = #this, v: string|array|function|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.fillRange");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Also aliased to <tt>opSliceAssign</tt>.</strong></p><p>Works just like <a href="string.html#StringBuffer.fill">fill</a>, except it works on just a subrange of the buffer. The <tt>lo</tt> and <tt>hi</tt> params work just like slice indices - low inclusive, high noninclusive, negative from the end.</p><p>You can either call this method directly, or you can use slice-assignment; they are aliased to the same method and do the same thing. Thus, <tt>"s.fillRange(x, y, z)"</tt> is functionally identical to <tt>"s[x .. y] = z"</tt> and vice versa.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.fillChar"></a>function StringBuffer.fillChar(ch: string, lo: int = 0, hi: int = #this)<script>explorer.outline.addDecl("StringBuffer.fillChar");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Sets every character to the character given by <tt>ch</tt>, which must be a one-character string. Can optionally just set the characters of a slice given by <tt>lo</tt> and <tt>hi</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.insert"></a>function StringBuffer.insert(idx: int, val)<script>explorer.outline.addDecl("StringBuffer.insert");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Inserts the string representation of <tt>val</tt> before the character indexed by <tt>idx</tt>. <tt>idx</tt> can be negative, which means an index from the end of the buffer. It can also be the same as the length of this <tt>StringBuffer</tt>, in which case the behavior is identical to appending.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.remove"></a>function StringBuffer.remove(lo: int, hi: int = lo + 1)<script>explorer.outline.addDecl("StringBuffer.remove");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Removes characters from a <tt>StringBuffer</tt>, shifting the data after them (if any) down. The indices work like slice indices. The <tt>hi</tt> index defaults to one more than the <tt>lo</tt> index, so you can remove a single character by just passing the <tt>lo</tt> index.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.find"></a>function StringBuffer.find(sub: string|StringBuffer, start: int = 0)<script>explorer.outline.addDecl("StringBuffer.find");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Searches for an occurence of <tt>sub</tt> in <tt>this</tt>. <tt>sub</tt> can be a string or another <tt>StringBuffer</tt>. The search starts from <tt>start</tt> (which defaults to the first character) and goes right. If <tt>sub</tt> is found, this function returns the integer index of the occurrence in the string, with 0 meaning the first character. Otherwise, if <tt>sub</tt> cannot be found, <tt>#this</tt> is returned.</p><p>If <tt>start &lt; 0</tt> it is treated as an index from the end of <tt>this</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>start</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.rfind"></a>function StringBuffer.rfind(sub: string|StringBuffer, start: int = #this - 1)<script>explorer.outline.addDecl("StringBuffer.rfind");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Reverse find. Works similarly to <tt>find</tt>, but the search starts with the character at <tt>start</tt> (which defaults to the last character) and goes <em>left</em>. If <tt>sub</tt> is found, this function returns the integer index of the occurrence in the string, with 0 meaning the first character. Otherwise, if <tt>sub</tt> cannot be found, <tt>#this</tt> is returned.</p><p>If <tt>start &lt; 0</tt> it is treated as an index from the end of <tt>this</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>start</tt> is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.startsWith"></a>function StringBuffer.startsWith(other: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.startsWith");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a bool of whether or not <tt>this</tt> starts with the substring <tt>other</tt>. This is case-sensitive.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.endsWith"></a>function StringBuffer.endsWith(other: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.endsWith");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a bool of whether or not <tt>this</tt> ends with the substring <tt>other</tt>. This is case-sensitive.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.split"></a>function StringBuffer.split(delim: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.split");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Splits <tt>this</tt> into pieces (each piece being a new <tt>StringBuffer</tt>) and returns an array of the split pieces.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">delim</td><td><p>specifies a delimiting string where <tt>this</tt> will be split.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.vsplit"></a>function StringBuffer.vsplit(delim: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.vsplit");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="string.html#StringBuffer.split">split</a>, but instead of returning an array, returns the split pieces as multiple return values. If <tt>this</tt> splits into more than 20 pieces, an error will be thrown (as returning many values can be a memory problem). Otherwise the behavior is identical to <a href="string.html#StringBuffer.split">split</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.splitWS"></a>function StringBuffer.splitWS()<script>explorer.outline.addDecl("StringBuffer.splitWS");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="string.html#StringBuffer.split">split</a>, but splits at whitespace (spaces, tabs, newlines etc.), and all the whitespace is stripped from the split pieces. No empty pieces will be returned.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.vsplitWS"></a>function StringBuffer.vsplitWS()<script>explorer.outline.addDecl("StringBuffer.vsplitWS");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="string.html#StringBuffer.vsplit">vsplit</a> in that it returns multiple values, but works like <a href="string.html#StringBuffer.splitWS">splitWS</a> instead. If <tt>this</tt> splits into more than 20 pieces, an error will be thrown (as returning many values can be a memory problem). Otherwise the behavior is identical to <a href="string.html#StringBuffer.splitWS">splitWS</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.splitLines"></a>function StringBuffer.splitLines()<script>explorer.outline.addDecl("StringBuffer.splitLines");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This will split <tt>this</tt> at any newline characters (<tt>'\n'</tt>, <tt>'\r'</tt>, or <tt>'\r\n'</tt>). The newline characters will be removed. Other whitespace is preserved, and empty lines are preserved. This returns an array of <tt>StringBuffer</tt>s, each of which holds one line of text.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.vsplitLines"></a>function StringBuffer.vsplitLines()<script>explorer.outline.addDecl("StringBuffer.vsplitLines");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="string.html#StringBuffer.splitLines">splitLines</a>, but instead of returning an array, returns the split lines as multiple return values. If <tt>this</tt> splits into more than 20 lines, an error will be thrown. Otherwise the behavior is identical to <a href="string.html#StringBuffer.splitLines">splitLines</a>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.repeat"></a>function StringBuffer.repeat(n: int)<script>explorer.outline.addDecl("StringBuffer.repeat");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new <tt>StringBuffer</tt> which is the concatenation of <tt>n</tt> instances of <tt>this</tt>. If <tt>n == 0</tt>, returns an empty <tt>StringBuffer</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if <tt>n &lt; 0</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.reverse"></a>function StringBuffer.reverse()<script>explorer.outline.addDecl("StringBuffer.reverse");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new <tt>StringBuffer</tt> whose contents are the reversal of <tt>this</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.strip"></a>function StringBuffer.strip()<script>explorer.outline.addDecl("StringBuffer.strip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new <tt>StringBuffer</tt> whose contents are the same as <tt>this</tt> but with any whitespace stripped from the beginning and end.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.lstrip"></a>function StringBuffer.lstrip()<script>explorer.outline.addDecl("StringBuffer.lstrip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new <tt>StringBuffer</tt> whose contents are the same as <tt>this</tt> but with any whitespace stripped from just the beginning of the string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.rstrip"></a>function StringBuffer.rstrip()<script>explorer.outline.addDecl("StringBuffer.rstrip");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new <tt>StringBuffer</tt> whose contents are the same as <tt>this</tt> but with any whitespace stripped from just the end of the string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.replace"></a>function StringBuffer.replace(from: string|StringBuffer, to: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.replace");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new <tt>StringBuffer</tt> where any occurrences in <tt>this</tt> of the string <tt>from</tt> are replaced with the string <tt>to</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.repeat!"></a>function StringBuffer.repeat!(n: int)<script>explorer.outline.addDecl("StringBuffer.repeat!");</script></span><br/><span class="decl"><a id="StringBuffer.reverse!"></a>function StringBuffer.reverse!()<script>explorer.outline.addDecl("StringBuffer.reverse!");</script></span><br/><span class="decl"><a id="StringBuffer.strip!"></a>function StringBuffer.strip!()<script>explorer.outline.addDecl("StringBuffer.strip!");</script></span><br/><span class="decl"><a id="StringBuffer.lstrip!"></a>function StringBuffer.lstrip!()<script>explorer.outline.addDecl("StringBuffer.lstrip!");</script></span><br/><span class="decl"><a id="StringBuffer.rstrip!"></a>function StringBuffer.rstrip!()<script>explorer.outline.addDecl("StringBuffer.rstrip!");</script></span><br/><span class="decl"><a id="StringBuffer.replace!"></a>function StringBuffer.replace!(from: string|StringBuffer, to: string|StringBuffer)<script>explorer.outline.addDecl("StringBuffer.replace!");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These are all <em>in-place</em> versions of their corresponding methods. They work identically, except instead of returning a new <tt>StringBuffer</tt> object leaving <tt>this</tt> unchanged, they replace the contents of <tt>this</tt> with their output.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.format"></a>function StringBuffer.format(fmt: string, vararg)<script>explorer.outline.addDecl("StringBuffer.format");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Just like <a href="string.html#string.format">string.format</a>, except the results are appended directly to the end of this <tt>StringBuffer</tt> without needing a string temporary.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.formatln"></a>function StringBuffer.formatln(fmt: string, vararg)<script>explorer.outline.addDecl("StringBuffer.formatln");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as <tt>format</tt>, but also appends the <tt>\n</tt> character after appending the formatted string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opSerialize"></a>function StringBuffer.opSerialize()<script>explorer.outline.addDecl("StringBuffer.opSerialize");</script></span><br/><span class="decl"><a id="StringBuffer.opDeserialize"></a>function StringBuffer.opDeserialize()<script>explorer.outline.addDecl("StringBuffer.opDeserialize");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>These allow instances of <tt>StringBuffer</tt> to be serialized by the <a href="serialization.html">serialization</a> library.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="StringBuffer.opApply"></a>function StringBuffer.opApply(reverse: string = null)<script>explorer.outline.addDecl("StringBuffer.opApply");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Lets you iterate over <tt>StringBuffer</tt>s with foreach loops just like strings. You can iterate in reverse, just like strings, by passing the string <tt>"reverse"</tt> as the second value in the foreach container:</p><p><div class="code"><pre><span class="k">local</span> <span class="n">sb</span> <span class="p">=</span> <span class="n">StringBuffer</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span> <span class="n">sb</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span> <span class="n">sb</span><span class="p">,</span> <span class="s">&quot;reverse&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// goes backwards</span>
</pre></div>
</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 15 Nov 2014 10:28:14	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("imgui");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>