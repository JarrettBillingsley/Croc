<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module text</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("text");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module text</h1><p>This library contains utilities for performing text encoding, decoding, and specialized output formatting.</p><p>Whereas the <tt>string</tt> library concerns itself with simple algorithmic operations on string objects, this module deals with the more "linguistic" aspects of text handling, such as converting between text encodings and displaying objects in human-readable forms.</p><p>This module exposes flexible interfaces, and the hope is that more text encodings and formatting options will be made available by second- and third-party libraries.</p><p><strong>Codec Error Handling</strong></p><p>The text codecs' encoding and decoding functions all take an optional argument to control the behavior of encoding and decoding when erroneous input is encountered. There are three error behaviors: <tt>"strict"</tt>, <tt>"ignore"</tt>, and <tt>"replace"</tt>. The default behavior is <tt>"strict"</tt>.</p><p>For encoding, the input text is always well-formed, since Croc strings are always valid sequences of Unicode codepoints. However, many text encodings only support a subset of all available Unicode codepoints, so the error handling mechanism is used when an unencodable character is encountered. If the error behavior is <tt>"strict"</tt>, a <tt>UnicodeError</tt> is thrown. If the error behavior is <tt>"ignore"</tt>, the unencodable character is simply skipped. If the error behavior is <tt>"replace"</tt>, the unencodable character is skipped, and a codec-defined replacement character is encoded in its place. Usually this will be a question mark character, but not necessarily.</p><p>For decoding, the input data may or may nor be well-formed; thus the error handling mechanism is used when malformed or invalid input is encountered. If the error behavior is <tt>"strict"</tt>, a <tt>UnicodeError</tt> is thrown. If the error behavior is <tt>"ignore"</tt>, the invalid input is skipped. If the error behavior is <tt>"replace"</tt>, the invalid input is skipped, and the Unicode Replacement Character (U+00FFFD) is used in its place.</p><p><strong>Built-in Encodings</strong></p><p>This library comes with a few encodings built-in. Here is a table of those encodings, as well as their aliases and what they are:</p><p><table><tr><td><p><strong>Name</strong></p></td><td><p><strong>Aliases</strong></p></td><td><p><strong>Description</strong></p></td></tr><tr><td><p><tt>"ascii"</tt></p></td><td><p></p></td><td><p>7-bit ASCII (no characters &gt; 127!).</p></td></tr><tr><td><p><tt>"latin1"</tt></p></td><td><p><tt>"latin-1", "iso8859-1", "cp819"</tt></p></td><td><p>An 8-bit encoding that maps exactly to the first 255 Unicode codepoints.</p></td></tr><tr><td><p><tt>"utf-8"</tt></p></td><td><p><tt>"utf8"</tt></p></td><td><p>UTF-8!</p></td></tr><tr><td><p><tt>"utf-8-sig"</tt></p></td><td><p><tt>"utf8-sig"</tt></p></td><td><p>UTF-8, but on encoding, a signature (0xEF 0xBB 0xBF) is prepended, and on decoding, any signature is stripped.</p></td></tr><tr><td><p><tt>"utf-16"</tt></p></td><td><p><tt>"utf16"</tt></p></td><td><p>UTF-16. On encoding, always outputs in native byte order with a BOM before the text. On decoding, checks for a BOM and can decode little- or big-endian UTF-16.</p></td></tr><tr><td><p><tt>"utf-16-be"</tt></p></td><td><p><tt>"utf16-be"</tt></p></td><td><p>Big-endian UTF-16. No BOM is written or read.</p></td></tr><tr><td><p><tt>"utf-16-le"</tt></p></td><td><p><tt>"utf16-le"</tt></p></td><td><p>Little-endian UTF-16. No BOM is written or read.</p></td></tr><tr><td><p><tt>"utf-32"</tt></p></td><td><p><tt>"utf32"</tt></p></td><td><p>UTF-32. On encoding, always outputs in native byte order with a BOM before the text. On decoding, checks for a BOM and can decode little- or big-endian UTF-32.</p></td></tr><tr><td><p><tt>"utf-32-be"</tt></p></td><td><p><tt>"utf32-be"</tt></p></td><td><p>Big-endian UTF-32. No BOM is written or read.</p></td></tr><tr><td><p><tt>"utf-32-le"</tt></p></td><td><p><tt>"utf32-le"</tt></p></td><td><p>Little-endian UTF-32. No BOM is written or read.</p></td></tr></table></p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="dumpVal"></a>global function dumpVal(val, printNewline: bool = true, output = console.stdout)<script>explorer.outline.addDecl("dumpVal");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Dumps an exhaustive string representation of the given value to the console. This is also exported in the global namespace for convenience.</p><p><ul><li><p><strong><tt>weakrefs</tt></strong> will be displayed as <tt>"weakref(value)"</tt> where <tt>value</tt> is the exhaustive representation of the value the weakref points to.</p></li><li><p><strong><tt>strings</tt></strong> will print non-printable and non-ASCII characters with Croc-like <tt>\uxxxx</tt> and <tt>\UXXXXXXXX</tt> escape sequences.</p></li><li><p><strong><tt>tables</tt> and <tt>arrays</tt></strong> will be recursed into safely, so you don't need to worry about infinite recursion.</p></li><li><p><strong><tt>namespaces</tt></strong> will have the names of their fields printed, but not the values.</p></li><li><p><strong>All other types</strong> will have <a href="misc.html#toString">toString</a> called on them.</p></li></ul></p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">val</td><td><p>is the value to print.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">printNewline</td><td><p>controls whether or not a newline will be output after the representation.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">output</td><td><p>should be a <a href="stream.html#TextWriter">stream.TextWriter</a>-like object which implements <tt>write</tt>, <tt>writeln</tt>, and <tt>flush</tt> methods.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="charUtf8Length"></a>global function charUtf8Length(c: string)<script>explorer.outline.addDecl("charUtf8Length");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the number of bytes needed to encode the first codepoint of the given string in UTF-8, or 0 if the codepoint is out of the valid range of Unicode.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="utf8SequenceLength"></a>global function utf8SequenceLength(firstByte: int)<script>explorer.outline.addDecl("utf8SequenceLength");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Given the value of an initial UTF-8 code unit, returns how many bytes long this character is, or 0 if this is an invalid initial code unit.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">exceptions.RangeError</a></td><td><p>if <tt>firstByte</tt> is not in the range <tt>[0 .. 255]</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF8"></a>global BOM_UTF8 = memblock.fromArray([0xEF 0xBB 0xBF])<script>explorer.outline.addDecl("BOM_UTF8");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>UTF-8 "BOM", not so much a byte-order mark as it is a UTF-8 tag. Sometimes appears at the beginning of UTF-8 encoded text.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF8_STR"></a>global BOM_UTF8_STR = "\uFEFF"<script>explorer.outline.addDecl("BOM_UTF8_STR");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A string representation of the above.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF16_LE"></a>global BOM_UTF16_LE = memblock.fromArray([0xFF 0xFE])<script>explorer.outline.addDecl("BOM_UTF16_LE");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Little-endian UTF-16 BOM.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF16_BE"></a>global BOM_UTF16_BE = memblock.fromArray([0xFE 0xFF])<script>explorer.outline.addDecl("BOM_UTF16_BE");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Big-endian UTF-16 BOM.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF32_LE"></a>global BOM_UTF32_LE = memblock.fromArray([0xFF 0xFE 0x00 0x00])<script>explorer.outline.addDecl("BOM_UTF32_LE");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Little-endian UTF-32 BOM.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF32_BE"></a>global BOM_UTF32_BE = memblock.fromArray([0x00 0x00 0xFE 0xFF])<script>explorer.outline.addDecl("BOM_UTF32_BE");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Big-endian UTF-32 BOM.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BOM_UTF16"></a>global BOM_UTF16<script>explorer.outline.addDecl("BOM_UTF16");</script></span><br/><span class="decl"><a id="BOM_UTF16_BS"></a>global BOM_UTF16_BS<script>explorer.outline.addDecl("BOM_UTF16_BS");</script></span><br/><span class="decl"><a id="BOM_UTF32"></a>global BOM_UTF32<script>explorer.outline.addDecl("BOM_UTF32");</script></span><br/><span class="decl"><a id="BOM_UTF32_BS"></a>global BOM_UTF32_BS<script>explorer.outline.addDecl("BOM_UTF32_BS");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Native and byte-swapped UTF-16 and UTF-32 BOMs. These are just aliases for the above globals, and which is "native" and which is "byte-swapped" is determined automatically for you.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="detectBOM"></a>global function detectBOM(mb: memblock, lo: int = 0, hi: int = #mb)<script>explorer.outline.addDecl("detectBOM");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Given a slice of a memblock containing encoded text, detects any BOMs at the beginning of the text, returning which UTF encoding it believes the text to be in.</p><p>If there is no BOM, or if the memblock is too short to contain one, returns <tt>null</tt>.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">mb</td><td><p>is the memblock to test.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">lo</td><td><p>and</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">hi</td><td><p>define the slice of <tt>mb</tt> to test.</p></td></tr></table><p><strong>Returns:</strong> <p>one of <tt>"utf-8"</tt>, <tt>"utf-16"</tt>, <tt>"utf-32"</tt>, or <tt>null</tt>. This doesn't return <tt>"utf-16-be"</tt> or the like, as those codecs do not expect a BOM at the beginning.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#BoundsError">BoundsError</a></td><td><p>if <tt>lo</tt> or <tt>hi</tt> are invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="registerCodec"></a>global function registerCodec(name: string, codec)<script>explorer.outline.addDecl("registerCodec");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Register a text codec of the given name. The codec can then be retrieved with <a href="text.html#getCodec">getCodec</a>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#LookupError">exceptions.LookupError</a></td><td><p>if there is already a codec registered named <tt>name</tt>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="aliasCodec"></a>global function aliasCodec(name: string, vararg)<script>explorer.outline.addDecl("aliasCodec");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Re-registers an already-registered codec with one or more alternate names.</p><p>For instance, if you wanted the codec "foobar" to be accessible also as "foo-bar" or "FOOBAR", you could use:</p><p><div class="code"><pre><span class="n">aliasCodec</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="s">&quot;foo-bar&quot;</span><span class="p">,</span> <span class="s">&quot;FOOBAR&quot;</span><span class="p">)</span>
</pre></div>
Then <tt>getCodec("foo-bar")</tt> and <tt>getCodec("FOOBAR")</tt> would give the same codec as <tt>getCodec("foobar")</tt>.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">name</td><td><p>is the name of the codec to alias. It must have been previously registered with <a href="text.html#registerCodec">registerCodec</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">vararg</td><td><p>is one or more strings that will be registered as aliases to the given codec.</p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ParamError">exceptions.ParamError</a></td><td><p>if you don't pass at least one variadic argument.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#TypeError">exceptions.TypeError</a></td><td><p>if any of the variadic arguments are not strings.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="getCodec"></a>global function getCodec(name: string)<script>explorer.outline.addDecl("getCodec");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the codec object that was registered with the given name.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#LookupError">exceptions.LookupError</a></td><td><p>if there was no codec registered with the given name.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="getAllCodecNames"></a>global function getAllCodecNames()<script>explorer.outline.addDecl("getAllCodecNames");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets an alphabetically sorted array of the names of all available codecs (including aliases).</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="getAllCodecs"></a>global function getAllCodecs()<script>explorer.outline.addDecl("getAllCodecs");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets an alphabetically sorted array of arrays. Each sub-array has the name of the codec as the first element and the codec itself as the second.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="hasCodec"></a>global function hasCodec(name: string)<script>explorer.outline.addDecl("hasCodec");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>whether or not a codec of the given name has been registered.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec"></a>class TextCodec<script>explorer.outline.addDecl("TextCodec");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The base class for all text codecs which are registered with this module. This class defines an interface which all codecs must implement.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.name"></a>TextCodec.name = ""<script>explorer.outline.addDecl("TextCodec.name");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The name of the text encoding that this codec implements.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.encodeInto"></a>function TextCodec.encodeInto(str: string, dest: memblock, start: int, errors: string = "strict")<script>explorer.outline.addDecl("TextCodec.encodeInto");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Encodes a string object into a string encoding, placing the encoded data into a memblock.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">str</td><td><p>is the string to be encoded.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">dest</td><td><p>is the memblock that will hold the encoded data. The memblock will be resized so that the end of the memblock coincides with the end of the encoded data. The beginning of the encoded data is specified by..</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">start</td><td><p>..this parameter. This is the byte offset into <tt>dest</tt> where the first byte of encoded data will be placed. This can be equal to <tt>#dest</tt>, which means the encoded data will be appended to the end of <tt>dest</tt>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">errors</td><td><p>controls the error handling behavior of the encoder; see this module's docs for more info.</p></td></tr></table><p><strong>Returns:</strong> <p><tt>dest</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.encode"></a>function TextCodec.encode(str: string, errors: string = "strict")<script>explorer.outline.addDecl("TextCodec.encode");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as calling <a href="text.html#TextCodec.encodeInto">encodeInto</a> with a new, empty memblock and a starting index of 0.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.decodeRange"></a>function TextCodec.decodeRange(src: memblock, lo: int, hi: int, errors: string = "strict")<script>explorer.outline.addDecl("TextCodec.decodeRange");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Decodes an encoded string from a memblock into a string.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">src</td><td><p>is the memblock that holds the encoded string data.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">lo</td><td><p>and</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">hi</td><td><p>are slice indices into <tt>src</tt>; this slice is the data to be decoded.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">errors</td><td><p>controls the error handling behavior of the decoder; see this module's docs for more info.</p></td></tr></table><p><strong>Returns:</strong> <p>the decoded text as a string.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">exceptions.ValueError</a></td><td><p>if the given slice of data cannot be consumed in its entirety, such as if there is an incomplete character encoding at the end of the data. If you need to be able to decode data piecemeal, such as in a stream decoding situation, this is what <a href="text.html#TextCodec.incrementalDecoder">incrementalDecoder</a> is for.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.decode"></a>function TextCodec.decode(src: memblock, errors: string = "strict")<script>explorer.outline.addDecl("TextCodec.decode");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as calling <a href="text.html#TextCodec.decodeRange">decodeRange</a> with a slice of the entire memblock.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.incrementalEncoder"></a>function TextCodec.incrementalEncoder(errors: string = "strict")<script>explorer.outline.addDecl("TextCodec.incrementalEncoder");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new instance of a class derived from <a href="text.html#IncrementalEncoder">IncrementalEncoder</a> that allows you to encode a stream of text incrementally. See that class's docs for more info.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="TextCodec.incrementalDecoder"></a>function TextCodec.incrementalDecoder(errors: string = "strict")<script>explorer.outline.addDecl("TextCodec.incrementalDecoder");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>a new instance of a class derived from <a href="text.html#IncrementalDecoder">IncrementalDecoder</a> that allows you to decode a stream of text incrementally. See that class's docs for more info.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalEncoder"></a>class IncrementalEncoder<script>explorer.outline.addDecl("IncrementalEncoder");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The base class for incremental text encoders, which are returned from <a href="text.html#TextCodec.incrementalEncoder">TextCodec.incrementalEncoder</a> methods.</p><p>An incremental encoder does the same thing as <a href="text.html#TextCodec.encodeInto">TextCodec.encodeInto</a> except its operation can be split up over multiple calls instead of being done all at once. This way large pieces of data can be encoded without having to have either the source or the output entirely in memory.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalEncoder.this"></a>IncrementalEncoder.this(errors: string = "strict")<script>explorer.outline.addDecl("IncrementalEncoder.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Instead of specifying the error behavior on each call, incremental encoders have it specified once in the constructor.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalEncoder.encodeInto"></a>function IncrementalEncoder.encodeInto(str: string, dest: memblock, start: int, final: bool = false)<script>explorer.outline.addDecl("IncrementalEncoder.encodeInto");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="text.html#TextCodec.encodeInto">TextCodec.encodeInto</a>.</p><p>The <tt>final</tt> parameter tells the function whether or not this is the last piece of string to be encoded. This way the encoder can throw an error if there's insufficient input or whatever. Also, if the <tt>final</tt> parameter is true, the encoder is expected to be reset to its initial state after this method returns.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">str</td><td><p>same as in <a href="text.html#TextCodec.encodeInto">TextCodec.encodeInto</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">dest</td><td><p>same as in <a href="text.html#TextCodec.encodeInto">TextCodec.encodeInto</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">start</td><td><p>same as in <a href="text.html#TextCodec.encodeInto">TextCodec.encodeInto</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">final</td><td><p>is explained above.</p></td></tr></table><p><strong>Returns:</strong> <p><tt>dest</tt>.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalEncoder.encode"></a>function IncrementalEncoder.encode(str: string, final: bool = false)<script>explorer.outline.addDecl("IncrementalEncoder.encode");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as caling <a href="text.html#IncrementalEncoder.encodeInto">encodeInto</a> with a new, empty memblock and a starting index of 0.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalEncoder.reset"></a>function IncrementalEncoder.reset()<script>explorer.outline.addDecl("IncrementalEncoder.reset");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Resets any internal state to its initial state so that this encoder object can be used to encode a new string. This will be called automatically by <a href="text.html#IncrementalEncoder.encodeInto">encodeInto</a> if its <tt>final</tt> param was <tt>true</tt>.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalDecoder"></a>class IncrementalDecoder<script>explorer.outline.addDecl("IncrementalDecoder");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The base class for incremental text decoders, which are returned from <a href="text.html#TextCodec.incrementalDecoder">TextCodec.incrementalDecoder</a> methods.</p><p>An incremental decoder does the same thing as <a href="text.html#TextCodec.decodeRange">TextCodec.decodeRange</a> except its operation can be split up over multiple calls instead of being done all at once. This way large pieces of data can be decoded without having to have either the source or the output entirely in memory.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalDecoder.this"></a>IncrementalDecoder.this(errors: string = "strict")<script>explorer.outline.addDecl("IncrementalDecoder.this");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Instead of specifying the error behavior on each call, incremental decoders have it specified once in the constructor.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalDecoder.decodeRange"></a>function IncrementalDecoder.decodeRange(src: memblock, lo: int, hi: int, final: bool = false)<script>explorer.outline.addDecl("IncrementalDecoder.decodeRange");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Similar to <a href="text.html#TextCodec.decodeRange">TextCodec.decodeRange</a>.</p><p>The <tt>final</tt> parameter tells the function whether or not this is the last piece of string to be decoded. This way the decoder can throw an error if there's insufficient input or whatever. Also, if the <tt>final</tt> parameter is true, the decoder is expected to be reset to its initial state after this method returns.</p><p>If the given slice of data ends with an incomplete character encoding, it is the decoder's responsibility to keep this data around for the next call to this method. Then it can resume decoding by using the stored data as the beginning of the next character.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">src</td><td><p>same as in <a href="text.html#TextCodec.decodeRange">TextCodec.decodeRange</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">lo</td><td><p>same as in <a href="text.html#TextCodec.decodeRange">TextCodec.decodeRange</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">hi</td><td><p>same as in <a href="text.html#TextCodec.decodeRange">TextCodec.decodeRange</a>.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">final</td><td><p>is explained above.</p></td></tr></table><p><strong>Returns:</strong> <p>as much of the data as could be decoded as a string.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalDecoder.decode"></a>function IncrementalDecoder.decode(src: memblock, final: bool = false)<script>explorer.outline.addDecl("IncrementalDecoder.decode");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Same as calling <a href="text.html#IncrementalDecoder.decodeRange">decodeRange</a> with a slice of the entire memblock.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="IncrementalDecoder.reset"></a>function IncrementalDecoder.reset()<script>explorer.outline.addDecl("IncrementalDecoder.reset");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Resets any internal state to its initial state so that this encoder object can be used to encode a new string. This will be called automatically by <a href="text.html#IncrementalDecoder.decodeRange">decodeRange</a> if its <tt>final</tt> param was <tt>true</tt>.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedIncrementalDecoder"></a>class BufferedIncrementalDecoder : IncrementalDecoder<script>explorer.outline.addDecl("BufferedIncrementalDecoder");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>A base class for incremental decoders which share a common behavior: needing to save partial character encodings from the end of a data block for use in the next call.</p><p>Subclasses need only implement the <a href="text.html#BufferedIncrementalDecoder._bufferedDecode">_bufferedDecode</a> method.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedIncrementalDecoder._bufferedDecode"></a>function BufferedIncrementalDecoder._bufferedDecode(src: memblock, lo: int, hi: int, errors: string = "strict", final: bool = false)<script>explorer.outline.addDecl("BufferedIncrementalDecoder._bufferedDecode");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Subclasses just implement this method. Note that it takes both an <tt>errors</tt> parameter <em>and</em> a <tt>final</tt> parameter.</p><p>This method should return two values. The first is the decoded string (or the empty string if there was not enough data to decode anything). The second is the number of bytes of the given slice that were consumed during decoding.</p><p>When this method is given a memblock slice, it's possible that there is incomplete encoded data at the end of the slice. For instance, in a multibyte character encoding scheme (like UTF-8), there might only be the first byte of a four-byte character at the end of the slice. Suppose the slice is 16 bytes long. In this case, this method would return the decoded version of the first 15 bytes, then the number 15 (to indicate that only 15 of 16 bytes were decoded).</p><p>With this information, this class can save that 1 byte into an internal buffer, and then on the next call to <a href="text.html#BufferedIncrementalDecoder.decodeRange">decodeRange</a>, it will concatenate that byte to the front of the new input slice, and call this method with the concatenated data.</p><p>If all the bytes were decoded from the given slice, then this method should return <tt>hi - lo</tt> as the number of bytes consumed.</p><p><strong>Returns:</strong> <p>two values: the decoded string (or an empty string if nothing was decoded) and the number of bytes consumed from the given slice of the memblock.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="BufferedIncrementalDecoder.decodeRange"></a>function BufferedIncrementalDecoder.decodeRange(src: memblock, lo: int, hi: int, final: bool = false)<script>explorer.outline.addDecl("BufferedIncrementalDecoder.decodeRange");</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Implementation of the <a href="text.html#IncrementalDecoder.decodeRange">IncrementalDecoder.decodeRange</a> method.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 15 Nov 2014 10:28:14	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("imgui");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>