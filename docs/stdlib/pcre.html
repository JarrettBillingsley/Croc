<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="text/javascript" http-equiv="content-script-type"><title>module pcre</title><link rel="stylesheet" type="text/css" href="candydoc/style.css"><link rel="stylesheet" type="text/css" href="candydoc/code.css"><script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script><script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script></head><body><div id="everything"><div id="tabarea"></div><div id="explorerclient"></div><div id="content"><script>explorer.initialize("pcre");</script>	<img src="candydoc/img/banner.gif" alt="The Croc Programming Language"></img>	<div id="docbody">		<h1>module pcre</h1><p>PCREs, or Perl-compatible regular expressions, are the <em>de facto</em> standard in regular expression text processing. This module exposes a regular expression class which wraps the <a href="http://www.pcre.org/">libpcre</a> library. Not all features are supported at this time, but more may be added in the future.</p><p><strong>Prerequisites</strong></p><p>This module loads libpcre dynamically when it's first imported. On Windows, this can be <tt>libpcre.dll</tt> or <tt>pcre.dll</tt>; on Linux, <tt>libpcre.so.3</tt> or <tt>libpcre.so</tt>; and on OSX <tt>libpcre.dylib</tt>. The shared library is loaded from the usual places.</p><p>The loaded library must be <strong>libpcre version 7.4 or higher, built with UTF-8 support.</strong> Support for Unicode Properites isn't necessary, just UTF-8. This library will check that the version of libpcre that was loaded meets these requirements after loading it. If the shared library is not suitable, a <a href="exceptions.html#RuntimeError">RuntimeError</a> will be thrown.</p><p><strong>Windows:</strong> building libpcre manually is kind of a pain, and as far as I know the only project that provides binaries of libpcre is GnuWin32, but for some reason they haven't built a version of it since 7.0 in 2007. To save you the hassle, I've compiled a compatible DLL of 7.4, available <a href="https://github.com/JarrettBillingsley/Croc/blob/master/libpcre.dll?raw=true">here</a>. (<strong>Note:</strong> you must have the <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=9b2da534-3e03-4391-8a4d-074b9f2bc1bf&displaylang=en">VC++2008 redist installed</a> for this DLL to work. This is a very tiny download and fast install.)</p><p><strong>Including this library in the host</strong></p><p>To use this library, the host must have it compiled into it. Compile Croc with the <tt>CROC_PCRE_ADDON</tt> option enabled in the CMake configuration. Then, from your host, when setting up the VM use the <tt>croc_vm_loadAddons</tt> or <tt>croc_vm_loadAllAvailableAddons</tt> API functions to load this library into the VM. Then from your Croc code, you can just <tt>import pcre</tt> to access it.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex"></a>class Regex<script>explorer.outline.addDecl('Regex');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Wraps a PCRE regex object.</p><script>explorer.outline.incSymbolLevel();</script><dl><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.this"></a>Regex.this(pattern: string, attrs: string = '')<script>explorer.outline.addDecl('Regex.this');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Compiles a regular expression.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">pattern</td><td><p>is the regular expression to be compiled. See the PCRE documentation for the syntax.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">attrs</td><td><p>is a string containing attributes with which to compile this regex. It can contain any of the following characters, in any order:</p><p><dl><dt><tt>'i'</tt></dt><dd><p>Case-insensitive. Any literal characters or character classes will match either case.</p></dd><dt><tt>'s'</tt></dt><dd><p>The dot pattern will match all characters including newlines (which it normally doesn't).</p></dd><dt><tt>'m'</tt></dt><dd><p>Multiline. Normally the <tt>^</tt> and <tt>$</tt> patterns will match the beginning and end of the string. With this modifier, they will match the beginning and end of each line in the subject string.</p></dd></dl></p></td></tr></table><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#StateError">StateError</a></td><td><p>if you attempt to call this constructor on an already-initialized object.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#ValueError">ValueError</a></td><td><p>if the <tt>pattern</tt> could not be compiled.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.finalizer"></a>function Regex.finalizer()<script>explorer.outline.addDecl('Regex.finalizer');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Cleans up the underlying C PCRE objects.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.numGroups"></a>function Regex.numGroups()<script>explorer.outline.addDecl('Regex.numGroups');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>the number of matched subgroups. This will be 0 if <a href="pcre.html#Regex.test">test</a> returned <tt>false</tt>, or a number greater than 0 otherwise.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.groupNames"></a>function Regex.groupNames()<script>explorer.outline.addDecl('Regex.groupNames');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p><strong>Returns:</strong> <p>an array of strings of named groups.</p><p>Named groups are created with the <tt>"(?P&lt;name&gt;pattern)"</tt> regex syntax. So, if you compiled something like <tt>@"(?P&lt;lname&gt;\w+), (?P&lt;fname&gt;\w+)"</tt>, this function would return an array containing the strings <tt>"lname"</tt> and <tt>"fname"</tt> (though not in any particular order).</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.test"></a>function Regex.test(subject: string = null)<script>explorer.outline.addDecl('Regex.test');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>The workhorse of the regex engine, this gets the next match of the regex within the current subject string.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">subject</td><td><p>is the optional new subject string. If you don't pass one, this will continue testing on the current subject string. If you do, it's the same as doing <tt>re.search(subject).test()</tt>.</p></td></tr></table><p><strong>Returns:</strong> <p><tt>true</tt> if a new match was found in the subject string. In this case it updates all the matches which can be retrieved using various other methods. Returns <tt>false</tt> if no more matches were found.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.search"></a>function Regex.search(subject: string)<script>explorer.outline.addDecl('Regex.search');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Sets the subject string and resets all match groups, but does not start looking for matches. You'll have to use <a href="pcre.html#Regex.test">test</a> or iterate over the matches with a <tt>foreach</tt> loop.</p><p><strong>Returns:</strong> <p>this regex object, to make it easier to use as the container in a <tt>foreach</tt> loop.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.pre"></a>function Regex.pre(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.pre');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the slice of the subject string that comes before the given subgroup match.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>works just like in <a href="pcre.html#Regex.match">match</a>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.match"></a>function Regex.match(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.match');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the most recent match of the regex and its subgroups within the subject string.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>can be the integer index of a subgroup, where index 0 is the entire regex and 1, 2, etc. are the subgroups in order of where they appear in the regex. Alternatively, if you've named subgroups, you can get them by name; only names returned from <a href="pcre.html#Regex.groupNames">groupNames</a> are valid.</p></td></tr></table><p><strong>Returns:</strong> <p>the slice of the subject string which was matched by the given regex group.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#StateError">StateError</a></td><td><p>if there are no more matches (<a href="pcre.html#Regex.test">test</a> returned <tt>false</tt>).</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#RangeError">RangeError</a></td><td><p>if the given integral subgroup index is invalid.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#NameError">NameError</a></td><td><p>if the given string subgroup name is invalid.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.post"></a>function Regex.post(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.post');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the slice of the subject string that comes after the given subgroup match.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>works just like in <a href="pcre.html#Regex.match">match</a>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.preMatchPost"></a>function Regex.preMatchPost(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.preMatchPost');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets three pieces of the string: the part that comes before the given subgroup match, the match itself, and the part that comes after. This is slightly more efficient than calling <a href="pcre.html#Regex.pre">pre</a>, <a href="pcre.html#Regex.match">match</a>, and <a href="pcre.html#Regex.post">post</a> separately if you need two or all three parts.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>works just like in <a href="pcre.html#Regex.match">match</a>.</p></td></tr></table><p><strong>Returns:</strong> <p>the pre, match, and post strings in that order.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.matchBegin"></a>function Regex.matchBegin(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.matchBegin');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the character index into the subject string where the given subgroup match begins.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>works just like in <a href="pcre.html#Regex.match">match</a>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.matchEnd"></a>function Regex.matchEnd(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.matchEnd');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the character index into the subject string where the given subgroup match ends.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>works just like in <a href="pcre.html#Regex.match">match</a>.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.matchBeginEnd"></a>function Regex.matchBeginEnd(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.matchBeginEnd');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Gets the character indices into the subject string where the given subgroup match begins and ends.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">idx</td><td><p>works just like in <a href="pcre.html#Regex.match">match</a>.</p></td></tr></table><p><strong>Returns:</strong> <p>the begin and end indices in that order.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.find"></a>function Regex.find(subject: string)<script>explorer.outline.addDecl('Regex.find');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Searches for the first match of this regex in the given subject string.</p><p>This is basically the same as <tt>re.search(subject).test() ? re.matchBegin() : #subject</tt>.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">subject</td><td><p>will be set as the new subject string.</p></td></tr></table><p><strong>Returns:</strong> <p>the index into the subject string where the first match of this regex was found, or <tt>#subject</tt> if not.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.split"></a>function Regex.split(subject: string)<script>explorer.outline.addDecl('Regex.split');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Splits <tt>subject</tt> into an array of pieces, using entire matches of this regex as the delimiters.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">subject</td><td><p>will be set as the new subject string.</p></td></tr></table><p><strong>Returns:</strong> <p>the array of split-up components. This will have only one element if the regex did not match.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.replace"></a>function Regex.replace(subject: string, repl: string|function)<script>explorer.outline.addDecl('Regex.replace');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>Perform a search-and-replace on <tt>subject</tt> using this regex as the search term.</p><p><strong>Params:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">subject</td><td><p>will be set as the new subject string.</p></td></tr><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px">repl</td><td><p>can be a string, in which case any matches of this regex will be replaced with <tt>repl</tt> verbatim.</p><p><tt>repl</tt> can also be a function. In this case, it should take a single parameter which will be this regex object (through which it can access the match), and should return a single string to be used as the replacement.</p></td></tr></table><p><strong>Returns:</strong> <p>a new string with all occurrences of this regex replaced with <tt>repl</tt>.</p><p><strong>Throws:</strong> <table class="params"><tr><td class="paramname" nowrap valign="top" style="padding-right: 8px"><a href="exceptions.html#TypeError">TypeError</a></td><td><p>if <tt>repl</tt> is a function and it returns anything other than a string.</p></td></tr></table></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.opApply"></a>function Regex.opApply()<script>explorer.outline.addDecl('Regex.opApply');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>This allows you to iterate over all the matches of this regex in the subject string with a <tt>foreach</tt> loop. To set the subject string, you can use <a href="pcre.html#Regex.search">search</a>, which conveniently returns this regex object.</p><p>In the loop, there will be two indices: the first being the 0-based index of the match (that is, the number of times this regex has matched in the subject string), and the second being this regex object itself. For example:</p><p><div class="code"><pre><span class="k">local</span> <span class="n">re</span> <span class="p">=</span> <span class="n">pcre</span><span class="p">.</span><span class="n">Regex</span><span class="p">$</span> <span class="s">@&quot;(\w+)\s?=\s?(\w+)&quot;</span>
<span class="k">local</span> <span class="n">subject</span> <span class="p">=</span>
<span class="s">&quot;foo = bar</span>
<span class="s">baz= quux&quot;</span>

<span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">subject</span><span class="p">))</span>
	<span class="n">writefln</span><span class="p">$</span> <span class="s">&quot;{}: key = &#39;{}&#39;, value = &#39;{}&#39;&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">m</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
This will print out:</p><p><pre>0: key = 'foo', value = 'bar'
1: key = 'baz', value = 'quux'</pre>Note that <tt>opApply</tt> is just defined in terms of <a href="pcre.html#Regex.test">test</a>. You can also iterate through all matches by doing something like this:</p><p><div class="code"><pre><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">subject</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="k">local</span> <span class="n">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">re</span><span class="p">.</span><span class="n">test</span><span class="p">();</span> <span class="n">i</span><span class="p">++)</span>
	<span class="n">writefln</span><span class="p">$</span> <span class="s">&quot;{}: key = &#39;{}&#39;, value = &#39;{}&#39;&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
Given the same regex and subject string, this will print out the same thing as the previous example.</p></dd><script>explorer.outline.writeEnabled = true;</script><dt><span class="decl"><a id="Regex.opIndex"></a>function Regex.opIndex(idx: int|string = 0)<script>explorer.outline.addDecl('Regex.opIndex');</script></span><script>explorer.outline.writeEnabled = false;</script></dt><dd><p>An alias for <a href="pcre.html#Regex.match">match</a>, so <tt>re[4]</tt> is the same as <tt>re.match(4)</tt>, and <tt>re['lname']</tt> is the same as <tt>re.match('lname')</tt>. You can't write <tt>re[]</tt> for the whole match, though, since that's a full-slice, not indexing.</p></dd></dl><script>explorer.outline.decSymbolLevel();</script></dd></dl><script>explorer.outline.decSymbolLevel();</script>	</div><div id="docfooter">		HTML and JavaScript source derived from 		<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">		by Victor Nakoryakov; Page generated on 12 Oct 2014 15:09:57	</div></div><script>	explorer.packageExplorer.addModuleFull("array");	explorer.packageExplorer.addModuleFull("ascii");	explorer.packageExplorer.addModuleFull("compiler");	explorer.packageExplorer.addModuleFull("console");	explorer.packageExplorer.addModuleFull("debug");	explorer.packageExplorer.addModuleFull("devil");	explorer.packageExplorer.addModuleFull("docs");	explorer.packageExplorer.addModuleFull("doctools.console");	explorer.packageExplorer.addModuleFull("doctools.output");	explorer.packageExplorer.addModuleFull("doctools.trac");	explorer.packageExplorer.addModuleFull("env");	explorer.packageExplorer.addModuleFull("exceptions");	explorer.packageExplorer.addModuleFull("file");	explorer.packageExplorer.addModuleFull("gc");	explorer.packageExplorer.addModuleFull("gl");	explorer.packageExplorer.addModuleFull("glfw");	explorer.packageExplorer.addModuleFull("hash");	explorer.packageExplorer.addModuleFull("json");	explorer.packageExplorer.addModuleFull("math");	explorer.packageExplorer.addModuleFull("memblock");	explorer.packageExplorer.addModuleFull("misc");	explorer.packageExplorer.addModuleFull("modules");	explorer.packageExplorer.addModuleFull("object");	explorer.packageExplorer.addModuleFull("openal");	explorer.packageExplorer.addModuleFull("os");	explorer.packageExplorer.addModuleFull("path");	explorer.packageExplorer.addModuleFull("pcre");	explorer.packageExplorer.addModuleFull("repl");	explorer.packageExplorer.addModuleFull("serialization");	explorer.packageExplorer.addModuleFull("stream");	explorer.packageExplorer.addModuleFull("string");	explorer.packageExplorer.addModuleFull("text");	explorer.packageExplorer.addModuleFull("thread");	explorer.packageExplorer.addModuleFull("time");</script></div></body></html>